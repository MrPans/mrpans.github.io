<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PPPan&#39;s 平凡之路</title>
  
  <subtitle>做一个互联网内容的贡献者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shengpan.net/"/>
  <updated>2017-07-10T20:57:31.000Z</updated>
  <id>https://shengpan.net/</id>
  
  <author>
    <name>PPPan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>全站 HTTPS 边做边记</title>
    <link href="https://shengpan.net/2016/10/07/https/"/>
    <id>https://shengpan.net/2016/10/07/https/</id>
    <published>2016-10-07T06:32:00.000Z</published>
    <updated>2017-07-10T20:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>没错，这是一篇可以 Step by Step 跟着做的操作指南。</p><p>keyword: <strong>Let’s Encrypt</strong>, <strong>Ubuntu 14.04</strong>, <strong>Nginx</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 HTTPS 可以先看看鹅厂的<a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=402615812&amp;idx=1&amp;sn=b6dae639119bb66e7025321254b8d973&amp;scene=1&amp;srcid=122439MA3l7gRwfjgNOB76pA#rd" target="_blank" rel="noopener">这篇文章</a>涨涨姿势。</p><p>我们知道 HTTPS 需要一个 CA 来解决信息抵赖和中间人攻击的隐患。<strong>Let’s Encrypt</strong> 就是一个 CA。它的优势在于免费、被绝大多数浏览器认可、高度自动化。这么好的一个 CA 摆在这里，还多说什么呢，开搞。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>操作系统: Ubuntu 14.04</li><li>代理服务器: Nginx</li><li>权限: 拥有 Shell 权限</li></ul><h2 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h2><p>我们采用官方推荐的自动化工具 <a href="https://certbot.eff.org" target="_blank" rel="noopener">Certbot</a>来进行全自动化的申请。</p><p>首先下载 Certbot, 并修改相关权限.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure><p>下载完成后，先关闭 Nginx 服务。因为我们将采用独立模式来安装证书。在独立模式下，certbot-auto 需要占用 80 端口，因此我们需要先暂时关闭 Nginx 来释放 80 端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx stop</span><br></pre></td></tr></table></figure><p>运行 certbot-auto 命令申请证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./path/to/certbot-auto certonly --standalone -d example.com -d www.example.com</span><br></pre></td></tr></table></figure><p><code>-d</code> 后面的参数是你需要用 HTTPS 访问的域名。这里不支持通配符，所以子域名比较多的同学得费力都填满了。</p><p>运行过程中，会弹出窗口让你填写邮箱。Let’s Encrypt 的证书的有效期是 90 天。在证书过期后，他们会往这个邮箱发送提醒。</p><p>填完邮箱并接收用户协议后，就会进入如下界面。这说明开始申请并下载证书了。</p><p><img src="/content/images/2016/10/get-cer.png" alt=""></p><p>稍等片刻，如果出现以下提示，则表示证书申请成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at</span><br><span class="line">   /etc/letsencrypt/live/shengpan.net/fullchain.pem. Your cert will</span><br><span class="line">   expire on 2017-01-05. To obtain a new or tweaked version of this</span><br><span class="line">   certificate <span class="keyword">in</span> the future, simply run certbot-auto again. To</span><br><span class="line">   non-interactively renew *all* of your certificates, run</span><br><span class="line">   <span class="string">"certbot-auto renew"</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">'s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure><p>你可以在上述信息中找到证书存放的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/letsencrypt/live/shengpan.net/fullchain.pem</span><br></pre></td></tr></table></figure><p>这在后面的 Nginx 配置中会用到。</p><h2 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h2><p>找到 Nginx 的配置文件，添加 ssl 配置。以我的 Ghost 博客为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">listen 443 ssl;</span><br><span class="line">    server_name shengpan.net; </span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/shengpan.net/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/shengpan.net/privkey.pem;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_ciphers AES256+EECDH:AES256+EDH:!aNULL;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header   Host      $http_host;</span><br><span class="line">        proxy_pass         http://127.0.0.1:2368;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>server_name</code> 改为你的域名，<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 分别改为你的公私钥路径。</p><h4 id="兼容-HTTP"><a href="#兼容-HTTP" class="headerlink" title="兼容 HTTP"></a>兼容 HTTP</h4><p>有可能你的网站在启用 HTTPS 之前已经在某些地方留下过 HTTP 的链接了，而你又不希望这些链接失效，就需要做一些兼容。</p><p>如果你希望全站都使用 HTTPS 访问，只需要把 HTTP 请求重定向到 HTTPS 上即可。在 Nginx 配置文件中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name shengpan.net; </span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你希望用户可以同时使用 HTTPS 和 HTTP 访问，只需要在配置文件中简单地添加一行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen 443 ssl;</span><br><span class="line">listen 80; # 添加这一行即可</span><br><span class="line">server_name shengpan.net;</span><br></pre></td></tr></table></figure><p>最后我们重启一下 Nginx 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure><p>在浏览器中输入你的域名看看吧！</p><h2 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h2><p>Let’s Encrypt 颁发的证书只有 90 天的有效期，过了有效期需要续期。幸运的是 Cerbot 已经帮我们打理好了这一切，只需要一句命令行就可以为你的证书续期。</p><blockquote><p>To non-interactively renew <em>all</em> of your certificates, run “certbot-auto renew”</p></blockquote><p>当然，这句命令行还可以交给计划任务去做，以自动续期。Linux 下我们使用 Cron 实现这一功能。</p><h4 id="启动-cron-服务"><a href="#启动-cron-服务" class="headerlink" title="启动 cron 服务"></a>启动 cron 服务</h4><p>通常 ubuntu 下自带 cron，如果没有也可以通过以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install cron</span><br></pre></td></tr></table></figure><p>若已经安装，输入以下命令判断 cron 服务是否启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pgrep cron</span><br></pre></td></tr></table></figure><p>如果有 pid （一串数字）输出则说明 cron 服务已经启动，没有任何输出说明需要手动启动 cron 服务。<br>启动 cron 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service cron start</span><br></pre></td></tr></table></figure><h4 id="编写需要运行的脚本"><a href="#编写需要运行的脚本" class="headerlink" title="编写需要运行的脚本"></a>编写需要运行的脚本</h4><p>首先新建一个脚本文件，为了方便识别，我们命名为 <code>refetch-https-cer.sh</code>，并保存到 <code>/etc/cron.weekly/</code> 路径下。如果没有该路径则最新建。</p><p>在 <code>refetch-https-cer.sh</code> 中填入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/usr/bin/service nginx stop</span><br><span class="line">/root/certbot-auto renew</span><br><span class="line">/usr/bin/service nginx start</span><br></pre></td></tr></table></figure><p><code>#!/bin/bash</code> 开头说明该文件是一个 shell 脚本。 下面就是需要执行的命令。这里我们只要三步就能完成 https 证书的更新:</p><ol><li>关闭占用80端口的 nginx 服务（因为我们用 <code>standalone</code> 模式来使用 <code>cerbot-auto</code>)</li><li>用 certbot 来为证书续期</li><li>重启 HTTP 代理服务器，来使新的 https 证书生效。</li></ol><p>需要注意的是，文件里需要写全命令路径，因为 cron 执行的时候，可能没有 PATH 的环境变量。我的 certbot 命令放在 root 文件夹下，因此是 <code>/root/certbot-auto renew</code>，你需要将其替换为你的 certbot 命令路径。</p><p>最后我们需要修改一下改脚本文件的权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 777 /etc/cron.quarterly/refetch-https-cer.sh</span><br></pre></td></tr></table></figure><h4 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h4><p>cron 是以载入配置文件的方式来运行计划任务的。因此，只需要编写好配置文件并将其提交到 cron 服务中，它就会按照配置定期运行相关任务。</p><p>我们新建一个配置文件，命名为 rootcron , 保存到 <code>/var/spool/cron/</code>。该路径是所有用户 cron 文件存放的目录。</p><p>编辑 rootcron 文件，添加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># refetch https certificate per week</span><br><span class="line"># minute hour day month week command</span><br><span class="line">0 3 * * 2 /etc/cron.weekly/refetch-https-cer.sh &gt;&gt; /root/for_crontab/error.log</span><br></pre></td></tr></table></figure><p>这个配置文件的意思就是，在每周二的凌晨 3 点，执行我们先前编写的用来自动续期的脚本，并将错误日志输出到 <code>/root/for_crontab/error.log</code> 文件中。</p><p>你可以自定义log文件的路径，但要保证在编写这个配置文件之前，已经把 log 文件创建好了。这样你可以偶尔上来看看日志文件，确保计划任务正常运行。</p><p>你也可以根据自己证书的过期时间，自定义任务的计划时间。想要知道如何自定义自己的配置文件，请看<a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="noopener">这里</a>。</p><p>最后，我们将该配置文件提交到 cron 服务中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab /var/spool/cron/rootcron</span><br></pre></td></tr></table></figure><p>检查一下是否已经成功将计划任务提交了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure><p>如果出现下面的提示，则说明已经成功提交了。自此，cron 会帮你打理好证书续期的事。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line"><span class="comment"># refetch https certificate per week</span></span><br><span class="line"><span class="comment"># minute hour day month week command</span></span><br><span class="line">0 3 * * 2 /etc/cron.weekly/refetch-https-cer.sh &gt;&gt; /root/for_crontab/error.log</span><br></pre></td></tr></table></figure><p>Have fun ：）</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://letsencrypt.org/getting-started/" target="_blank" rel="noopener">Let’s Encrypt Getting Start</a></li><li><a href="https://certbot.eff.org/#ubuntutrusty-nginx" target="_blank" rel="noopener">Certbot</a></li><li><a href="http://www.jianshu.com/p/eaac0d082ba2" target="_blank" rel="noopener">Let’s Encrypt SSL证书配置</a></li><li><a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="noopener">每天一个linux命令（50）：crontab命令</a></li><li><a href="http://outprog.github.io/blog/2015/10/15/ubuntu-14-dot-04-shi-yong-cron-shi-xian-ji-hua-ren-wu/" target="_blank" rel="noopener">Ubuntu 14.04 使用 Cron 实现计划任务</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没错，这是一篇可以 Step by Step 跟着做的操作指南。&lt;/p&gt;
&lt;p&gt;keyword: &lt;strong&gt;Let’s Encrypt&lt;/strong&gt;, &lt;strong&gt;Ubuntu 14.04&lt;/strong&gt;, &lt;strong&gt;Nginx&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 持续集成系列 - 自动化 Code Review</title>
    <link href="https://shengpan.net/2016/09/14/auto-code-review/"/>
    <id>https://shengpan.net/2016/09/14/auto-code-review/</id>
    <published>2016-09-13T21:16:55.000Z</published>
    <updated>2016-11-24T07:29:03.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/ios-ci-index/">iOS 持续集成 - 开篇</a></li><li><a href="#">iOS 持续集成 - 自动化 Code Review</a></li><li>[iOS 持续集成 - 自动化单元测试]</li><li>[iOS 持续集成 - 自动化打包与分发]</li></ul><p>为了保证代码质量，Code Review 是非常重要的一环。细到<code>*</code>的位置是否正确，大到代码的结构是否符合了软件开发的一些基本原则，都在这项工作的范围内。</p><p>受限于现实情况，大多数团队没有足够的时间进行 Code Review，那么只能把一部分 CR 工作交给计算机去完成了。我们只需要定下合理的流程，用代码告诉计算机需要做什么，剩下的就交给我们可靠的伙伴吧。</p><p>应用了自动化 Code Review 后，如果你的代码写得不好，Xcode 会表示不开心。</p><p><img src="/content/images/2016/11/xcode.png" alt=""></p><p>如果你忽略 Xcode 的心情，那么质量管理平台会默默地记录这一切。</p><p><img src="/content/images/2016/11/sonar.png" alt=""></p><p>这套东西既帮助开发们写出更高质量的的代码，也给经理们对工程质量的评估提供了一个切面的支持，同时只需要花费较少的人力维护，听起来是不是跃跃欲试了呢 ： ）</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>整体的工作流程非常简单，如图：</p><p><img src="/content/images/2016/11/flow-1.png" alt="自动化 Code Review 总体流程"></p><p>关键点在于<strong>本地 Review</strong>和<strong>远端 Review</strong>这两步。前者是提供给开发者一个即时的代码质量反馈，以便开发者修改，从而避免在接下来的远端 Review 中得到一个较低的得分。后者则是为了生成相关报表，为项目管理人员跟踪项目质量提供依据。在很多大公司里，这也是开发者们绩效的参考之一。</p><p>剩下的就是一些胶水步骤了，如何让过程更自动化，就是胶水步骤要做的事。例如利用 WebHook 自动触发远端 Review，利用 Git 的钩子进行增量校验而不是全量校验等。这些我们放在后面聊，先来看看本地校验的流程。</p><h2 id="本地-Review"><a href="#本地-Review" class="headerlink" title="本地 Review"></a>本地 Review</h2><p><img src="/content/images/2016/11/local-flow-1.png" alt="本地自动化 Code Review"></p><p>在本地 Review 环节，开发者只需要像往常一样按下 CMD + B，然后只要静静地等待进度条读完，满屏的⚠️就会精确地指示出某一行的代码违反了哪条规则。此时开发者就可以根据代码规范进行对应修改。</p><p>从按下按键到产生警告主要发生了这么几件事情：</p><ul><li>生成 compile_commands.json 文件</li><li>OCLint 读取相关的 Rules，逐个扫描 compile_commands.json 中的 .m 文件</li><li>OCLint 将生成的报告展示在 Xcode 上</li></ul><p><strong>实现本地 Review 的核心就是 OCLint 和 compile_commands.json文件</strong></p><h3 id="OCLint"><a href="#OCLint" class="headerlink" title="OCLint"></a>OCLint</h3><blockquote><p>工欲善其事，必先利其器</p></blockquote><p><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a> 是一个开源的，基于 Clang 用 C++ 编写而成的，可以用于 C、C++ 和 Objective-C 的静态代码分析器。它可以在扫描的过程中动态加载规则文件（Rules），因此可以实现非常灵活的，高度可自定义的代码分析方案。它几乎可以和大多数系统无缝集成，例如 Cmake、Bear、xcodebuild、xctool、Xcode、xcpretty、Jenkins CI、Travis CI 等。你可以在<a href="http://docs.oclint.org/en/stable/guide/xcode.html" target="_blank" rel="noopener">这里</a>找到如何将其和 Xcode 配合使用。</p><p>最新版本的 OCLint 已经自带了 71 条 Rules，基本上都是先人宝贵的经验，比如<a href="http://docs.oclint.org/en/stable/rules/basic.html#gotostatement" target="_blank" rel="noopener">这条禁用 goto 语句的 Rule</a>，就是来源于 <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger W. Dijkstra</a> 1968 年的一篇<a href="http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF" target="_blank" rel="noopener">手稿</a>。</p><p>这 71 条 Rules 已经可以帮助我们避免一部分因书写习惯和语言误区而导致的问题，但是对于有完整编码规范的公司来说显然是不够的。我们必须要自己开发 Rules。</p><p>幸运的是，OCLint 已经为我们准备好了一切。</p><p>OCLint 提供了 Clang 和 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">AST (Abstract Syntax Tree)</a> 的一层封装，使我们不必对抽象语法树进行解析，只需要专注规则相关的逻辑开发即可。从其提供的接口中我们可以很明显地看出这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到一元操作符</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VisitUnaryOperator</span><span class="params">(UnaryOperator *node)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 遇到二元操作符</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VisitBinaryOperator</span><span class="params">(BinaryOperator *node)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 遇到 Objective-C 的函数声明</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VisitObjCMethodDecl</span><span class="params">(ObjCMethodDecl *node)</span></span></span><br></pre></td></tr></table></figure><p>在开发好相关的规则后，打包成 dylib，就可以在分析的时候<a href="http://docs.oclint.org/en/stable/manual/oclint.html#rule-loading-options" target="_blank" rel="noopener">加载我们自己的 Rule 了</a>。</p><h3 id="compile-commands-json"><a href="#compile-commands-json" class="headerlink" title="compile_commands.json"></a>compile_commands.json</h3><p>compile_commands.json 是 Clang 定义的<a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html" target="_blank" rel="noopener">一个规范</a>，里面存放了一组<strong>工作目录</strong>、<strong>目标文件</strong>、<strong>需要被执行的命令</strong>，帮助相关工具可以独立于编译系统来将源代码文件转换为 AST 并做对应的事。</p><p>看文件内容会更直观一些：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"directory"</span>: <span class="string">"/path/to/project/"</span>, </span><br><span class="line">  <span class="attr">"command"</span>: <span class="string">"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x ..."</span>, </span><br><span class="line">  <span class="attr">"file"</span>: <span class="string">"/path/to/project/XXXViewController.m"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>OCLint 可以根据 compile_commands.json 中的内容，批量检查源代码文件。</p><h3 id="xcpretty"><a href="#xcpretty" class="headerlink" title="xcpretty"></a>xcpretty</h3><p>还有一个点需要关注的是，如何生成 compile_commands.json 文件？</p><p>最便捷的方式是使用 <code>oclint-xcodebuild</code> 来生成。首先，利用xcodebuild 生成 xcodebuild.log 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild | tee xcodebuild.log</span><br></pre></td></tr></table></figure><p>然后利用 <code>oclint-xcodebuild</code> 生成 compile_commands.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oclint-xcodebuild</span><br></pre></td></tr></table></figure><p>截至 Xcode 8.1，这种做法可以正确生成 json 文件。由于 OCLint 团队已经声称不再维护 oclint-xcodebuild , 因此可能在未来的某个 Xcode 版本中这个方法将不再适用。</p><p>另一个推荐的方法是利用 <a href="https://github.com/supermarin/xcpretty" target="_blank" rel="noopener">xcpretty</a> 。</p><p>xcpretty 可以一句话生成 json 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild | xcpretty -r json-compilation-database --output /path/to/compile_commands.json</span><br></pre></td></tr></table></figure><h3 id="使用本地-Review"><a href="#使用本地-Review" class="headerlink" title="使用本地 Review"></a>使用本地 Review</h3><p>了解了这些工具后就很容易明白本地自动化 Code Review 是如何工作的，使用方式也非常容易理解了：</p><ol><li>首先在电脑本地安装好 OCLint 并拿到公司自定义的 Rules 文件</li><li><a href="http://docs.oclint.org/en/stable/guide/xcode.html" target="_blank" rel="noopener">在 Xcode 上配置好工程</a></li><li>build 工程，等待结果显示在 Xcode 上。</li></ol><p>附一个我们团队的配置脚本供参考:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;SRCROOT&#125;</span></span><br><span class="line">xcodebuild clean</span><br><span class="line">xcodebuild | tee xcodebuild.log</span><br><span class="line">oclint-xcodebuild</span><br><span class="line">oclint-json-compilation-database \</span><br><span class="line">-e Vendor \</span><br><span class="line">-e Pods \</span><br><span class="line">-- \</span><br><span class="line">-max-priority-1 100000 \</span><br><span class="line">-max-priority-2 100000 \</span><br><span class="line">-max-priority-3 100000 \</span><br><span class="line">-report-type xcode \</span><br><span class="line">-R /path/to/rules</span><br></pre></td></tr></table></figure><h2 id="远端-Review"><a href="#远端-Review" class="headerlink" title="远端 Review"></a>远端 Review</h2><p><img src="/content/images/2016/11/remote-flow-1.png" alt="远端自动化 Code Review"></p><p>远端 Review 和 本地 Review 大体相似，区别在与引用构建的脚本的对象从 Xcode 变成了 Jenkins CI ，报告的展示者从 Xcode 变成了 SonarQube 。其流程是这样的：</p><p>工程师通过 <code>git push</code> 提交代码<br>→ Web Hook 触发 <strong>Jenkins</strong> 构建<br>→ <strong>OCLint</strong> 扫描代码生成PMD格式报告<br>→ <strong>Sonar-runner</strong> 读取报告并展现到 <strong>SonarQube</strong>。</p><h3 id="CI-环境"><a href="#CI-环境" class="headerlink" title="CI 环境"></a>CI 环境</h3><p>为了实现远端 Review ，服务端必须首先有一套 CI 环境。鉴于 iOS 的特殊性，服务器必须是 macOS 系统。CI 我们直接选择开源的 <a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a>，质量管理平台则选用开源的 <a href="http://www.sonarqube.org" target="_blank" rel="noopener">SonarQube</a>。Jenkins 大名鼎鼎大家都非常熟悉了，SonarQube 则相对少的人了解。</p><p>SonarQube 是一个质量管理平台，在 SonarQube 上，你可以看到一个项目的代码行数、文件数量、代码重复率、违反的代码规范、技术债时间等等指标。SonarQube 对 Java 的支持极度友好，提供了 <strong>SonarScanner</strong> 可以直接对 Java 源代码进行扫描。Objective-C 就没有这么幸运了。虽然 SonarQube 也提供了 Objective-C 的报告展示的支持，但静态分析还是得依靠 OCLint 。</p><h3 id="Sonnar-Runner"><a href="#Sonnar-Runner" class="headerlink" title="Sonnar-Runner"></a>Sonnar-Runner</h3><p>我们在 Jenkins 上运行 OCLint 生成了报告。需要一个中间人将报告解析成 SonarQube 可以理解的格式并传输到 SonarQube 平台。这个中间人就是 Sonnar-Runner。Sonnar-Runner 在我们的系统中也仅仅扮演这个搬运工的角色。你可以从<a href="http://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Jenkins" target="_blank" rel="noopener">这里</a>了解到如何在 Jenkins 上安装和使用 Sonnar-Runner。</p><p>Sonnar-Runner 只能解析 <a href="http://pmd.github.io" target="_blank" rel="noopener">PMD</a> 格式的报告，因此我们在使用 OCLint 分析代码后，需要将报告格式<a href="http://docs.oclint.org/en/stable/howto/selectreporters.html#pmd-reporter-pmd" target="_blank" rel="noopener">输出为 PMD 格式</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oclint -report-type pmd -o ./report.xml</span><br></pre></td></tr></table></figure><h3 id="Rules-in-Sonar"><a href="#Rules-in-Sonar" class="headerlink" title="Rules in Sonar"></a>Rules in Sonar</h3><p>SonarQube 有一套规则，将代码问题按照严重程度分为 5 个等级，不同等级的问题会以不同权重影响到项目质量评分。这套规则和 OCLint 生成的报告中的 Rule name 必须要一一对应，SonarQube 才能正确将报告中的问题归类并评分。</p><p>如果你使用 OCLint 原生的 Rules 来检查代码，只需要在 SonarQube 上安装 <a href="https://github.com/octo-technology/sonar-objective-c" target="_blank" rel="noopener">SonarQube Plugin for Objective C</a> 插件，相关的报告就会被正确识别了。</p><p>如果是使用了自行开发的 Rules ，只需要 Clone 上述插件，并在<strong>profile-oclint.xml</strong> 和 <strong>rules.txt</strong> 中添加相关的 rule name ，然后打包并将这个插件安装到 SonarQube 上即可。</p><p>举个例子：</p><p>当我们用自行开发的 Rule 检查完代码后，生成了report.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">pmd</span> <span class="attr">version</span>=<span class="string">"oclint-0.11"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span> <span class="attr">name</span>=<span class="string">"/path/to/TerribleCode.m"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">violation</span> <span class="attr">rule</span>=<span class="string">"binary operator space (HT_iOS_Coding_style 2.8)"</span> <span class="attr">begincolumn</span>=<span class="string">"9"</span> <span class="attr">endcolumn</span>=<span class="string">"157"</span> <span class="attr">beginline</span>=<span class="string">"73"</span> <span class="attr">endline</span>=<span class="string">"73"</span> <span class="attr">priority</span>=<span class="string">"3"</span> <span class="attr">ruleset</span>=<span class="string">"HT_iOS_rules"</span> &gt;</span></span><br><span class="line">            多元运算符和他们的操作数之间至少需要一个空格</span><br><span class="line">        <span class="tag">&lt;/<span class="name">violation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pmd</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>binary operator space (HT_iOS_Coding_style 2.8)</code> 是我们定义的错误rule name。在 SonarQube 上，也必须对应有这么一条 rule 的 name，才能正确识别这个错误。</p><p>此时我们只需要在上述插件的 <strong>rules.txt</strong> 中添加一段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">binary operator space (HT_iOS_Coding_style 2.8)</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">Summary:多元运算符和他们的操作数之间至少需要一个空格。 </span><br><span class="line"></span><br><span class="line">Severity: 2</span><br><span class="line">Category: Hengtian iOS Coding Standard</span><br></pre></td></tr></table></figure><p>在上述插件的 <strong>profile-oclint.xml</strong> 中添加另外一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;rule&gt;</span><br><span class="line">  &lt;repositoryKey&gt;OCLint&lt;/repositoryKey&gt;</span><br><span class="line">  &lt;key&gt;binary operator space (HT_iOS_Coding_style 2.8)&lt;/key&gt;</span><br><span class="line">&lt;/rule&gt;</span><br></pre></td></tr></table></figure><p>然后将这个插件打包并安装到 SonarQube 上，SonarQube 就可以正确识别我们的问题并分类了。</p><h3 id="使用远端-Review"><a href="#使用远端-Review" class="headerlink" title="使用远端 Review"></a>使用远端 Review</h3><p>在使用前，一定要确保你的 macOS 服务器已经安装好了最新版的 Xocde、OCLint、Jenkins、sonnar-runner，安装好 Jenkins 的相关插件，并将自定义的 Rule 放置在服务器上（如果有的话）。</p><h4 id="检查并生成报告"><a href="#检查并生成报告" class="headerlink" title="检查并生成报告"></a>检查并生成报告</h4><p>在 Jenkins 上新建工程并配置好Git、构建触发器等其他内容。在构建步骤中添加一步 <strong>Execute Shell</strong> ，填入下述脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd YourProjectDir</span><br><span class="line">xcodebuild clean</span><br><span class="line">xcodebuild -workspace MyProject.xcworkspace -scheme HTMarket -sdk iphonesimulator | tee xcodebuild.log | xcpretty</span><br><span class="line">oclint-xcodebuild</span><br><span class="line">oclint-json-compilation-database -e Pods \</span><br><span class="line">-v \</span><br><span class="line">-- \</span><br><span class="line">-max-priority-1 100000 \</span><br><span class="line">-max-priority-2 100000 \</span><br><span class="line">-max-priority-3 100000 \</span><br><span class="line">-report-type pmd \</span><br><span class="line">-R /path/to/diy-rules \</span><br><span class="line">-o /path/to/report.xml</span><br></pre></td></tr></table></figure><p>脚本大致和本地 Review 一致，有三个地方需要注意一下。</p><ol><li><code>xcodebuild</code> 命令添加了 <code>-sdk iphonesimulator</code>参数，以避免 build 需要 Code Sign 的问题。</li><li><code>-report-type pmd</code> 输出格式必须为 pmd 格式</li><li><code>-o /path/to/report.xml</code> 注意输出报告的路径，下一步sonnar-runner 读取时会用到。</li></ol><h4 id="读取到-SonarQube"><a href="#读取到-SonarQube" class="headerlink" title="读取到 SonarQube"></a>读取到 SonarQube</h4><p>在上一步的下方再添加一步 <strong>Invoke Standalone SonarQube Analysis</strong>，选择好你的 sonnar-runner。并在 <em>Analysis Properties</em> 中添加如下配置：（如果没有这一项，你可能需要安装 SonarQube 相关的插件。）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sonar.projectKey=YOUR_PROJECT_NAME</span><br><span class="line">sonar.projectName=YOUR_PROJECT_NAME</span><br><span class="line">sonar.projectVersion=<span class="number">1.0</span></span><br><span class="line">sonar.language=objc</span><br><span class="line">sonar.projectDescription=YOUR_PROJECT_DESCRIPTION</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Path to source directories </span></span><br><span class="line">sonar.sources=<span class="regexp">/path/to</span><span class="regexp">/source/directories</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Xcode project configuration (.xcodeproj or .xcworkspace)</span></span><br><span class="line"><span class="comment"># -&gt; If you have a project: configure only sonar.objectivec.project</span></span><br><span class="line"><span class="comment"># -&gt; If you have a workspace: configure sonar.objectivec.workspace and sonar.objectivec.project</span></span><br><span class="line"><span class="comment"># and use the later to specify which project(s) to include in the analysis (comma separated list)</span></span><br><span class="line">sonar.objectivec.project=YOUR_PROJECT_NAME.xcodeproj </span><br><span class="line">sonar.objectivec.workspace= YOUR_PROJECT_NAME.xcworkspace</span><br><span class="line"></span><br><span class="line"><span class="comment"># Scheme to build your application</span></span><br><span class="line">sonar.objectivec.appScheme=YOUR_PROJECT_NAME</span><br><span class="line"> </span><br><span class="line">sonar.sourceEncoding=UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OCLint report generated by run-sonar.sh is stored in sonar-reports/oclint.xml</span></span><br><span class="line"><span class="comment"># Change it only if you generate the file on your own</span></span><br><span class="line"> sonar.objectivec.oclint.report=YOUR_REPORT_FILE_PATH</span><br></pre></td></tr></table></figure><p>注意看注释并修改 <code>YOUR_PROJECT_NAME</code> 、<code>YOUR_PROJECT_DESCRIPTION</code>、和 <code>YOUR_REPORT_FILE_PATH</code>为你项目的值。</p><p>一切顺利的话，在 Jenkins 上立即构建，你就可以在你的 Sonar 平台上看到代码质量报告了。</p><p>配合好<strong>构建触发器</strong> 和 Git 平台的 WebHook 功能，就可以在开发提交代码或者合并分支等关键点自动触发构建了。</p><h3 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h3><p><strong>为什么生成的 compile_commands.json 为空</strong></p><p>检查 log 是否为空，如果 log 为空则代表 build 失败。排除失败原因后即可正常生成。</p><p><strong>Jenkins 构建遇到了如下问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❌  Code signing is required for product type &apos;Application&apos; in SDK &apos;iOS 10.0&apos;</span><br></pre></td></tr></table></figure></p><p>遇到这样的情况，是因为构建了 Release 版本，且项目在 Xcode8+ 上开启了 Automatic Code Sign。解决方法如下：</p><ol><li>如果只需要检查代码规范，则在 xcodebuild 命令后添加 <code>-sdk iphonesimulator</code> 参数指明以 Debug 方式构建即可。</li><li>如果希望构建 Release 版本，那么关闭自动签名，在 CI 系统上手动配置证书和Proversion Profile。或者保留自动签名，参考<a href="https://testerhome.com/topics/5954" target="_blank" rel="noopener">这个回答</a>用 <code>sed</code> 命令在构建前修改相关配置。</li></ol><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a></li><li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li><li><a href="http://www.sonarqube.org" target="_blank" rel="noopener">SonarQube</a></li><li><a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger W. Dijkstra</a></li><li><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">AST (Abstract Syntax Tree)</a></li><li><a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html" target="_blank" rel="noopener">json compilation database format specification</a></li><li><a href="https://github.com/supermarin/xcpretty" target="_blank" rel="noopener">xcpretty</a> </li><li><a href="http://pmd.github.io" target="_blank" rel="noopener">PMD</a></li><li><a href="https://testerhome.com/topics/5954" target="_blank" rel="noopener">xcode8 和 ios10 升级之后的问题集中讨论帖 – TesterHome</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/ios-ci-index/&quot;&gt;iOS 持续集成 - 开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS 持续集成 - 自动化 Code Review&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[iOS 持续集成 - 自动化单元测试]&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深挖 Swift 中的字符串可比性</title>
    <link href="https://shengpan.net/2016/09/06/string-comparable/"/>
    <id>https://shengpan.net/2016/09/06/string-comparable/</id>
    <published>2016-09-06T01:13:20.000Z</published>
    <updated>2016-09-06T01:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在写 <a href="http://shengpan.net/swift-max/">《从 Swift 中的 max(_:_:) 看设计哲学》</a>的过程中，产生了这样一个想法: <em>既然 <code>max(_:_:)</code> 可以用来对比任何 <code>Comparable</code> ,而 <code>String</code> 是符合 <code>Comparable</code> 的，那么用它来比较两个字符串”谁大谁小”会怎么样呢？</em></p><p>由于实验结果的捉摸不定，于是产生了一探究竟的念头。过程很有趣，结果让人感叹计算机科学之深厚。同时也是典型的 <strong>How I Resolve A Problem</strong>,故记。</p><h3 id="用-max-来对比-String"><a href="#用-max-来对比-String" class="headerlink" title="用 max 来对比 String"></a>用 max 来对比 String</h3><blockquote><p>The Comparable protocol is used for types that have an inherent order, such as numbers and strings.</p></blockquote><p>Swift 标准库已经为 Sting 实现了 Comparable， max 可以用在 String 上。猜猜下面两个字符串谁更大？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let maxString = max(&quot;bc&quot;, &quot;abc&quot;)</span><br></pre></td></tr></table></figure><p>答案是 <strong>maxString == “bc”</strong></p><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>根据结果我们猜测，String 的大小应该不是根据长度来判断的，<strong>有可能是按照首字母的 Unicode 编码大小来判断的</strong>。为了证实这一猜测，我们去翻翻相关资料。</p><p>首先看 String 的头文件。</p><p>我们只看到了实现了 Comparable 的声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension String : Equatable &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension String : Comparable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯。 好歹证实了 String 的确实现了 Comparable 嘛。既然 Swift 是开源的，我们去源代码里找找，继续深挖。</p><p>首先 Google <em>swift standard library source code</em>,</p><p><img src="/content/images/2016/09/google-swift-std-1.png" alt=""></p><p>我们访问 Swift 官网上的 Source Code 一节，其中中有两块资源可能会有我们的答案，一块是 <strong><a href="https://github.com/apple/swift" target="_blank" rel="noopener">Swift 源码</a></strong> ,另一块是 <strong><a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Foundation源码</a></strong>。</p><p><img src="/content/images/2016/09/swift-source-code.png" alt=""></p><p>我们把两部分都 Clone 下来看看。</p><p>首先看可以直接打开工程文件的 Foundation 源码，找到 String.swift 文件， 一共 70 行代码。类声明是这样的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension String : _ObjectTypeBridgeable</span><br></pre></td></tr></table></figure><p>原来这个工程是为了和 Objective - C 的库桥接而生的。看来只能到 Swift 源码中找答案了。</p><h3 id="去-Swift-源码中找答案"><a href="#去-Swift-源码中找答案" class="headerlink" title="去 Swift 源码中找答案"></a>去 Swift 源码中找答案</h3><p>Swift 的 README 中有这么一句话</p><blockquote><p>Another source of documentation is the standard library itself, located in stdlib. Much of the language is actually implemented in the library (including Int)</p></blockquote><p>既然这样，在 <code>stdlib</code> 文件夹里面，肯定也有 <code>String</code> 的实现。</p><p>我们在 <code>stdlib/public/core</code> 下找到 <code>String.Swift</code> 并打开。</p><p><img src="/content/images/2016/09/string.png" alt=""></p><p>如苹果所说，Swift 标准库的文档基本上都在原代码中了，<strong>开头整整 284 行都是文档</strong>! Apple 的文档丰富和详细在这里提现得淋漓尽致。</p><p>从上图也可以看到，我们尝试搜索 <code>Comparable</code> 关键字，没有发现文件中有对 <code>Comparable</code> 的实现。快速翻阅一下 String 的 extension, 也没有发现相关的实现。</p><p>查阅 Apple 的 <a href="https://developer.apple.com/reference/swift/comparable" target="_blank" rel="noopener">API Reference</a> 可以得知 <code>Comparable</code> 也是 Swift 标准库的一份。因此，在上述文件夹中肯定能找到相关定义。同时，我们也知道，Swift 可以为 Protocol 添加默认实现。也许找到 <code>Comparable</code> 定义的地方，就能找到答案。</p><p><img src="/content/images/2016/09/Comparable.png" alt=""></p><p>在 String.swift 的同目录下，我们发现了 Comparable.swift 文件，打开文件，我们发现了熟悉的 <code>Comparable</code> 协议的定义，以及最关键的，默认实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public func &gt; &lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; Bool &#123;</span><br><span class="line">  return rhs &lt; lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func &lt;= &lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; Bool &#123;</span><br><span class="line">  return !(rhs &lt; lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func &gt;= &lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; Bool &#123;</span><br><span class="line">  return !(lhs &lt; rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里只有针对 <code>&gt;</code>，<code>&lt;=</code>,<code>&gt;=</code> 的实现，并且这些实现都是依赖 <code>&lt;</code> 的实现。这一点印证了接口文档中 Apple 关于<a href="http://en.wikipedia.org/wiki/Total_order#Strict_total_order" target="_blank" rel="noopener">严格全序</a>和如何在子类实现 <code>Comparable</code> 的说法。</p><blockquote><p>A type conforming to <code>Comparable</code> need only supply the <code>&lt;</code> and<code>==</code> operators;<br>default implementations of <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and<code>!=</code> are supplied by the standard library</p></blockquote><h3 id="走弯路"><a href="#走弯路" class="headerlink" title="走弯路"></a>走弯路</h3><p>那么 <code>&lt;</code> 的实现又在哪儿？</p><p>纵览 <code>Comparable</code> 的源码中的文档，基本上是设计思想和使用说明，只字未提 <code>&lt;</code> 的实现。</p><p>我们继续翻阅标准库中的文件，在 <code>optinal.swift</code> 等文件中，都有对 <code>==</code> 的重载，但 Command + 左键点击无法跳转到原始实现。一番寻找后，在 <code>Policy.swift</code> 中找到 <code>&lt;</code> 的定义</p><p><img src="/content/images/2016/09/-.png" alt=""></p><p>似乎 <code>ComparisonPrecedence</code> 是关键所在。由于是打开单个文件，无法点击跳转到 <code>ComparisonPrecedence</code> 的定义。联想到 Swift 的 README 中说过，可以通过 <code>utils/build-script -x</code> 来将源码构建成 Xcode 工程，那样看起来会方便许多。但考虑到需要安装 <code>CMake</code>、<code>Ninja</code> 等一系列环境，所花费的时间对于解决这个问题来说不划算。先去 Google 搜索一下答案。</p><p>通过 Google 找到了 NSHipster 的 <a href="http://nshipster.com/swift-operators/" target="_blank" rel="noopener">Swift Operators</a>,也仔细阅读了 <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" target="_blank" rel="noopener">The Swift Programming Language (Swift 2.2)</a>，均没有收获。</p><h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><p>就在一筹莫展的时候，想到标准库的源码还没翻完，于是继续一个个地浏览标准库的文件。其中一个文件名让人眼前一亮:</p><p><img src="/content/images/2016/09/StringComparable.png" alt=""></p><p>我们找到了 String 关于 <code>Comparable</code> 的实现！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension String : Comparable &#123;</span><br><span class="line">  public static func &lt; (lhs: String, rhs: String) -&gt; Bool &#123;</span><br><span class="line">    return lhs._compareString(rhs) &lt; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 的 <code>&lt;</code> 实现依赖于 <code>Int</code> 的 <code>&lt;</code> 实现。通过 <code>_compareString</code> 生成的整数和 0 比较。至此，我们忽然明白，<strong>Swift 标准库中，<code>Comparable</code> 本身并没有提供默认的 <code>&lt;</code> 实现，而是由 <code>String</code> 和 <code>Int</code> 各自提供了 <code>&lt;</code> 的实现。</strong></p><p>整数的比较非常好理解了，我们来看看关键的 <code>_compareString</code> 方法是怎么实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func _compareString(_ rhs: String) -&gt; Int &#123;</span><br><span class="line">#if _runtime(_ObjC)</span><br><span class="line">    // We only want to perform this optimization on objc runtimes. Elsewhere,</span><br><span class="line">    // we will make it follow the unicode collation algorithm even for ASCII.</span><br><span class="line">    if _core.isASCII &amp;&amp; rhs._core.isASCII &#123;</span><br><span class="line">      return _compareASCII(rhs)</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return _compareDeterministicUnicodeCollation(rhs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法对 Objective-C 下的 ASCII 编码的字符串对比做了优化，剩余情况都采用 <code>_compareDeterministicUnicodeCollation</code> 来做比较。</p><p>顺藤摸瓜继续看 <code>_compareDeterministicUnicodeCollation</code> 的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  func _compareDeterministicUnicodeCollation(_ rhs: String) -&gt; Int &#123;</span><br><span class="line">    // Note: this operation should be consistent with equality comparison of</span><br><span class="line">    // Character.</span><br><span class="line">#if _runtime(_ObjC)</span><br><span class="line">    if self._core.hasContiguousStorage &amp;&amp; rhs._core.hasContiguousStorage &#123;</span><br><span class="line">      let lhsStr = _NSContiguousString(self._core)</span><br><span class="line">      let rhsStr = _NSContiguousString(rhs._core)</span><br><span class="line">      let res = lhsStr._unsafeWithNotEscapedSelfPointerPair(rhsStr) &#123;</span><br><span class="line">        return Int(</span><br><span class="line">            _stdlib_compareNSStringDeterministicUnicodeCollationPointer($0, $1))</span><br><span class="line">      &#125;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">    return Int(_stdlib_compareNSStringDeterministicUnicodeCollation(</span><br><span class="line">      _bridgeToObjectiveCImpl(), rhs._bridgeToObjectiveCImpl()))</span><br><span class="line">#else</span><br><span class="line">    switch (_core.isASCII, rhs._core.isASCII) &#123;</span><br><span class="line">    case (true, false):</span><br><span class="line">      return Int(_swift_stdlib_unicode_compare_utf8_utf16(</span><br><span class="line">          _core.startASCII, Int32(_core.count),</span><br><span class="line">          rhs._core.startUTF16, Int32(rhs._core.count)))</span><br><span class="line">    case (false, true):</span><br><span class="line">      // Just invert it and recurse for this case.</span><br><span class="line">      return -rhs._compareDeterministicUnicodeCollation(self)</span><br><span class="line">    case (false, false):</span><br><span class="line">      return Int(_swift_stdlib_unicode_compare_utf16_utf16(</span><br><span class="line">        _core.startUTF16, Int32(_core.count),</span><br><span class="line">        rhs._core.startUTF16, Int32(rhs._core.count)))</span><br><span class="line">    case (true, true):</span><br><span class="line">      return Int(_swift_stdlib_unicode_compare_utf8_utf8(</span><br><span class="line">        _core.startASCII, Int32(_core.count),</span><br><span class="line">        rhs._core.startASCII, Int32(rhs._core.count)))</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们略过优化，直接看关键的两个方法： <code>_stdlib_compareNSStringDeterministicUnicodeCollationPointer</code> 和 <code>_swift_stdlib_unicode_compare_utf8_utf8</code></p><p>看方法名，大概知道如下信息:</p><p>在 Objective - C 下，比较两个 String 的 Unicode 集合指针。</p><p>在 Swift 下，通过字符串的起始位置指针和字符串的长度综合比较。那么究竟是怎么综合比较的呢？（原来和长度还是有关系的，看来前面的猜测不全对）。</p><p>通过方法名中<code>_swift_stdlib</code>的前缀，我们猜测这个方法可能也是 Swift 标准库中的一员。经过一番查找，我们在 <code>/stdlib/public/stubs</code> 路径下的 <strong>UnicodeNormalization.cpp</strong> 文件的 173 行找到了这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/// Compares the strings via the Unicode Collation Algorithm on the root locale.</span><br><span class="line">/// Results are the usual string comparison results:</span><br><span class="line">///  &lt;0 the left string is less than the right string.</span><br><span class="line">/// ==0 the strings are equal according to their collation.</span><br><span class="line">///  &gt;0 the left string is greater than the right string.</span><br><span class="line">int32_t</span><br><span class="line">swift::_swift_stdlib_unicode_compare_utf8_utf8(const unsigned char *LeftString,</span><br><span class="line">                                               int32_t LeftLength,</span><br><span class="line">                                               const unsigned char *RightString,</span><br><span class="line">                                               int32_t RightLength) &#123;</span><br><span class="line">  UCharIterator LeftIterator;</span><br><span class="line">  UCharIterator RightIterator;</span><br><span class="line">  UErrorCode ErrorCode = U_ZERO_ERROR;</span><br><span class="line"></span><br><span class="line">  uiter_setUTF8(&amp;LeftIterator, reinterpret_cast&lt;const char *&gt;(LeftString), LeftLength);</span><br><span class="line">  uiter_setUTF8(&amp;RightIterator, reinterpret_cast&lt;const char *&gt;(RightString), RightLength);</span><br><span class="line"></span><br><span class="line">  uint32_t Diff = ucol_strcollIter(GetRootCollator(),</span><br><span class="line">    &amp;LeftIterator, &amp;RightIterator, &amp;ErrorCode);</span><br><span class="line">  if (U_FAILURE(ErrorCode)) &#123;</span><br><span class="line">    swift::crash(&quot;ucol_strcollIter: Unexpected error doing utf8&lt;-&gt;utf8 string comparison.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return Diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里的关键算法是 <code>ucol_strcollIter</code>。但到这里，其实我们已经不再需要在源代码中继续翻找了，注释已经给出了答案 – <strong>通过 Unicode 对照算法来比较两个字符串，结果小于 0 ，则代表左边的字符串小于右边，反之亦然。如果结果等于 0 则代表两个字符串在该对照算法下是相等的。</strong></p><p>为了补充一下知识，我们再来看看 Unicode Collation Algorithm 的<a href="http://unicode.org/reports/tr10/#Main_Algorithm" target="_blank" rel="noopener">主算法</a>。</p><p>主算法分四步</p><ol><li>标准化字符串</li><li>为每个标准化后的字符串生成对照元素数组</li><li>根据对照元素数组，生成二进制的排序 Key</li><li>通过对比二进制数据的大小，其结果就是原字符串的”大小”。</li></ol><p>算法这块不过多展开, ucol_strcollIter 函数的实现看<a href="http://icu-project.org/apiref/icu4c/ucol_8h.html" target="_blank" rel="noopener">这里</a>，有兴趣的朋友可以深入研究。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 下字符串的比较是通过计算机科学领域标准的 Unicode 对照算法来的。在不了解算法的情况下，很难从字面上看出两个字符串谁大谁小。因此在日常开发下，应当尽量避免比较两个字符串”谁大谁小”。</p><p>Swift 以<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" target="_blank" rel="noopener"><strong>是否具有统一码等价性</strong></a> 作为判断字符相等的标准。因此在比较两个字符串相等的时候，也需要多考虑细，来避免产生不必要的 BUG。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://developer.apple.com/reference/swift/comparable" target="_blank" rel="noopener">Comparable</a></li><li><a href="https://github.com/apple/swift" target="_blank" rel="noopener">Swift</a><br><a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Foundation</a></li><li><a href="http://nshipster.com/swift-operators/" target="_blank" rel="noopener">Swift Operators</a> </li><li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" target="_blank" rel="noopener">The Swift Programming Language (Swift 2.2)</a></li><li><a href="http://unicode.org/reports/tr10/" target="_blank" rel="noopener">Unicode Collation Algorithm</a></li><li><a href="http://icu-project.org/apiref/icu4c/ucol_8h.html" target="_blank" rel="noopener">ICU 57.1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;在写 &lt;a href=&quot;http://shengpan.net/swift-max/&quot;&gt;《从 Swift 中的 max(_:_:) 看设计哲学》&lt;/a&gt;的过程中，产生了这样一个想法: &lt;em&gt;既然 &lt;code&gt;max(_:_:)&lt;/code&gt; 可以用来对比任何 &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从 Swift 中的 max(_:_:) 看设计哲学</title>
    <link href="https://shengpan.net/2016/09/05/swift-max/"/>
    <id>https://shengpan.net/2016/09/05/swift-max/</id>
    <published>2016-09-05T01:18:09.000Z</published>
    <updated>2016-09-06T01:10:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于 Swift 不再支持宏了，于是 MAX,MIN 等一些列常用宏都被重写为 Swift 函数。我们来看看函数的定义:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@warn_unused_result</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">max</span>&lt;T : Comparable&gt;<span class="params">(x: T, <span class="number">_</span> y: T)</span></span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure><h3 id="warn-unused-result"><a href="#warn-unused-result" class="headerlink" title="warn_unused_result"></a><code>warn_unused_result</code></h3><p>先说说 @warn_unused_result 注解。 顾名思义，被该注解标记的方法所产生的返回值，如果未被使用，编译器会不开心哦（编译的时候会产生一条警告⚠️）。</p><p>这里讲一下方法的设计哲学。一般来说一个理想的带有返回值的方法，除了返回返回值以外，是不会产生任何其他副作用的。比如说不会改变入参的值(这也是 <code>inout</code>存在的原因)<br>，不会对系统的其他状态有影响（比如说不会改变类的实例变量的值）。这样的好处是减少方法产生的不确定性，同时方法使用的目的变得非常明确。</p><p>拿 <code>max</code> 来举例。<code>max</code> 方法被设计用来判断并返回两个参数中更大的那个。容易理解，当返回值没有被使用的时候，这次方法的调用也是没有意义的，因此 @warn_unused_result 的标注是非常合理的。</p><p>所以当你在开发 SDK 或是框架，甚至是和同事合作开发业务，同事会用到你的 API 的时候，你可以在需要的地方，用此注解来标记你的方法，以提示使用者注意使用方法产生的返回值。</p><h3 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h3><p>从方法的定义中，我们可以看到，传入的参数只要符合 <code>Comparable</code> 协议，就可以正确得到返回结果。</p><p>这意味着我们不仅可以用它来比较数字大小:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxInteger = <span class="built_in">max</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>还可以用来比较 <code>String</code> 的大小</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxString = <span class="built_in">max</span>(<span class="string">"bc"</span>, <span class="string">"abc"</span>)</span><br></pre></td></tr></table></figure><p>甚至是自定义的对象，只要它实现了 <code>Comparable</code> 协议。从这一点上，我们可以窥见 Swift “面向协议编程” 的一斑。面向协议编程让 <code>max(_:_:)</code> 从具体的类中解放出来，不关心入参是什么类，有什么结构，只关心 <strong>所传进来的参数能否被比较</strong>,而具体的比较则让入参自己去做，从而让 <code>max(_:_:)</code> 具有普适性，达到程序设计上的低耦合。</p><p>这么说可能有点抽象，我们来举个具体的例子。</p><p>假设我们有这样的餐馆定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Int</span> <span class="comment">// 占地面积</span></span><br><span class="line">    <span class="keyword">var</span> michelinRate: <span class="type">Int</span> <span class="comment">// 米其林等级</span></span><br><span class="line">    <span class="keyword">var</span> averageCoast: <span class="type">Int</span> <span class="comment">// 人均消费</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="comment">// 餐厅名称</span></span><br><span class="line">    <span class="keyword">var</span> logo: <span class="type">UIImage</span> <span class="comment">// 餐厅LOGO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何比较两家餐馆谁大谁小？</strong></p><p>按照餐馆面积比，平海路上的日料店表示不服；按照人均消费比，新白鹿表示不服；按照米其林等级比，一众特色小吃店表示不服；按照餐厅名称长度比，产品经理表示不服。</p><p>总地来说，”谁更大”其实是一种抽象的概念， <code>max</code> 方法不能也不该知道入参是如何比较的。只有入参自己知道自己该如何比较。因此抽象出 <code>Comparable</code> 协议是非常自然的。</p><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>我们再来看看 <code>Comparable</code> 的定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Comparable</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// over instances of `Self`.</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> &lt;(lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    @<span class="title">warn_unused_result</span></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">func</span> &lt;=(lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function">    @<span class="title">warn_unused_result</span></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">func</span> &gt;=<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="meta">@warn_unused_result</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> &gt;<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Comparable</code> 抽象了数学上<a href="http://en.wikipedia.org/wiki/Total_order#Strict_total_order" target="_blank" rel="noopener">严格全序</a>的概念。虽然定义了五个方法(别忘了 Equatable 中还有一个 ==),但只需要实现 <code>==</code> 和 <code>&lt;</code> ，其他方法只需要使用 Swift 标准库提供的默认实现，就可以根据严格全序定义推导出实现。</p><p>数学真是计算机科学的基石啊！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于 Swift 不再支持宏了，于是 MAX,MIN 等一些列常用宏都被重写为 Swift 函数。我们来看看函数的定义:&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 持续集成系列 - 开篇</title>
    <link href="https://shengpan.net/2016/09/04/ios-ci-index/"/>
    <id>https://shengpan.net/2016/09/04/ios-ci-index/</id>
    <published>2016-09-04T05:48:18.000Z</published>
    <updated>2016-11-24T03:40:37.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#">iOS 持续集成 - 开篇</a></li><li><a href="/auto-code-review/">iOS 持续集成 - 自动化 Code Review</a></li><li>[iOS 持续集成 - 自动化单元测试]</li><li>[iOS 持续集成 - 自动化打包与分发]</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发在经过这几年的野蛮生长之后，慢慢地趋于稳定。无论开发语言是 Objective-C 还是 Swift,工程类型是 Hybird 还是原生，开发思想是 OOP 还是函数式，随着项目逐渐变大都在面临相同的问题: 测试、发布等重复性工作占了很大一部分时间，回归成本越来越高。持续集成不可避免地被提上了日程。</p><p>本文主要阐述 iOS 下的持续集成，以目标、内容、流程、工具入手，希望可以为大家描绘一幅 iOS 持续集成的蓝图。这可能不是一篇可以让你 Step by Step 跟着做的文章，但愿可以在你脑海中建立相关概念，以便在实操时走对方向。</p><p>我们会在后面几篇内容中，详细阐述 <strong>是什么</strong> 和 <strong>如何做</strong> 。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>对于我们来说，减少重复工作、提升团队效率。<br>对于公司来说，省钱！</p><p>狭义上持续集成指早集成早测试尽早早发现问题早修复，并辅以一些自动化的手段，其目标是减少修复的成本。通过其目的，我们可以发现，其实<strong>通过自动化减少重复工作</strong>和<strong>通过早发现问题降低成本</strong>是持续集成的核心理念。因此，我把自动化 Code Review 也放到这里讲。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>iOS 下的持续集成内容包括自<strong>动化 Code Reivew、自动化单元测试、自动化打包和自动化分发</strong>。自动化 Code Review 保证团队遵守代码规范，在编码阶段减少 BUG 的产生。在人员流动较大的公司里，用同一套代码规范，也可以保证项目交接更流畅。自动化单元测试在集成阶段检测出 BUG ,以减少回归成本。自动化打包和自动化分发则是减少重复劳动，毕竟，工程师的时间就是金钱啊。</p><h4 id="自动化-Code-Review"><a href="#自动化-Code-Review" class="headerlink" title="自动化 Code Review"></a>自动化 Code Review</h4><p>顾名思义，自动化 Code Review 既采用自动化的手段，对团队成员得代码进行 Review，以保证代码质量。从现实角度来说，自动化的 Code Review 更多地是对代码进行静态分析，通过扫描代码并对比制定的规则，产出所需要的结果。这个所需要的结果，可以是工程总体的量化的质量报告，也可以是显示在 Xcode 中的一条警告⚠️。这取决于用户是什么角色。</p><p>在实际实践中，一般会有两种角色会关注这份结果 – <strong>工程师和管理层</strong>。工程师需要在开发的过程中及时了解代码错误，以便及时纠正。管理层需要了解工程的总体代码质量，以掌握项目的相关风险。同时，也可以作为工程师绩效的依据之一。</p><p>要完成这一块内容，我们需要这些工具:</p><ul><li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li><li><a href="http://www.sonarqube.org" target="_blank" rel="noopener">SonarQube</a></li><li><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a> OR <a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">SwiftLint</a></li></ul><p>通过这三者协作，我们可以实现以下流程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工程师通过 `Git Commit` 提交代码 → Web Hook 触发 `Jenkins` 构建 → `OCLint` 扫描代码生成PMD格式报告 → `Sonar-runner` 读取报告并展现到 `SonarQube`。</span><br></pre></td></tr></table></figure><p>关于 Code Review 需要指出的是，自动化工具是有局限性的。其无法分析出较为”智能”的规则。比如说下面这条</p><blockquote><p>4.7 方法名以小写字母动词作为开头</p></blockquote><p>还有下面这种代码，尽管含有多个容易造成闪退的 BUG,也是可以顺利逃过分析器的眼睛的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> result?.bindPhone == <span class="string">"true"</span> &#123;</span><br><span class="line"><span class="keyword">let</span> range = (result?.loginId?.startIndex.advancedBy(<span class="number">3</span>))!...(result?.loginId?.endIndex.advancedBy(-<span class="number">5</span>))!</span><br><span class="line"><span class="keyword">let</span> phoneNumber: <span class="type">String</span>? = result?.loginId?.stringByReplacingCharactersInRange(range, withString: <span class="string">"****"</span>)</span><br><span class="line"><span class="keyword">self</span>.phoneNumLabel.text = phoneNumber!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，想要达到 “保证代码质量” 的目的，还需要人工 Review 和自动化 Review 相结合。</p><h4 id="自动化单元测试"><a href="#自动化单元测试" class="headerlink" title="自动化单元测试"></a>自动化单元测试</h4><p>自动化地执行单元测试，在测试失败的情况下中断集成，并通知相关人员，就是这一块工作的内容。</p><p>为此，我们需要如下的工具:</p><ul><li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li><li><a href="https://github.com/facebook/xctool" target="_blank" rel="noopener">xctool</a></li></ul><p>我们可以实现以下的流程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Git Merge`  → Web Hook 触发 `Jenkins` 构建 → xctool 执行单元测试 → 如果失败则发邮件给相关人员。</span><br></pre></td></tr></table></figure><p>当然，如果你公司的项目托管在 GitHub 上，业界有两个非常优秀的 Jenkins 替代产品 <a href="https://travis-ci.org" target="_blank" rel="noopener">travis-ci</a> 和 <a href="https://circleci.com" target="_blank" rel="noopener">circle-ci</a>。他们对 GitHub 的支持完美，且对开源项目是免费的。私有项目则需要付费试用。</p><p>在单元测试这一块，最高的成本还是写单元测试的时间成本。脑洞大开地说，如果能实现一款工具，可以自动地为业务代码生成测试代码，那才是生产力的大大提升。</p><h4 id="自动化打包与分发"><a href="#自动化打包与分发" class="headerlink" title="自动化打包与分发"></a>自动化打包与分发</h4><p>一次完整的打包，需要经历配置证书、切换环境、调整参数(构建版本号等)、Archive、导出。<br>根据工程的复杂程度，以上过程快则五分钟，慢则半小时。当需要频繁发版的情况下，浪费了工程师非常多的时间。</p><p>我们其实可以利用一些工具来实现这样的一个流程:</p><p>Git Merge 到 Master（通常这意味着一个 Release）→ 触发 Jenkins 构建生成 ipa → <strong>自动化分发</strong>。</p><p>自动分发包含以下工作：</p><ul><li>自动上传 App Store</li><li>自动使用 TestFlight 分发</li><li>自动上传到 蒲公英/Fir 等平台</li><li>自动上传到企业 App Store</li></ul><p>我们可以分别配置相关的脚本，来实现测试的分发，和发布等。</p><p>要实现这样的流程，我们需要这些工具:</p><ul><li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li><li><a href="https://fastlane.tools" target="_blank" rel="noopener">Fastlane</a></li></ul><p>Fastlane 是由一个个小组件组成的工具，功能包括上传截图到 iTunes Connect,创建 provisioning file, 管理 TestFlight 的测试员，分发等。这个工具几乎可以用命令行来实现打包上传分发相关的所有功能，并且越来越有成为默认的业界持续集成标准工具的样子。就像 CocoaPods 在依赖管理方面一样。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>持续集成，可以看做是通过版本控制系统、CI平台(如Jenkins)和相关工具链来完成一套工作流，以减少团队重复性工作，并保证软件可以不停地迭代而不出太大的差错。iOS 下的持续集成大体就是上述几块内容，我们在实现的过程中遇到了不少坑，后面的文章分块详细讲。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS 持续集成 - 开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/auto-code-review/&quot;&gt;iOS 持续集成 - 自动化 Code Review&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[iOS 持续集成 - 自动化单元测试]&lt;/l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信 URL Schemes</title>
    <link href="https://shengpan.net/2016/07/12/wechat-url/"/>
    <id>https://shengpan.net/2016/07/12/wechat-url/</id>
    <published>2016-07-11T18:29:05.000Z</published>
    <updated>2016-09-17T22:21:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DEPRECATED"><a href="#DEPRECATED" class="headerlink" title="DEPRECATED"></a>DEPRECATED</h3><p>2016年09月18日更新：</p><p><strong>在 微信 6.3.25 版本中，所有外部唤起 URL 的方式均无法打开对应页面。</strong><br>未来这些 url 都只能在微信内部的浏览器使用了。</p><hr><p>年初的动态化分享热潮里，基本上都提到了 URL 跳转，天猫称为<a href="http://pingguohe.net/2015/11/24/Navigator-and-Rewrite.html" target="_blank" rel="noopener">统跳协议</a>，蘑菇街称为 <a href="http://limboy.me/tech/2016/03/10/mgj-components.html" target="_blank" rel="noopener">URL 路由</a>。其实很多大厂都默默地做了一套 URL 跳转机制，比如说 – 微信。</p><p>本文整理了部分微信 URL Schemes，经过本人测试，所有url在微信 6.3.22 版本下都可正常工作。大家可以在 Safari 中打开链接进行尝试。(部分链接仅允许在微信内部浏览器中打开，已用<code>!</code>标注。）</p><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><ul><li>微信 <a href="weixin://" target="_blank" rel="noopener">weixin://</a></li><li><code>!</code>发起群聊 <a href="weixin://dl/groupchat" target="_blank" rel="noopener">weixin://dl/groupchat</a></li></ul><h3 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h3><ul><li><p><code>!</code>添加朋友 <a href="weixin://dl/add" target="_blank" rel="noopener">weixin://dl/add</a></p><ul><li>上报日志 <a href="weixin://dl/log" target="_blank" rel="noopener">weixin://dl/log</a></li><li>故障修复 搜索 <code>:recover</code></li></ul></li><li><p>新的朋友 <a href="weixin://dl/recommendation" target="_blank" rel="noopener">weixin://dl/recommendation</a></p></li><li>群聊 <a href="weixin://dl/groups" target="_blank" rel="noopener">weixin://dl/groups</a></li><li>标签 <a href="weixin://dl/tags" target="_blank" rel="noopener">weixin://dl/tags</a></li><li>公众号 <a href="weixin://dl/officialaccounts" target="_blank" rel="noopener">weixin://dl/officialaccounts</a></li></ul><h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><ul><li>朋友圈 <a href="weixin://dl/moments" target="_blank" rel="noopener">weixin://dl/moments</a></li><li>扫一扫 <a href="weixin://dl/scan" target="_blank" rel="noopener">weixin://dl/scan</a></li><li>购物（京东） <a href="weixin://dl/shopping" target="_blank" rel="noopener">weixin://dl/shopping</a></li><li>游戏 <a href="weixin://dl/games" target="_blank" rel="noopener">weixin://dl/games</a></li></ul><h3 id="我"><a href="#我" class="headerlink" title="我"></a>我</h3><ul><li>个人信息 <a href="weixin://dl/profile" target="_blank" rel="noopener">weixin://dl/profile</a><ul><li>名字 <a href="weixin://dl/setname" target="_blank" rel="noopener">weixin://dl/setname</a></li><li>我的二维码 <a href="weixin://dl/myQRcode" target="_blank" rel="noopener">weixin://dl/myQRcode</a></li><li>我的地址 <a href="weixin://dl/myaddress" target="_blank" rel="noopener">weixin://dl/myaddress</a></li></ul></li><li>相册 <a href="weixin://dl/posts" target="_blank" rel="noopener">weixin://dl/posts</a></li><li>收藏 <a href="weixin://dl/favorites" target="_blank" rel="noopener">weixin://dl/favorites</a></li><li>优惠券 <a href="weixin://dl/card" target="_blank" rel="noopener">weixin://dl/card</a></li><li>表情 <a href="weixin://dl/stickers" target="_blank" rel="noopener">weixin://dl/stickers</a></li><li><p>设置 <a href="weixin://dl/settings" target="_blank" rel="noopener">weixin://dl/settings</a></p><ul><li>QQ 号 <a href="weixin://dl/bindqq" target="_blank" rel="noopener">weixin://dl/bindqq</a></li><li>手机号 <a href="weixin://dl/bindmobile" target="_blank" rel="noopener">weixin://dl/bindmobile</a></li><li>邮箱地址 <a href="weixin://dl/bindemail" target="_blank" rel="noopener">weixin://dl/bindemail</a></li><li>帐号保护 <a href="weixin://dl/protection" target="_blank" rel="noopener">weixin://dl/protection</a></li><li><p>新消息通知 <a href="weixin://dl/notifications" target="_blank" rel="noopener">weixin://dl/notifications</a></p></li><li><p>通讯录黑名单 <a href="weixin://dl/blacklist" target="_blank" rel="noopener">weixin://dl/blacklist</a></p><ul><li>不让他（她）看我的朋友圈 <a href="weixin://dl/hidemoments" target="_blank" rel="noopener">weixin://dl/hidemoments</a></li><li>不看他（她）的朋友圈 <a href="weixin://dl/blockmoments" target="_blank" rel="noopener">weixin://dl/blockmoments</a></li></ul></li><li><p>通用 <a href="weixin://dl/general" target="_blank" rel="noopener">weixin://dl/general</a></p><ul><li>多语言 <a href="weixin://dl/languages" target="_blank" rel="noopener">weixin://dl/languages</a></li><li>字体大小 <a href="weixin://dl/textsize" target="_blank" rel="noopener">weixin://dl/textsize</a></li><li>我的表情 <a href="weixin://dl/stickersetting" target="_blank" rel="noopener">weixin://dl/stickersetting</a></li><li>朋友圈小视频 <a href="weixin://dl/sight" target="_blank" rel="noopener">weixin://dl/sight</a></li><li><p>功能 <a href="weixin://dl/features" target="_blank" rel="noopener">weixin://dl/features</a></p><ul><li>通讯录同步助手 <a href="weixin://dl/securityassistant" target="_blank" rel="noopener">weixin://dl/securityassistant</a></li><li>群发助手 <a href="weixin://dl/broadcastmessage" target="_blank" rel="noopener">weixin://dl/broadcastmessage</a></li></ul></li><li>聊天记录迁移 <a href="weixin://dl/chathistory" target="_blank" rel="noopener">weixin://dl/chathistory</a></li><li>清理微信存储空间 <a href="weixin://dl/clear" target="_blank" rel="noopener">weixin://dl/clear</a></li></ul></li><li>帮助与反馈<ul><li>意见反馈 <a href="weixin://dl/help" target="_blank" rel="noopener">weixin://dl/help</a> 或 <a href="weixin://dl/feedback" target="_blank" rel="noopener">weixin://dl/feedback</a></li><li>关于微信 <a href="weixin://dl/about" target="_blank" rel="noopener">weixin://dl/about</a></li></ul></li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>隐藏入口</strong> 第三方公众号临时会话接口 <a href="weixin://dl/business" target="_blank" rel="noopener">weixin://dl/business</a><ul><li>参数 <code>ticket</code> <a href="weixin://dl/business/?ticket=" target="_blank" rel="noopener">weixin://dl/business/?ticket=</a></li><li>参阅：<a href="http://xyk.cmbchina.com/wx/20150528" target="_blank" rel="noopener">http://xyk.cmbchina.com/wx/20150528</a> 使用了 <a href="http://xyk.cmbchina.com/getWeiXinURL.do" target="_blank" rel="noopener">http://xyk.cmbchina.com/getWeiXinURL.do</a> 生成 ticket 参数</li></ul></li><li><strong>隐藏入口</strong> <code>参数不明</code> 第三方 Webview 接口 <a href="weixin://dl/businessWebview/link/" target="_blank" rel="noopener">weixin://dl/businessWebview/link/</a></li><li><strong>隐藏入口</strong> <code>参数不明</code> 第三方游戏库接口 <a href="weixin://dl/businessGame/library/" target="_blank" rel="noopener">weixin://dl/businessGame/library/</a></li><li><strong>隐藏入口</strong> <code>参数不明</code> 第三方游戏详情接口 <a href="weixin://dl/businessGame/detail/" target="_blank" rel="noopener">weixin://dl/businessGame/detail/</a></li><li><strong>隐藏入口</strong> <code>参数不明</code> 第三方支付接口 <a href="weixin://dl/businessPay/" target="_blank" rel="noopener">weixin://dl/businessPay/</a></li><li><strong>隐藏入口</strong> <code>参数不明</code> 第三方临时会话接口 <a href="weixin://dl/business/tempsession/" target="_blank" rel="noopener">weixin://dl/business/tempsession/</a> 或 <a href="weixin://dl/businessTempSession/" target="_blank" rel="noopener">weixin://dl/businessTempSession/</a></li></ul><h3 id="未知"><a href="#未知" class="headerlink" title="未知"></a>未知</h3><ul><li><a href="weixin://dl/chat" target="_blank" rel="noopener">weixin://dl/chat</a></li><li><a href="weixin://dl/designeremoji" target="_blank" rel="noopener">weixin://dl/designeremoji</a></li><li><a href="weixin://dl/login/common_view" target="_blank" rel="noopener">weixin://dl/login/common_view</a></li><li><a href="weixin://dl/login/phone_view" target="_blank" rel="noopener">weixin://dl/login/phone_view</a></li><li><a href="weixin://dl/personalemoticon" target="_blank" rel="noopener">weixin://dl/personalemoticon</a></li><li><a href="weixin://private/" target="_blank" rel="noopener">weixin://private/</a><ul><li><a href="weixin://private/setresult/" target="_blank" rel="noopener">weixin://private/setresult/</a></li></ul></li><li><a href="weixin://dl/update_newest_version" target="_blank" rel="noopener">weixin://dl/update_newest_version</a></li><li><a href="weixin://dl/wechatout" target="_blank" rel="noopener">weixin://dl/wechatout</a><ul><li><a href="weixin://dl/wechatoutcoupon" target="_blank" rel="noopener">weixin://dl/wechatoutcoupon</a></li></ul></li></ul><p>参考资料:</p><ul><li><a href="https://github.com/reverseengineeringer/com.tencent.mm/blob/master/src/com/tencent/mm/pluginsdk/d.java" target="_blank" rel="noopener">Wechat 安卓版部分源码</a></li><li><a href="http://spacekid.me/weixin-url-schemes" target="_blank" rel="noopener">太空小孩</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DEPRECATED&quot;&gt;&lt;a href=&quot;#DEPRECATED&quot; class=&quot;headerlink&quot; title=&quot;DEPRECATED&quot;&gt;&lt;/a&gt;DEPRECATED&lt;/h3&gt;&lt;p&gt;2016年09月18日更新：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 微信 6.3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>让你的应用更好地利用 3D Touch - WWDC 2016 Session 228 笔记</title>
    <link href="https://shengpan.net/2016/06/23/3dtouch/"/>
    <id>https://shengpan.net/2016/06/23/3dtouch/</id>
    <published>2016-06-22T23:52:03.000Z</published>
    <updated>2016-06-23T00:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们回首 iPhone 的历程，不禁感叹它是如何不断改变我们对手机的认知的。从触屏改变手机的定义开始，距离传感器、光线传感器，到三轴陀螺仪、GPS、运动传感器、再到指纹。这些功能一步步地拓展 iPhone 的能力，不断地改变着我们的生活。</p><p>iPhone 6s 再次增加了新的功能 – 3D Touch。 它为iOS 设备的操作增加了另一个维度的能力，为用户提供了另一个操作体验，甚至是改变了用户的操作习惯。随着设备的普及和软件的跟进，3D Touch 也许会像指纹解锁一样，不可或缺的存在。</p><p>关于 3D Touch, Apple 主要为我们提供了两种封装好的功能：</p><ol><li>主屏幕快捷菜单 ( Home screen quick action)</li><li>预览 ( peek and pop )</li></ol><h3 id="Home-screen-quick-action"><a href="#Home-screen-quick-action" class="headerlink" title="Home screen quick action"></a>Home screen quick action</h3><p><img src="/content/images/2016/06/IMG_0001-1.jpg" alt=""></p><p>Home screen quick action 的表现形式非常简单，利用 3D Touch 按主屏幕图标，则会弹出该App 的快捷菜单。点击快捷菜单则会唤起app，并进入到相对应的功能。</p><p>主屏幕快捷菜单分为<strong>静态</strong>和<strong>动态</strong>的两种。静态即固定的菜单。动态则代表菜单项是可变的。例如激活一款聊天软件的 Quick Action，出现三个你联系最频繁的人。这便需要动态菜单来实现。</p><p>当然，他们的开发也同表现形式一样简单。</p><h4 id="静态快捷菜单"><a href="#静态快捷菜单" class="headerlink" title="静态快捷菜单"></a>静态快捷菜单</h4><p>创建一个静态的快捷菜单，只需要简单地在<code>Info.plist</code>中添加一个 <code>UIApplicationShortcutItems</code> 的 Array 即可。</p><p>你可以为快捷菜单指定标题、系统或自定义的icon等，所有这些，都只需要在 <code>UIApplicationShortcutItems</code> 下添加一些key 和 value 即可。这些key可以在<a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW32" target="_blank" rel="noopener">这里</a>找到。</p><p>iOS 10 中，快捷菜单同时可以附带显示一个 Widget ，也就是以前的 App Extension。如果你提供了多个 Extension，可以在 <code>Info.plist</code> 中添加 <code>UIApplicationShortcutWidget</code>，其 Value 代表快捷菜单中展示的 Extension 的 Bundle id. </p><h4 id="动态快捷菜单"><a href="#动态快捷菜单" class="headerlink" title="动态快捷菜单"></a>动态快捷菜单</h4><p>创建一个动态的快捷菜单也非常容易，只需要初始化并配置   <code>UIApplicationShortcutItem</code>, <code>UIMutableApplicationShortcutItem</code> 和 <code>UIApplicationShortcutIcon</code> 这三个类，并将其添加到 AppDelegate 中的 <code>shortcutItems</code> 属性即可。</p><p>值得一提的是，静态快捷菜单在 App 被安装的那一刻就可用了。区别于静态菜单，动态快捷菜单只有当第一次启动后才可用。</p><h4 id="处理快捷菜单的点击"><a href="#处理快捷菜单的点击" class="headerlink" title="处理快捷菜单的点击"></a>处理快捷菜单的点击</h4><p>这里分<em>当 App 被 kill</em> 和 <em>当 App 未被 kill</em>两种情况。</p><p>当 App 仍然在运行的情况下，点击快捷菜单会触发以下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"><span class="comment">// 做你想做的事</span></span><br><span class="line"><span class="comment">// 最后不要忘了调用completionHandler()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 App 被 kill 的情况下，点击快捷菜单会触发以下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="comment">// 通过 UIApplicationLaunchOptionsShortcutItemKey 在 launchOptions 中取得 UIApplicationShortcutItem</span></span><br><span class="line"><span class="comment">// 然后做你想做的事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Peek-and-Pop"><a href="#Peek-and-Pop" class="headerlink" title="Peek and Pop"></a>Peek and Pop</h3><p><img src="/content/images/2016/06/IMG_0002-1.jpg" alt=""></p><p>macOS 中按下空格键即可预览各种各样的文件。通过 3D Touch 现在它也来到了 iOS 中。这一操作被 Apple 很形象地称为 <strong>Peek and Pop</strong>。</p><p>Peek and Pop 将传统的 Push 操作分为了两步，当你的手指按压某行列表，背景开始模式模糊，然后出现一个预览界面，然后继续增加压力，伴随着俏皮的弹性动画，下一个界面呈现在你眼前。在 API 中，这两部分别被称为 <code>Preview</code> 和 <code>Commit</code>。 </p><h4 id="为你的-App-添加-Peek-and-Pop"><a href="#为你的-App-添加-Peek-and-Pop" class="headerlink" title="为你的 App 添加 Peek and Pop"></a>为你的 App 添加 Peek and Pop</h4><p>为 App 添加 Peek and Pop 非常简单，只要遵循以下几步：</p><ol><li>让需要预览的 ViewController 遵循 <code>UIViewControllerPreviewingDelegate</code> 协议</li><li>调用 <code>registerForPreviewing(with:sourceView:)</code> 注册该ViewController</li><li>在 preview 代理方法中提供一个预览的ViewController，<strong>并设置好 context 的 sourceRect</strong>.</li><li>在 commit 代理方法中，直接调用 <code>show(_:sender:)</code> 即可。</li></ol><p>编码的过程中，要注意检查 3D Touch 的可用性。 因为这项功能同定位一样，用户是可以将其关闭的！为了保证所有的用户都能使用到你 App 的功能，应当依据 3D Touch 的可用性，来编写不同的代码。 当 3D Touch 可用时，那就用上着炫酷的新功能吧！如果不支持 3D Touch，我们还有另外一个备选方案 – <code>UILongPressGestureRecognizer</code>.</p><p>另外，不要在 UIViewControllerPreviewingDelegate 中做非常耗时的工作，那会造成界面卡顿。</p><p>合理地利用 Peek and Pop 可以为用户带来无缝的体验。 例如，下一个界面会有大量的初始化工作，在preview的过程中，你可以预先加载并提供部分预览（同时也为下一个界面做准备)，记住不要卡住主线程，等到 Pop 时，界面已经初始化好了。这为用户提供了一个非常好的体验。</p><h4 id="Preview-Action"><a href="#Preview-Action" class="headerlink" title="Preview Action"></a>Preview Action</h4><p>在 Preview 的过程中，用户可以上滑来唤出类似 Action Sheet 的菜单。实现这一功能只需要重写 ViewController 中的 <code>previewActionItems() -&gt; [UIPreviewActionItem]</code>方法即可。<br>系统提供了和 <code>UIAlertAction</code> 非常类似的 <code>UIPreviewAction</code>，来实现 <code>UIPreviewActionItem</code>。</p><p>与 Action Sheet 不同的是，系统提供了 <code>UIPreviewActionGroup</code> 类，实现子菜单的功能。</p><p>在开发 Peek and Pop 的过程中，请记住以下原则</p><ol><li>让合适的内容支持 Peek and Pop (不要滥用这项特性）</li><li>始终返回相同的预览界面 （保持一致性和可预测性）</li><li>不要在preview代理方法中花太多的时间</li><li>为 context 设置正确的 sourceRect</li></ol><h3 id="UIPreviewInteractionDelegate"><a href="#UIPreviewInteractionDelegate" class="headerlink" title="UIPreviewInteractionDelegate"></a>UIPreviewInteractionDelegate</h3><p>iOS 10 中为我们带来了全新的 API，可以让你自定义 Peek and Pop 操作。 我们只需要让某个对象遵循 <code>UIPreviewInteractionDelegate</code> 协议，并在相对于的代理方法中做我们想做的事情就可以了。 </p><p>UIPreviewInteractionDelegate 一共包含以下四个方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须实现</span></span><br><span class="line"><span class="comment">// 这个方法可以让你精细地控制从按压到 Preview 触发过程中发生的事</span></span><br><span class="line"><span class="comment">// 配合 UIViewControllerTransitioningDelegate ，可以做类似新郎微博的 + 号菜单效果。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteraction</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction, didUpdatePreviewTransition transitionProgress: CGFloat, ended: Bool)</span></span> <span class="comment">// transitionProgress ranges from 0 to 1</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法也是必须实现的，用来处理一些 Interaction 被打断情况</span></span><br><span class="line"><span class="comment">// 比如说：接到一个电话。</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteractionDidCancel</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你可以用这个方法来控制 Delegate 的触发。</span></span><br><span class="line"><span class="comment">// return false 则不会触发其他代理方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteractionShouldBegin</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用这个方法来精细地控制 Preview -&gt; Commit 阶段</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteraction</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction, didUpdateCommitTransition transitionProgress: CGFloat, ended: Bool)</span></span></span><br></pre></td></tr></table></figure><p><code>UIPreviewInteractionDelegate</code> 让 3D Touch 变得更灵活了。如果我们希望 iOS 9 也支持这样的功能怎么办呢？ 不用担心，Apple 还提供了更底层的 API。</p><h3 id="Low-Level-Force-API"><a href="#Low-Level-Force-API" class="headerlink" title="Low Level Force API"></a>Low Level Force API</h3><p>在 UITouch 中有两个关键的属性为我们提供了压力相关数据的存储。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> force <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br><span class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> maximumPossibleForce <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br></pre></td></tr></table></figure><p><code>force</code> 代表当前 Touch 的压力系数，默认是 0.0 ~ 1.0。你也可以通过 <code>maximumPossibleForce</code> 来调整 <code>force</code> 的上限，来为其提供更宽的变化范围。</p><p>上面的 API 仅在支持 3D Touch 和 Apple Pencil 的设备上可用，所以在使用前，不要忘了检查 <code>UITraitCollection</code> 中的<code>forceTouchCapability</code>，来确定以上 API 是否可用。</p><blockquote><p>为什么将 forceTouchCapability 放在 UITraitCollection 中？</p></blockquote><blockquote><p>因为 Size Classes 将设备抽象成了 Size.</p></blockquote><h3 id="3D-Touch-的最佳实践"><a href="#3D-Touch-的最佳实践" class="headerlink" title="3D Touch 的最佳实践"></a>3D Touch 的最佳实践</h3><ol><li>每个 app 都应该提供 quick actions。其简创建简单，却能带来巨大的价值。</li><li>为高价值的任务提供一个快速的入口。</li><li>很重要的一点，你需要保证 quik action 的可预测性，用户们如果经常使用它，却发现每一次的结果都不一样，就会因此而困惑。</li><li>即使你做了 3D touch 用户也可以禁用这一项功能，因此不能过度依赖这项特性来做一些必须的事情,同时也要准备好备选方案。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>主页的 quick action 可以让你的app 直接进入相关行为。</li><li>Peek and Pop 允许你快速预览内容，并导航到对应界面。</li><li>UIPreviewInteraction 让你可以更精细地控制 3D Touch。</li><li>用户们期望你支持 3D touch。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.apple.com/videos/play/wwdc2016/228/" target="_blank" rel="noopener">WWDC 2016 Sssion 228 - A Peek at 3D Touch</a></p><p><a href="http://devstreaming.apple.com/videos/wwdc/2016/228a1kbxogojm4fviqc/228/228_a_peek_at_3d_touch.pdf" target="_blank" rel="noopener">WWDC 2016 Sssion 228 - A Peek at 3D Touch Presentation Slides</a></p><p><a href="https://developer.apple.com/library/prerelease/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1" target="_blank" rel="noopener">Adopting 3D Touch</a></p><p><a href="https://developer.apple.com/library/prerelease/content/samplecode/AppChat/Introduction/Intro.html" target="_blank" rel="noopener">Apple WWDC 示例代码: AppChat</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们回首 iPhone 的历程，不禁感叹它是如何不断改变我们对手机的认知的。从触屏改变手机的定义开始，距离传感器、光线传感器，到三轴陀螺仪、GPS、运动传感器、再到指纹。这些功能一步步地拓展 iPhone 的能力，不断地改变着我们的生活。&lt;/p&gt;
&lt;p&gt;iPhone 6s 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>电池电量与低电量模式</title>
    <link href="https://shengpan.net/2016/05/31/battery/"/>
    <id>https://shengpan.net/2016/05/31/battery/</id>
    <published>2016-05-30T19:31:24.000Z</published>
    <updated>2016-05-30T19:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>优步最近公布的数据显示，<a href="http://www.npr.org/2016/05/17/478266839/this-is-your-brain-on-uber" title="UberNews" target="_blank" rel="noopener">当电池快没电的时候，人们更愿意接受溢价</a>。同时，优步也表明他们并没有利用电量相关的数据来设置溢价规则。换句话说，我们在开发App的时候，可以通过电池电量来”提升用户体验”。</p><h3 id="电池状态与电量"><a href="#电池状态与电量" class="headerlink" title="电池状态与电量"></a>电池状态与电量</h3><p><code>UIDevice</code> 中有三个电池相关的属性:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isBatteryMonitoringEnabled) <span class="built_in">BOOL</span> batteryMonitoringEnabled <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0) __TVOS_PROHIBITED;  <span class="comment">// default is NO</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIDeviceBatteryState</span>          batteryState <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0) __TVOS_PROHIBITED;  <span class="comment">// UIDeviceBatteryStateUnknown if monitoring disabled</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="keyword">float</span>                         batteryLevel <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0) __TVOS_PROHIBITED;  <span class="comment">// 0 .. 1.0. -1.0 if UIDeviceBatteryStateUnknown</span></span><br></pre></td></tr></table></figure><p>我们可以通过 <code>batteryState</code> 来获取电池状态，通过 <code>batteryLevel</code>来获取电池电量信息。</p><p>值得一提的是，在获取电池信息之前，需要手动设置 <code>batteryMonitoringEnabled</code> 为 <code>YES</code>，不然<code>batterystate</code> 会返回 <code>Unkonw</code>. </p><p>如果想要订阅电池状态，可以注册为以下两个通知的观察者:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceBatteryStateDidChangeNotification</span>;</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceBatteryLevelDidChangeNotification</span>;</span><br></pre></td></tr></table></figure><p><code>batteryLevel</code> 的值每改变 0.05（也就是电池电量的 <strong>5%</strong>）, 就会触发一次 <code>UIDeviceBatteryLevelDidChangeNotification</code>。</p><h3 id="低电量模式"><a href="#低电量模式" class="headerlink" title="低电量模式"></a>低电量模式</h3><p>为了解决续航问题，Apple 在 iOS 9 中为 iPhone 添加了<a href="https://support.apple.com/en-gb/HT205234" title="低电量模式" target="_blank" rel="noopener">低电量模式</a> 。在此模式下，系统会通过禁用一些特性诸如电子邮件自动获取、后台刷新、Hey Siri等，来达到降低能耗的目的。</p><p>低电量模式的设置藏得比较深，以至于从设置中找到它对大多数人来说是一件非常困难的事。换句话说，用户打开了低电量模式，才能真正说明用户所处的情景需要尽可能地节约电量。因此，相比较于直接获取电池电量来说，探测低电量模式是否开启，更能直观地反应产品情景和用户心理。</p><h4 id="检测低电量模式"><a href="#检测低电量模式" class="headerlink" title="检测低电量模式"></a>检测低电量模式</h4><p>在 iOS 9 中，我们可以很容易地检测到用户是否开启了低电量模式，<code>NSProcessInfo</code> 提供了相对于的属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">NSProcessInfo</span> processInfo] isLowPowerModeEnabled]) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 做低电量模式下该做的事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，如果想要对低电量模式的变化做出响应，可以注册为以下通知的观察者：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSProcessInfoPowerStateDidChangeNotification</span>;</span><br></pre></td></tr></table></figure><p>当我们检测低电量模式的时候，需要注意以下两点:</p><ul><li>低电量模式仅支持 iOS 9 。当 App 需要兼容更早的版本时，先检查api的可用性。</li><li>低电量模式仅适用于 iPhone ,在 iPad 中，<code>isLowPowerModeEnabled</code> 的返回值始终为 <code>NO</code></li></ul><p>当我们检测到用户开启了低电量模式，可以为用户做一些小改变，来帮助用户延长电池续航。以下是 Apple 给出一些建议:</p><ul><li>停止使用定位服务</li><li>减弱动画效果</li><li>停止后台任务（比如网络请求）</li><li>禁用运动追踪</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html" target="_blank" rel="noopener">Energy Efficiency Guide for iOS Apps</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/707/" target="_blank" rel="noopener">WWDC 2015 Session 707 Achieving All-day Battery Life</a></li><li><a href="http://useyourloaf.com/blog/detecting-low-power-mode/" target="_blank" rel="noopener">Detecting low power mode</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;优步最近公布的数据显示，&lt;a href=&quot;http://www.npr.org/2016/05/17/478266839/this-is-your-brain-on-uber&quot; title=&quot;UberNews&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HengTian iOS Code Style</title>
    <link href="https://shengpan.net/2016/05/30/hengtian-ios-code-style-2/"/>
    <id>https://shengpan.net/2016/05/30/hengtian-ios-code-style-2/</id>
    <published>2016-05-30T00:16:55.000Z</published>
    <updated>2016-11-24T06:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HengTian-iOS-Code-Style"><a href="#HengTian-iOS-Code-Style" class="headerlink" title="HengTian iOS Code Style"></a>HengTian iOS Code Style</h1><h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><p>1.1 首先是为人编写程序，其次才是计算机</p><p>软件的生命周期贯穿产品的开发、测试、生产、用户使用、版本升级和后期维护等过程，只有易读、易维护的软件代码才具有生命力。</p><p>1.2 保持代码的简明清晰，避免过分的编程技巧</p><p>简单是最美，不要过分追求技巧，否则会降低程序的可读性。</p><p>1.3 编程时首先达到正确性，其次考虑效率</p><p>编程首先考虑的是满足正确性、健壮性、可维护性、可移植性等质量因素。</p><p>1.4 编写代码时需要考虑到代码的可测试性</p><p>不可以测试的代码是无法保障质量的，实现设计功能的同时，要提供可以测试、验证的方法。</p><p>1.5 函数（方法）是为一特定功能而编写，不是万能工具箱</p><p>方法是一个处理单元，是有特定功能的，所以应该很好地规划方法，不能是所有东西都放在一个方法里实现。</p><p>1.6鼓励多注释</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><blockquote><p>程序布局的目的是显示出程序良好的逻辑结构，提高程序的准确性、连续性、可读性、可维护性。统一的程序布局和编程风格，有助于提高整个项目的开发质量，提高开发效率，降低开发成本。</p></blockquote><p>2.1 遵循统一的布局顺序书写头文件和实现文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件头注释</span><br><span class="line">imports</span><br><span class="line">文件内部使用的宏</span><br><span class="line">常量定义</span><br><span class="line">文件内部使用的数据类型</span><br><span class="line">全局变量</span><br><span class="line">本地变量</span><br><span class="line">类定义/实现</span><br></pre></td></tr></table></figure><p>在实现中，合理地将功能相似的代码块归为一类，并用 <code>#pragma mark –</code> 做标记。</p><p>推荐的代码块划分如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Public Method</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Life cycle</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - IBAction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Navigation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Delegate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private Method</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Getter and Setter</span></span><br></pre></td></tr></table></figure><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><p>2.2.1 <code>If</code>、<code>else</code>、<code>else if</code>、<code>for</code>、<code>while</code>、<code>do</code>等语句自占一行，执行语句不得紧跟其后，不论执行语句有多少都要加<code>{}</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( numberA &gt; numberB )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> numberA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">[<span class="keyword">self</span> caculate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2.2 定义指针类型的变量，<code>*</code> 应该放在变量前</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *hello = <span class="string">@"Hello World!"</span>;</span><br></pre></td></tr></table></figure><p>2.3 源代码中关系较为紧密的代码应尽可能相邻</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="built_in">CGFloat</span> length;</span><br><span class="line"><span class="built_in">CGFloat</span> height;</span><br></pre></td></tr></table></figure><p>2.4 禁止使用TAB键，必须使用空格进行缩进，缩进为4个空格<br>在Xcode -&gt; Preferences -&gt; Text Editing -&gt; Indentation -&gt;Prefer indent using中，将值设置为Spaces。</p><p>2.5 程序的分界符 <code>{</code> 和 <code>}</code> 应独占一行并且位于同一列，同时与引用他们的语句对齐。<code>{}</code> 之内的代码块使用缩进规则对齐</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="literal">nil</span> == dic</span><br><span class="line">    || ( <span class="literal">NO</span> == [dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] ) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.6 相关的赋值语句等号对齐</p><p>2.7 一元操作符如<code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>*</code>、<code>&amp;</code>和<code>[]</code>、<code>.</code>、<code>-&gt;</code>前后不加空格</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!bValue</span><br><span class="line">iValue</span><br><span class="line">++iCount</span><br><span class="line">*strSource</span><br><span class="line">&amp;fSum</span><br></pre></td></tr></table></figure><p>2.8 多元运算符和他们的操作数之间至少需要一个空格</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fWidth = <span class="number">5</span> + <span class="number">5</span>;</span><br><span class="line">fLength = fWidth * <span class="number">2</span>;</span><br><span class="line">fHeight = fWidth + fLength;</span><br></pre></td></tr></table></figure><p>2.9 关键字之后要留空格。<br><code>if</code>、<code>for</code>、<code>while</code>等关键字之后应留一个空格再跟左括号<code>(</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == fWidth )</span><br></pre></td></tr></table></figure><p>2.10 方法名与形参不能留空格，返回类型与方法标识符有一个空格<br>方法名后紧跟<code>:</code>，然后紧跟形参，返回类型<code>(</code>与<code>-</code>之间有一个空格。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue </span><br><span class="line">sender:(<span class="keyword">id</span>)sender</span><br></pre></td></tr></table></figure><p>2.11 注释符与注释内容之间要用一个空格进行分割</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一段长注释 */</span></span><br><span class="line"><span class="comment">// 这是一句短注释</span></span><br></pre></td></tr></table></figure><p>2.12 长表达式（超过80列）要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当地缩进，使排版整齐</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == fWidth</span><br><span class="line">   || <span class="number">0</span> &lt; fLength )</span><br></pre></td></tr></table></figure><p>2.13 函数（方法）声明时，类型与名称不允许分行书写</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning</span><br></pre></td></tr></table></figure><p>2.14 类中功能模块以 <code>#pragma mark –</code>分割，上空两行，下空一行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark – UITextFieldDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)textFieldDidEndEditing:(<span class="built_in">UITextField</span> *)textField</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.15 方法实现时，参数过长则每个参数用一行，以冒号对齐</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWithFoo:(<span class="built_in">NSString</span> *)theFoo</span><br><span class="line">           rect:(<span class="built_in">CGRect</span>)theRect</span><br><span class="line">   interval:(<span class="built_in">CGFloat</span>)theInterval</span><br></pre></td></tr></table></figure><p>如果方法名比参数名短，则每个参数占用一行，至少缩进4个字符，且为垂直对齐（非冒号对齐）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="keyword">short</span>:(<span class="built_in">NSString</span> *)theFoot</span><br><span class="line">    longKeyword:(<span class="built_in">CGRect</span>)theRect</span><br><span class="line">    evenLongerkeyword:(<span class="keyword">float</span>)theInterval</span><br></pre></td></tr></table></figure><p>2.16 方法调用沿用声明方法的习惯 在同一行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomethingWith:<span class="string">@"test"</span> rect:<span class="keyword">self</span>.view.frame interval:<span class="number">1.0</span>f];</span><br></pre></td></tr></table></figure><p>或冒号对齐</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomethingWith:<span class="string">@"test"</span></span><br><span class="line">                 rect:<span class="keyword">self</span>.view.frame</span><br><span class="line">             interval:<span class="number">1.0</span>f];</span><br></pre></td></tr></table></figure><p>2.17 Protocol 声明中类型标识符、代理名称、尖括号间不留空格</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;MyProtocalDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>在类声明中包含多个protocal，每个protocal占用一行，缩进2个字符。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomBackButtonViewController</span> ()</span></span><br><span class="line">&lt;<span class="built_in">UITextFieldDelegate</span>,</span><br><span class="line">  MyProtocalDelegate,</span><br><span class="line">  <span class="built_in">UITabBarControllerDelegate</span>,</span><br><span class="line">  <span class="built_in">UITabBarDelegate</span>&gt;</span><br></pre></td></tr></table></figure><p>如果并非所有方法都是必须得，使用<code>@optional</code>标示。 </p><p>2.18 其他</p><p>函数（方法）块之间使用两个空行分隔</p><p><code>@public</code> 和 <code>@private</code> 使用单独一行，且缩进1个字符</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>3.1 一般情况下，源程序有效注释量必须在30%以上</p><p>注释语言不宜太多也不能太少，注释语言必须准确、易懂、简洁。</p><p>3.2 多行注释采用<code>/*…*/</code>，单行注释采用<code>//…</code></p><p>3.3注释应与其描述的代码相近</p><p>对代码的注释应放在其上方或右方相邻位置，不可放在下方，如放于上方则需要与其上面的代码用空行隔开</p><p>3.4 注释与所描述内容进行同样的缩排</p><p>3.5 文件最前面的注释，是保留了工程自动生成的注释，但是需要进行如下修改：文件作者改为个人的名字，公司名为Insigma Hengtian software Ltd</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by ArthurWang on 14-5-7.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Insigma HengTian Software Ltd. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>3.6 类、协议、结构体注释。如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @class HTServerDatamanager</span></span><br><span class="line"><span class="comment"> @abstract 异步连接服务器管理类</span></span><br><span class="line"><span class="comment"> @discussion 异步请求服务器，接收到响应后，通过回调把数据回传到对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>3.7 成员方法、接口注释。如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @method  initWithTarget：selector：</span></span><br><span class="line"><span class="comment"> @abstract  类初始化函数</span></span><br><span class="line"><span class="comment"> @discussion  本类使用时必须调用此函数进行初始化</span></span><br><span class="line"><span class="comment"> @param target 响应回调对象</span></span><br><span class="line"><span class="comment"> @param selector  回调对象的selector</span></span><br><span class="line"><span class="comment"> @result   类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>4.1 标识符要采用英文单词或其组合，便于记忆和阅读，切忌使用汉语拼音来命名</p><p>标识符应当直观且可以拼读，可望文知意，英文单词一般不要太复杂，用词应当准确。</p><p>4.2 严格禁止使用连续的下划线，下划线也不能出现在标识符头或结尾。<br>（实例变量及特殊用法除外）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 禁止使用以下命名方式</span></span><br><span class="line"><span class="built_in">CGFloat</span> variable__name;</span><br><span class="line"><span class="built_in">NSString</span> *variale___name;</span><br></pre></td></tr></table></figure><p>4.3 程序中不要出现仅靠大小区分的相似的标识符</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 禁止使用以下命名方式</span></span><br><span class="line"><span class="built_in">NSString</span> *contentOfView;</span><br><span class="line"><span class="built_in">NSString</span> *ContentOfView;</span><br></pre></td></tr></table></figure><p>4.4 宏、常量名都要使用大写字母，用下划线‘_’分割单词。</p><blockquote><p>注：优先采用常量命名以兼容Swift</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define HT_SCREEN_HEIGHT UIScreen.mainScreen.bounds.size.height</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下宏可以采用常量替代，则优先采用常量表示</span></span><br><span class="line"><span class="comment">// #define URL_LOGIN   @"/v1/user/login"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> URL_LOGIN = <span class="string">@"/v1/user/login"</span></span><br></pre></td></tr></table></figure><p>4.5 程序中局部变量不要与全局变量重名</p><blockquote><p>尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。</p></blockquote><p>4.6 使用一致的前缀来区分变量的作用域</p><blockquote><p>此条规范仅在 C 语言环境下使用，在命名Objective-C的属性时，仍然采用驼峰法命名，并且以小写字母开头。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_  全局变量</span><br><span class="line">s_  模块内静态变量</span><br></pre></td></tr></table></figure><p>4.7 方法名用小写字母开头的<strong>动词</strong>组合而成</p><blockquote><p>方法名力求清晰、明了、通过方法名就能够判断方法的主要功能。方法名中不同意义字段之间不要用下划线连接，而要把每个字段的首字母大写以示区分。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法名采用动词开头</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)touchDoneButton:(<span class="built_in">UIButton</span> *)sender;</span><br></pre></td></tr></table></figure><p>4.8 尽量避免名字中出现数字编号，如 Value1, Vlaue2 等，除非逻辑上的确需要编号</p><p>4.9 标识符前最好不加项目、产品、部门的标识</p><p>这样做的目的是为了代码的可重用性。</p><p>4.10 类名（及其 Category 和 Protocol）的首字母大写，驼峰法分割单词</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Category命名</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImage</span> (<span class="title">Scale</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Protocol命名</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">HTModelCallBack</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>4.11 工厂方法以去前缀的类名开头，首字母小写,返回类型必须为 <code>instancetype</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)person;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)personWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>4.12 初始化方法命名必须以 <code>init</code> 开头，带有参数的初始化方法，第一个参数用 <strong>With</strong> 做连接，后续参数不需要跟 <strong>with</strong>，返回类型必须为 <code>instancetype</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line"> age:(<span class="built_in">NSInterger</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>变量、常量和数据类型是程序编写的基础，是直接关系到程序设计的成败。</p></blockquote><p>5.1 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途<br>一个变量只用来表示一个特定功能，不要把一个变量作多种用途。</p><p>5.2 循环语句与判断语句中，不允许对其它变量进行计算与赋值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 禁止如下做法</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="number">100</span> &gt; (fWidth = <span class="number">50</span> * fLength) )</span><br></pre></td></tr></table></figure><p>5.3 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MY_MIN(A, B)   ((A)&gt;(B)?(B):(A))</span></span><br></pre></td></tr></table></figure><p>5.4 对于全局变量通过统一的函数访问</p><p>5.5 最好不要在语句块内声明局部变量</p><p>5.6 系统常用类作实例变量声明时加入后缀</p><table><thead><tr><th>类名</th><th style="text-align:center">所需后缀</th><th style="text-align:right">命名例子</th></tr></thead><tbody><tr><td>UIViewController</td><td style="text-align:center">ViewController</td><td style="text-align:right">loginViewController</td></tr><tr><td>UIImage</td><td style="text-align:center">Image</td><td style="text-align:right">avatarImage</td></tr><tr><td>UIImageView</td><td style="text-align:center">ImageView</td><td style="text-align:right">avatarImageView</td></tr><tr><td>UILabel</td><td style="text-align:center">Label</td><td style="text-align:right">nameLabel</td></tr><tr><td>UIView</td><td style="text-align:center">View</td><td style="text-align:right">carousleView</td></tr><tr><td>UIButton</td><td style="text-align:center">Button</td><td style="text-align:right">loginButton</td></tr><tr><td>UINavigationBar</td><td style="text-align:center">NavigationBar</td><td style="text-align:right">mainNavigationBar</td></tr><tr><td>UIToolbar</td><td style="text-align:center">ToolBar</td><td style="text-align:right">chatToolBar</td></tr><tr><td>UISearchBar</td><td style="text-align:center">SearchBar</td><td style="text-align:right">messageSearchBar</td></tr><tr><td>UITextField</td><td style="text-align:center">TextField</td><td style="text-align:right">nameTextField</td></tr><tr><td>UITextView</td><td style="text-align:center">TextView</td><td style="text-align:right">contentTextView</td></tr><tr><td>NSArray</td><td style="text-align:center">Array / s</td><td style="text-align:right">userArray / users</td></tr><tr><td>NSMutableArray</td><td style="text-align:center">MArray / s</td><td style="text-align:right">userMArray / users</td></tr><tr><td>NSDictionary</td><td style="text-align:center">Dictionary</td><td style="text-align:right">parameterDictionary</td></tr><tr><td>NSMutableDictionary</td><td style="text-align:center">MDictionary</td><td style="text-align:right">parameterMDictionary</td></tr><tr><td>NSString</td><td style="text-align:center">String</td><td style="text-align:right">parameterString</td></tr><tr><td>NSMutableString</td><td style="text-align:center">MString</td><td style="text-align:right">paramterMString</td></tr><tr><td>NSSet</td><td style="text-align:center">Set</td><td style="text-align:right">keySet</td></tr><tr><td>NSMutableSet</td><td style="text-align:center">Mset</td><td style="text-align:right">keyMSet</td></tr></tbody></table><p>5.7 属性声明严把权限，对不需要外部修改的属性使用 <code>readonly</code></p><p>5.8 <code>NSString</code>使用 <code>copy</code> 而非 <code>retain</code></p><p>5.9 <code>CFType</code> 使用 <code>@dynamic</code>，禁止使用 <code>@synthesize</code></p><p>5.10 除非必须，使用 <code>nonatomic</code></p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><blockquote><p>表达式是语句的一部分，他们是不可分割的。</p></blockquote><p>6.1 一条语句只完成一个功能</p><blockquote><p>复杂的语句阅读起来，难于理解，并容易隐含错误。</p></blockquote><p>6.2 在表达式中使用括号，使表达式的运算顺序更清晰</p><blockquote><p>由于将运算符的优先级与结合律熟记是比较困难的，为了防止产生歧义并提高可读性，即使不加括号时运算顺序不会改变，也应当用括号确定表达式的操作顺序。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ( ( <span class="number">0</span> == iYear % <span class="number">4</span> ) &amp;&amp; ( <span class="number">0</span> != iYear % <span class="number">100</span> ) ) || ( <span class="number">0</span> == iYear % <span class="number">400</span> ) )</span><br></pre></td></tr></table></figure><p>6.3 避免表达式中的附加功能，不要编写太复杂的复合表达式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 不要采用如下写法</span></span><br><span class="line"><span class="keyword">int</span> iResult = iYear++-++iMonth+iDay++;</span><br></pre></td></tr></table></figure><p>6.4 不可将布尔变量和逻辑表达式直接与YES、NO或则1、0进行比较</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( isSuccess ) <span class="comment">//真</span></span><br><span class="line"><span class="keyword">if</span> ( !isSuccess )<span class="comment">//假</span></span><br></pre></td></tr></table></figure><p>6.5 在条件判断语句中，当整型变量与 <code>0</code> 比较时，不可模仿布尔变量的风格，应当将整型变量用 <code>==</code> 或 <code>!=</code> 直接与 <code>0</code> 比较</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == iYear )</span><br><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> != iMonth )</span><br></pre></td></tr></table></figure><p>6.6. 应当将指针变量用 <code>==</code> 或 <code>!=</code> 与 <code>nil</code> 比较</p><blockquote><p>指针变量的零值是 <em>空</em>（即nil），nil的值与0相同，但是两者含义不同。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="literal">nil</span> == strName )</span><br></pre></td></tr></table></figure><p>6.7 在switch语句中，每一个<code>case</code>分支必须使用<code>break</code>结尾，最后一个分支必须是<code>default</code>分支<br>避免漏掉<code>break</code>语句造成程序错误，同时保持程序简洁。对于多个分支相同处理的情况可以共用一个<code>break</code>，但是要用注释加以说明。</p><p>6.8 <code>for</code>语句的循环控制变量的取值采用<strong>半开半闭区间</strong>写法</p><p>这样做更能适应数组的特点，数组的下标属于一个<strong>半开半闭区间</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iMax[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, iMax[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.9 不可在<code>for</code>循环内修改循环变量，防止<code>for</code>循环失去控制</p><p>6.10 循环嵌套次数不大于 <code>3</code> 次</p><p>6.11 <code>do while</code> 语句和 <code>while</code> 语句仅使用一个条件</p><p>6.12 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面</p><p>6.13 将 <code>int</code> 值转换为 <code>BOOL</code> 时应特别小心</p><p>6.14 Objective-C 中，<code>BOOL</code> 被定义为 <code>unsigned char</code> ，这意味着除了 <code>YES</code>（1）和<code>NO</code>（0）外它还可以是其他值。禁止将<code>int</code>直接转换为<code>BOOL</code>。</p><p>6.15 将整型值转换为<code>BOOL</code>的方法：使用三元运算符返回<code>YES</code> / <code>NO</code>，或使用<code>&amp;&amp;</code>，<code>||</code>。</p><p>6.16 <code>BOOL</code>、<code>_BOOL</code>和<code>bool</code>之间的转换是安全的，但是<code>BOOL</code>和<code>Boolean</code>间的转换不是安全的，所以将<code>Boolean</code>看成整型值。</p><p>6.17 在 Objective-C 中，只允许使用<code>BOOL</code>。</p><h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><blockquote><p>凡此变数中函彼变数者，则此为彼之函数</p></blockquote><p>7.1 方法不能为多个目的服务</p><p>一个方法只做一件事。</p><p>7.2 避免函数有太多的参数，参数个数尽量控制在5个以内</p><p>如果参数的确比较多，不妨把这些参数定义成一个结构（或一个类）。</p><p>7.3 对于有返回值的函数（方法），每一个分支都必须有返回值</p><p>为了保证对被调用函数返回值的判断，有返回值的函数中都每一个退出点都需要有返回值。</p><p>7.4 对输入参数的正确性和有效性进行检查</p><p>很多程序错误和崩溃是由非法参数引起的。</p><p>7.5 防止将函数（方法）的参数作为工作变量</p><p>将函数的参数作为工作变量，有可能错误地改变参数内容。对必须改变的参数，最好先用局部变量代之，最后再将该局部变量的内容赋给该参数。</p><p>7.6 函数（方法）体的规模不能太大，尽量控制在200行之内</p><p>冗长的函数不利于调试，可读性差。</p><p>7.7 Dealloc的顺序要与变量声明的顺序相同</p><p>这样有利于review代码。 如果dealloc中调用其他方法来release变量，将被release的变量以注释的形式标注清楚。 先release自身成员变量，再调用父类dealloc方法。</p><p>7.8 在接口中应该尽量少使用外部定义的类型（减少耦合）</p><p>7.9 禁止直接调用<code>NSObject</code>的类方法<code>+new</code>，也不要在子类中重载它。使用<code>alloc</code>和<code>init</code>方法。</p><p>7.10 创建对象时尽量使用<code>autorelease</code>，创建临时对象时，尽量同时在同一行中<code>autorelease</code>掉，而非使用单独的release语句。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>8.1 申明成员类，应该引用该类申明，而不是包含该类的头文件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">MyViewController</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) MyViewController *myViewController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>8.2共同的接口、结构体、常量和数据类型要定义在同一个头文件里</p><p>8.3 使用<code>#import</code>引入Objective - C和Objective - C++头文件，使用<code>#include</code>引入c和c++头文件</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>为保证代码的可靠性，编程时请遵循入下基本原则，优先级递减</p><ul><li>正确性</li><li>稳定性</li><li>可测试性</li><li>规范、可读性</li><li>全局效率</li><li>局部效率</li><li>个人表达方式/个人方便性</li></ul><p>9.1 防止内存操作越界</p><p>内存操作主要是指对数组、指针、内存地址等得操作，内存操作越界是软件系统主要错误之一，后果往往非常严重，引起崩溃。</p><p>9.2 当变量释放后，需要将变量置为nil</p><p>避免因为野指针引起的程序崩溃。</p><p>9.3 变量在使用前应初始化，防止未初始化的变量被引用</p><p>引用未初始化的变量，会引起程序的崩溃。</p><p>9.4 指针不要进行复杂的逻辑或算术操作</p><p>通过复杂的逻辑或算术操作后，指针的位置就很难确定。</p><p>9.5 减少指针和数据类型的强制类型转化</p><p>强制类型转化如果类型强转错误会引起崩溃。</p><p>9.6 在编写派生类的赋值时，主要不要忘记对基类的成员变量重新赋值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.7 使用 <code>Extension</code> 申明私有方法和属性,所有属性和实例变量都采用 <code>@property</code> 来申明</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, string) <span class="built_in">UITextField</span> *nameTextField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)login;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>9.8对变量进行赋值时，必须对其值进行合法性检查，防止越界等现象发生。</p><p>9.9 非初始化方法中的 <code>alloc</code> 操作之前必须要 <code>nil</code> 判断。</p><p>9.10 指针类型变量必须初始化为<code>nil</code>。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><blockquote><p>断言是对某种假设条件进行检查，可以快速发现并定位软件文件，同时对系统错误进行自动报警。</p></blockquote><p>10.1 整个软件系统应该采用统一的断言。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(str);</span><br></pre></td></tr></table></figure><p>10.2 正式软件产品中应把断言及其它的调测代码去掉，加快软件运行速度。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>11.1 避免过多直接使用立即数</p><p>应该都使用常量，采用立即数不容易理解含义并容易出错。</p><p>11.2 枚举第一个成员要赋初始值</p><p>11.3 <code>addObject</code>之前要非空判断</p><p>11.4 release版本代码去掉NSLog打印，除了保留异常分支的NSLog</p><p>11.5 禁止在代码中直接写死字符串资源，必须要用字符串ID替代</p><p>应该考虑多语言国际化，尽量使用NSLocalizedStringFromTable实现对字符串ID的引用。</p><p>11.6 对于框架设计，逻辑层尽量与UI层分离，降低耦合度</p><p>11.7 同等难度下，优先考虑代码实现窗体创建</p><p>11.8 delegate对象使用weak，禁止使用strong</p><p>11.9 Controller独立于View和Controller</p><p>不要在View相关的类中添加过多的业务逻辑代码，这让代码的可重用性很差。Controller负责业务逻辑代码，且Controller的代码与View尽量无关。</p><p>11.10 init方法和dealloc方法是最常用的方法，所以将他们放在类实现的开始位置</p><p>11.11 使用空格将相同的变量、属性对齐，使用换行分组</p><p>11.12 很重要的一点：你所创建的项目的文件夹目录结构和Xcode中的虚拟Group文件夹的结构必须一致，这便于后期代码文件的维护，能够避免由于移动文件造成的引用编译错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HengTian-iOS-Code-Style&quot;&gt;&lt;a href=&quot;#HengTian-iOS-Code-Style&quot; class=&quot;headerlink&quot; title=&quot;HengTian iOS Code Style&quot;&gt;&lt;/a&gt;HengTian iOS Code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C与Swift混编实践</title>
    <link href="https://shengpan.net/2016/04/12/usingswiftwithobjc/"/>
    <id>https://shengpan.net/2016/04/12/usingswiftwithobjc/</id>
    <published>2016-04-12T03:31:27.000Z</published>
    <updated>2016-06-22T01:36:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>###前言</p><p>由于Swift的语法趋于稳定，目前本人负责的项目也已经在小范围地引入Swift。关于混编过程中遇到的各种思考与选择，胡波的<a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=403474677&amp;idx=1&amp;sn=5163adb2d80aa5b4f0099f79e6d783e1&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">这篇文章</a>已经阐述得得比较全面了，看完文章回头看自己在混编过程中的各种选择，与胡先生的看法是一致的。在此梳理一下一些值得注意的小细节。</p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>基于Objective-C的工程一般都是将JSON转为Model,把数据以Model的形式在对象之间传递。当服务器传过来的值为空或者类型错误时，大部分解析框架都会将相对应的值置为nil。我们知道在Objective-C的世界里，向nil发送消息是不会引发任何错误的。</p><p>Objective-C中没有任何问题的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *GroupName;</span><br></pre></td></tr></table></figure><p>到了Swift的世界里，变成了:</p><p><img src="/content/images/2016/04/nullable-1.png" alt=""></p><p>没错，隐式解析的存在，导致了容错能力的下降。只要服务端回传的参数中有一个空字段，必然引发Crash。这简直是自寻死路。</p><p>因此我们需要在Objective-C中，将属性标上<code>nullable</code>，这样Swift中该属性变成了optional,然后采用<code>if let</code>或者<code>guard let</code>来安全地拆包。</p><blockquote><p>即使业务上决定了某些字段绝对不可能为null,也仍然要将其设为nullable。校验任何外来输入是编程时的基本准则之一。</p></blockquote><p>想必大家也想到了，这样一来，在混编的过程中，if let充斥着Swift的代码，虽然保证了安全，但一定程度上降低了开发效率。个人还在不断摸索解决这个问题的方法。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>在Objective-C的世界里，<code>@selector</code>是我们的老朋友了。但到了Swift中我们不得不这样来用<code>Selector</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.addTarget(<span class="keyword">self</span>, action: <span class="string">"resignFristResponder"</span>, forControlEvents: .<span class="type">EditingDidEndOnExit</span>)</span><br></pre></td></tr></table></figure><p>如果不仔细看，一定不会发现上面的代码中我错将<code>resignFirstResponder</code>写成了<code>resignFristResponder</code>。这在编译时不会出现任何提醒，但到了运行时会引起崩溃。</p><p>幸运的是，Swift2.2用<code>#selector</code>关键字替代了字符串反射。此时拼写错误可以被编译期正确地纠正了–因为编译期会检查到方法不存在，并报一个error。</p><p>你可以这样写一个不带参数的selector：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#selector(resignFirstResponder）</span><br></pre></td></tr></table></figure><p>如果是带参数的selector,则会稍微特别一点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#selector(textFieldDidChange(<span class="number">_</span>:)</span><br></pre></td></tr></table></figure><p>采用下划线来忽略参数名，但记得保留分号。</p><p>update:2016年06月22日</p><p>在Swift 3中，由于第一个参数也必须指定参数名，因此，selector的语法稍稍有一点点改变：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#selector(textFieldDidChange(textField:)</span><br></pre></td></tr></table></figure><p>有一点需要注意一下，Selector只支持反射Objective-C的方法，如果想要让#selector能正确识别Swift的方法，需要在方法前面加上<code>@objc</code>关键字</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>Swift得益于Module而避免了类的命名冲突。在用Swift编写代码的时候，应当遵循Apple官方的命名规范。例如类命名不需要在类名前加前缀。如果类也需要在Objective-C中被调用，可以用@objc关键字来为Objective-C生成对应的类名。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>(<span class="type">PSLimitedTextField</span>) <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedTextField</span>: <span class="title">UITextField</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>同时API的设计也建议按照官方的<a href="https://swift.org/documentation/api-design-guidelines" target="_blank" rel="noopener">指导原则</a>来。我从开始写Objective-C时就尽量模仿Apple的命名方式，后来在Objective-C到Swift的自动桥接上尝到了甜头。比如说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithName:(NSString *)name;</span><br></pre></td></tr></table></figure><p>被自动桥接成了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(name: <span class="type">String</span>)</span><br></pre></td></tr></table></figure><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>如果仔细对比Objective-C和Swift的接口，你会发现有的类的工厂方法消失了，有的类的还在。这同样是由于命名的问题所导致的。Apple将那些同类名一致的工厂方法桥接成了init方法，将一些默认单词(default,standard,shared etc.)开头的工厂方法保留了下来。</p><p>如：<code>[NSDate date]</code>变成了<code>NSDate()</code>.</p><p>但<code>[NSUserDefaults standardUserDefaults]</code>,保留了下来，变成了<code>NSUserDefaults.standardUserDefaults()</code></p><p><a href="https://github.com/DeveloperPans/PSNumberPad" target="_blank" rel="noopener">PSNumberPad</a>就因为工厂方法的命名问题，没能自动桥接成Swift的方法。因此，在混编过程中，如果Objective-C的组件有可能被Swift调用的，需要妥善设计接口以便自动桥接。一个最佳实践是，多采用<strong>convince initialzer</strong>替代工厂方法。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>在混编的过程中，大部分问题你可以在<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" target="_blank" rel="noopener">这里</a>找到想要的答案。再一次感谢Apple完善的文档！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###前言&lt;/p&gt;
&lt;p&gt;由于Swift的语法趋于稳定，目前本人负责的项目也已经在小范围地引入Swift。关于混编过程中遇到的各种思考与选择，胡波的&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;amp;m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Storyboard的爱与恨（下）</title>
    <link href="https://shengpan.net/2016/02/22/storyboard2/"/>
    <id>https://shengpan.net/2016/02/22/storyboard2/</id>
    <published>2016-02-21T23:53:04.000Z</published>
    <updated>2016-02-23T07:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Scene的转场"><a href="#Scene的转场" class="headerlink" title="Scene的转场"></a>Scene的转场</h3><p>如我们所料，Storyboard也可以通过可视化的操作来实现Scene的转场。</p><p>故事板的转场有两种，可以分为手动触发和自动触发。自动触发完全由Storyboard实现，而手动触发则需要配合代码。前者简单易用，后者适用于配合业务逻辑，进行不同转场的触发。自动触发的转场非常简单，我们只需选择一个UIControl(比如UIButton),按住Control+左键，拖线至目标Scene,选择<code>Action</code>类型，即可在触发UIControl的某些事件的时候，自动执行转场。<br><img src="/content/images/2016/02/ooooo-1.gif" alt=""></p><p>例如利用UIButton转场，实际上是在触发<code>TouchUpInside</code>事件时执行。这一简单的操作实际上相当于如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [self.button addTarget:self</span><br><span class="line">                    action:@selector(showPSViewControllerB)</span><br><span class="line">          forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)showPSViewControllerB</span><br><span class="line">&#123;</span><br><span class="line">    PSViewControllerB *viewController = [[PSViewControllerB alloc]init];</span><br><span class="line">    //配置..传值...</span><br><span class="line">    [self.navigationController pushViewController:viewController animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Storyboard将Scene转场变成了可视化的操作又引入了一个新的问题，需要如何传递参数给目标ViewController？</p><p>解决方法就是，我们需要在Storyboard中给Segue一个Identifier，然后在源ViewController中重写如下方法即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    if ([segue.identifier isEqualToString:[PSViewControllerB description]])</span><br><span class="line">    &#123;</span><br><span class="line">        PSViewControllerB *vc = segue.destinationViewController;</span><br><span class="line">        //配置..传值..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动触发则需要代码配合。不同的是，拖线的对象从UIControl变成了UIViewController(不要忘了在Storyboard中填写Segue Identifier)。</p><p><img src="/content/images/2016/02/aaa.gif" alt=""></p><p>然后在代码中需要转场的地方，加上<code>performSegueWithIdentifier:sender:</code>即可。例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//self:PSViewControllerA</span><br><span class="line">    if (isBizSuccess)&#123;</span><br><span class="line">        [self performSegueWithIdentifier:[PSViewControllerB description] sender:parameter];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self showTips:@&quot;some failure reason&quot;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>你可以利用<code>performSegueWithIdentifier:sender:</code>来进行任何形式的转场。Segue为我们的转场提供了不同的Action，囊括了常见的UINavigationViewController的push，或者所有ViewController都可以执行的Modelly Presentation。</p><blockquote><p>事实上，在iOS 8以后，我们就可以利用Storyboard结合代码实现自定义的转场，无论是在哪一种上下文环境中。</p></blockquote><p>采用Storyboard进行Scene转场的好处在于，一个ViewController的所有转场代码，都集中到了<code>prepareForSegue:sender:</code>方法中，debug或者添加新功能时，可以很容易顺藤摸瓜。但缺点同样明显。每次转场的修改/删除需要同时修改Storyboard和代码文件。同时，随着项目的进行，越来越多的Scene和业务逻辑，导致Storyboard中Segue的数量剧增，难以维护。</p><p><em>巨量的Segue(仅仅是部分截图)</em></p><p><img src="/content/images/2016/02/-----2016-02-22-17-04-05.png" alt="难以维护的Segue"></p><h4 id="多Storyboard协作"><a href="#多Storyboard协作" class="headerlink" title="多Storyboard协作"></a>多Storyboard协作</h4><p>解决如上问题的方法就是，尽量将项目的界面分割在多个Storyboard文件中。一个最佳实践是，按照项目功能模块来区分故事板，例如<code>Login.Storyboard</code>,<code>Chat.Storyboard</code>,<code>Person.Storyboard</code>等。尽量把每个Storyboard的Scene数量控制在20个以内。</p><p>同时，Scene间的转场我们依然可以采用Segue,并且使用起来和单个Storyboard无异。这要多亏Apple在iOS 9新推出的<br><a href="http://shengpan.net/top-tips-for-ios9/#StoryboardReference">UIStoryboard Reference</a>。</p><h3 id="代码可视化"><a href="#代码可视化" class="headerlink" title="代码可视化"></a>代码可视化</h3><p>还有什么能比代码可视化更加炫酷的呢？作为前端工程师，最享受的时候，就是枯燥的代码和算法变成了优美的动画。但这一切都只在按下command+R之后。</p><p>现在，通过Storyboard,我们也可以在编译时实时预览我们的代码所产生的效果。</p><h4 id="IB-DESIGNABLE"><a href="#IB-DESIGNABLE" class="headerlink" title="IB_DESIGNABLE"></a>IB_DESIGNABLE</h4><p><img src="/content/images/2016/02/IB_DESIGNABLE.gif" alt=""></p><p>通过为自定义的View添加<code>IB_DESIGNABLE</code>关键字（注意图中关键字的位置）,我们让Storyboard为我们自定义的视图进行实时渲染。有的人可能会担心实时渲染造成的性能问题。这点大可放心，Xcode有一套非常优秀的缓存机制(优秀到有些时候必须要clean一下，某些小改动才会在真机上生效),只需要编译一次，视图就会被缓存，不会造成每次在Storyboard、代码文件中切换时多次渲染的问题。</p><blockquote><p>在swift中则为@IBDesignable，放在class关键字之前</p></blockquote><p>到这里令人惊叹的类似Playground的事实渲染功能，已经可以动态地应用在项目中了。我们可以利用IB_DESIGNABLE和IBInspectable来制作图表等高度自定义的、独特的视图。</p><p>当然，故事板狂魔对故事板的使用不会就此罢手的，本着一切能用Storyboard配置就不写代码的原则，我们也希望可以在故事板中配置自定义控件的属性。幸运的是，Apple再次为我们的想法提供了可能。</p><h4 id="IBInspectable"><a href="#IBInspectable" class="headerlink" title="IBInspectable"></a>IBInspectable</h4><p><img src="/content/images/2016/02/IBInspectable.gif" alt=""></p><p>通过为自定义View的属性添加<code>IBInspectable</code>关键字（注意图中关键字的位置），我们可以将原本需要代码配置的属性，放到故事板中。IBInspectable支持以下类型的属性：</p><ul><li>BOOL </li><li> NSString</li><li>NSNumber </li><li>CGPoint</li><li>CGSize</li><li>CGRect</li><li>UIColor</li><li>NSRange</li><li>UIImage</li></ul><blockquote><p>在swift中则为@IBInspectable，放在var关键字之前</p></blockquote><h4 id="为系统控件添加IBInspectable"><a href="#为系统控件添加IBInspectable" class="headerlink" title="为系统控件添加IBInspectable"></a>为系统控件添加IBInspectable</h4><p>不少设计设都喜欢设计圆角。通常我们需要写如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.cornerRadius = 5;</span><br><span class="line">view.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure><p>为了解决这些重复代码的问题，有的人喜欢为View写Category，一行代码实现圆角。然而这需要在不同的ViewController中不断引入这个Category,不够优雅。当然，这种小事情我们也肯定不会愿意采用继承的。</p><p>实际上，我们只需要为项目添加一个View的Category，在其中声明一个@property并加上IBInspectable关键字,然后在实现文件中的getter&amp;&amp;setter方法中实现具体的逻辑。<strong>不用import头文件，也不需要运行</strong>,Storyboard中将自动出现这个属性以供配置。这不正是我们梦寐以求的完全解耦吗！？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//UIView+CornerRadius.h</span><br><span class="line">@interface UIView (CornerRadius)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) IBInspectable CGFloat cornerRadius;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//UIView+CornerRadius.m</span><br><span class="line">@implementation UIView (CornerRadius)</span><br><span class="line"></span><br><span class="line">- (void)setCornerRadius:(CGFloat)cornerRadius</span><br><span class="line">&#123;</span><br><span class="line">    self.layer.cornerRadius = cornerRadius;</span><br><span class="line">    self.layer.masksToBounds = cornerRadius &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)cornerRadius</span><br><span class="line">&#123;</span><br><span class="line">    return self.layer.cornerRadius;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><img src="/content/images/2016/02/CornerRadius.gif" alt=""></p><blockquote><p>实际上，IBInspectable是对运行时属性进行的一种拓展，你在Attributed Inspector中进行的自定义属性配置，都会在Identity Inspector的运行时属性中得到体现。</p></blockquote><h3 id="Storyboard的弊端"><a href="#Storyboard的弊端" class="headerlink" title="Storyboard的弊端"></a>Storyboard的弊端</h3><p>Storyboard也并非十全十美的。它依然有许多的问题亟待解决，有些致命的问题，更是成为导致许多开发者放弃Storyboard的原因。在iOS9普及率已经达到<a href="https://developer.apple.com/support/app-store/" target="_blank" rel="noopener">77%</a>的今天，Storyboard仍然有很多问题需要完善。</p><h4 id="难以维护"><a href="#难以维护" class="headerlink" title="难以维护"></a>难以维护</h4><p>Storyboard在某些角度上，是难以维护的。我所遇到过的实际情况是，公司一个项目的2.0版本，设计师希望替换原有字体。然而原来项目的每一个Label都是采用Storyboard来定义字体的，因此替换新字体需要在Storyboard中更改每一个Label。</p><p>幸亏我们知道Storyboard的源文件是XML，最终写了一个读取-解析-替换脚本来搞定这件事。</p><h4 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h4><p>当项目达到一定的规模，即使是高性能的MacBook Pro,在打开Storyboard是也会有3-5秒的读取时间。无论是只有几个Scene的小东西，还是几十个Scene的庞然大物，都无法避免。Scene越多的文件，打开速度越慢(从另一个方面说明了分割大故事板的重要性)。</p><p>让人沮丧的是，这个造成卡顿的项目规模并不是太难达到。</p><p>我猜想是由于每一次打开都需要进行I/O操作造成的，Apple对这一块的缓存优化没有做到位。可能是由于Storyboard占用了太多内存，难以在内存中进行缓存。Whatever,这个问题总是让人困扰的。</p><p>然而需要指出的是，采用Storyboard开发或采用纯代码开发的App，在真机的运行效率上，并没有太大的区别。</p><h4 id="错误定位困难"><a href="#错误定位困难" class="headerlink" title="错误定位困难"></a>错误定位困难</h4><p>Storyboard的初学者应该对此深有体会。排除BAD_EXCUSE错误不说，单单是有提示的错误，就足以让人在代码和Storyboard之间来回摸索，却无法找到解决方案。</p><p>一个典型的例子是，在代码中删除了IBOUTLET属性或者IBAction方法，但是却忘了在Storyboard中删除对应的连接，运行后crash。然而控制台只会输出一些模糊其词的错误描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &apos;NSUnknownKeyException&apos;, </span><br><span class="line">reason: &apos;[&lt;DrawViewController 0x7fe9f6a11240&gt; setValue:forUndefinedKey:]: </span><br><span class="line">this class is not key value coding-compliant for the key drawButton.&apos;</span><br></pre></td></tr></table></figure><p>有经验的开发者可以从drawButton这个关键字中找到突破口，但大部分刚接触Storyboard的开发者，会被困在其中。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>综合其利弊，毅然选择了站在Storyboard这边。一方面是其提供的便利，另一方面是Apple对Storyboard的大力支持。这一点宏观上看，可以在以往对Storyboard的改进和增强上看出，微观上看，几乎所有iOS 8之后的simple code都或多或少采用了Storyboard作为界面开发工具。有理由相信，Storyboard的未来是光明的。</p><p>愿大家在Storyboard的路(keng)上，越走越远。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Scene的转场&quot;&gt;&lt;a href=&quot;#Scene的转场&quot; class=&quot;headerlink&quot; title=&quot;Scene的转场&quot;&gt;&lt;/a&gt;Scene的转场&lt;/h3&gt;&lt;p&gt;如我们所料，Storyboard也可以通过可视化的操作来实现Scene的转场。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Storyboard的爱与恨（上）</title>
    <link href="https://shengpan.net/2016/02/02/storyboard/"/>
    <id>https://shengpan.net/2016/02/02/storyboard/</id>
    <published>2016-02-01T22:30:53.000Z</published>
    <updated>2016-02-23T07:38:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>尽管现在已经是Apple将Storyboard整合进Xcode中的第四个年头，大家对于Storyboard的评价仍然褒贬不一。<a href="http://onevcat.com/2013/12/code-vs-xib-vs-storyboard/" target="_blank" rel="noopener">有早期就选择转向Storyboard</a>用于UI开发的国内业界领头人物，也有<a href="http://martinnormark.com/the-story-of-no-storyboard-in-ios-development/" target="_blank" rel="noopener">创建项目就立马删除Storyboard</a>的大牛。我经历过纯代码布局，同时也在多个多人合作项目中使用Storyboard开发界面。在初期绕过各种坑后，Storyboard将会是快速构建UI界面的好帮手，特别是在现如今设备分辨率与尺寸日益增加的情况下，它可以帮助工程师们节约大量的界面代码书写时间。Storyboard存在的一大意义在于为UI提供了可视化开发方式，另一方面提供了一种更好的MVC的View层实现方式，让你的ViewController代码更简洁。当然，Storyboard的不足仍然不可忽视，错误的难以定位经常让刚上手的开发者们手足无措，相比于代码更不容易阅读的XML源文件所导致多人合作中的冲突不易解决等问题仍然有待完善。本文从各个方面介绍一下Storyboard，分享一下Storyboard的一些使用心得。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>1986年Jean-Marie Hullot发明了IB(Interface Build–Storyboard的前身),并且和Macintosh的工具箱无缝融合，这一工具被Denison Bollay发现了。第二年， Denison Bollay带着Hullot和他的IB到NeXT,将IB演示给Steve Jobs看。老乔立意识到了IB的价值，并将其纳入到了NeXTSTEP中。之后Steve 带着NeXT的技术结晶(当然也包括IB)重新回归Apple，并将之整合到了Apple的体系中。2008年第一代iPhone SDK发布的时候，IB就已经捆绑在其中。到了Xcode4,Apple更是直接将其集成进IDE里。随后随着不断地改进，更新，演变，最终变成了我们今天所看到的Storyboard。从某种角度来说，Storyboard也是老乔留给我们的众多礼物之一。</p><h3 id="故事板能做什么"><a href="#故事板能做什么" class="headerlink" title="故事板能做什么"></a>故事板能做什么</h3><p>故事板主要为我们提供了以下的功能：(这些功能都是<strong>可视化</strong>的)</p><ul><li>Auto Layout</li><li>Size Classes</li><li>Secnce的跳转 </li><li>代码可视化</li></ul><h4 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a>Auto Layout</h4><p>自动布局颠覆了之前直接操作Frame的布局方式，从思考<strong>View应该在哪个位置</strong>,变成了考虑<strong>在特定条件下，View的所处的位置需要满足哪些条件</strong>。通过这些条件来确定View的Frame。自动布局在实际应用中大体上可以将分为三组:</p><p><strong>View与Super View的约束</strong></p><p><img src="/content/images/2016/02/-----2016-02-19-15-27-33.png" alt=""></p><p><strong>View自身的约束</strong></p><p><img src="/content/images/2016/02/-----2016-02-19-15-27-47-2.png" alt=""></p><p><strong>View与Other View的约束</strong></p><p><img src="/content/images/2016/02/-----2016-02-19-15-27-58-2-1.png" alt=""></p><p>假如我们需要在代码中使用自动布局可以使用<br><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="noopener">Visual Format Language</a>或者<code>NSLayoutConstraint</code>的简单工厂方法来生成约束，然后添加到View上。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//用代码来实现上图中View与Super View的约束</span><br><span class="line">    UIView *superView = self.view;</span><br><span class="line">    UIView *subView = [[UIView alloc] init];</span><br><span class="line">    NSLayoutConstraint *leadingConstraint = [NSLayoutConstraint constraintWithItem:superView</span><br><span class="line">                                                           attribute:NSLayoutAttributeLeading</span><br><span class="line">                                                           relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                              toItem:subView</span><br><span class="line">                                                           attribute:NSLayoutAttributeLeading</span><br><span class="line">                                                          multiplier:1</span><br><span class="line">                                                            constant:15];</span><br><span class="line">    NSLayoutConstraint *TrailingConstraint = [NSLayoutConstraint constraintWithItem:superView</span><br><span class="line">                                                                         attribute:NSLayoutAttributeTrailing</span><br><span class="line">                                                                         relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                                            toItem:subView</span><br><span class="line">                                                                         attribute:NSLayoutAttributeTrailing</span><br><span class="line">                                                                        multiplier:1</span><br><span class="line">                                                                          constant:15];</span><br><span class="line"></span><br><span class="line">//topConstraint init...</span><br><span class="line">//bottomConstraint init...</span><br><span class="line">    [superView addConstraint:leadingConstraint];</span><br><span class="line">    [superView addConstraint:TrailingConstraint];</span><br><span class="line">    [superView addConstraint:topConstraint];</span><br><span class="line">    [superView addConstraint:bottomConstraint];</span><br><span class="line">    </span><br><span class="line">    // 如果是iOS8+ 则使用下面的方式来激活Constraint</span><br><span class="line">    // leadingConstraint.active = YES;</span><br><span class="line">    // leadingConstraint.active = YES;</span><br><span class="line">    // leadingConstraint.active = YES;</span><br><span class="line">    // leadingConstraint.active = YES;</span><br></pre></td></tr></table></figure><p>是不是一大团乱糟糟的代码?Visual Format Language用起来更加令人崩溃。好在业界已经有比较好的代码自动布局的<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">第三方解决方案</a>。但是仍然会有大堆的简单界面布局代码残留在你的代码中。</p><p>为了让你的生活更轻松(也为了让代码更清爽)，Storyboard就包含了非常优雅的可视化自动布局解决方案。以上一切，在Storyboard中都被浓缩成了两个按钮（下图红圈中的椭圆按钮）。</p><p><img src="/content/images/2016/02/1111.png" alt=""></p><ul><li>红框1:为被选中View和离他最近的View(可能是SuperView,也可能是另一个同层级的View,看哪个离它更近)添加Leading、Training、Top、Bottom四个属性约束。</li><li>红框2:为View添加自身宽和高约束</li><li>红色椭圆左侧按钮:当选中多个View时，为多个View添加约束</li></ul><p>只需要点击几下鼠标，Storyboard就可以帮你轻松完成视图布局。</p><h4 id="Auto-Layout-Debug"><a href="#Auto-Layout-Debug" class="headerlink" title="Auto Layout Debug"></a>Auto Layout Debug</h4><p>使用代码来对Auto Layout布局的另一个缺点在于debug的困难。当添加了多余的约束，往往只能在运行时才能发现错误。同时，要寻找出是哪一行代码添加了错误的约束也比较费力(往往连控制台都没有错误输出)。</p><p>而Storyboard却为此提供了非常友好的静态检查。主要针对View的约束、布局提供警告和Error,甚至是解决方案。</p><p><img src="/content/images/2016/02/-----2016-02-19-16-30-51.png" alt=""></p><p>上图的例子是：我们为Label添加了多余的约束，Storyboard用红色标记出冲突的约束，并给出修改建议:<em>删除其中一个约束以保证约束的正确性。</em>是不是很友好？ ：）</p><h4 id="Size-Classes"><a href="#Size-Classes" class="headerlink" title="Size Classes"></a>Size Classes</h4><p>Apple 与iOS 8推出了Size Classes的概念。意在解决因设备尺寸造成的适配问题。Size Classes通过将界面的宽度和高度抽象为<code>正常</code>和<code>紧凑</code>两种概念，通过合理的组合，可以将现有设备(以及未来将要出现的设备)划分到不同的Size中。因此，无论是代码还是界面布局，只需要针对Size进行，而不用再拘泥于分辨是iPhone还是iPad,是横屏还是竖屏的问题了。Size Classes的推出是具有前瞻性的，无论是Apple Watch还是iOS 9推出的的iPad 分屏模式，都可以用Size Classes完美解决适配的问题。</p><p>Size Classes和现有设备的对照表如下：</p><p><img src="/content/images/2016/02/-----2016-02-19-16-50-33.png" alt=""></p><p>在之前，我们要对横屏竖屏的界面进行区分，代码一般是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (IPAD_PORTRAIT)</span><br><span class="line">&#123;</span><br><span class="line">    //TODO:modify something portrait</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    //TODO:modify something landscape</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Size Classes时代，Apple引入了一个新的类<code>UITraitCollection</code>来封装水平和垂直方向的Size信息。现在我们通过代码来改变界面是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection </span><br><span class="line">              withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator</span><br><span class="line">&#123;</span><br><span class="line">    [super willTransitionToTraitCollection:newCollection </span><br><span class="line">                 withTransitionCoordinator:coordinator];</span><br><span class="line">    [coordinator animateAlongsideTransition:^(id &lt;UIViewControllerTransitionCoordinatorContext&gt; context) </span><br><span class="line">    &#123;</span><br><span class="line">        if (newCollection.verticalSizeClass == UIUserInterfaceSizeClassCompact) &#123;</span><br><span class="line">            //To Do: modify something for compact vertical size</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //To Do: modify something for other vertical size</span><br><span class="line">        &#125;</span><br><span class="line">        [self.view setNeedsLayout];</span><br><span class="line">    &#125; completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在TODO中做相对应Size的事。</p><p>可以想见的是，仍然会有非常多的布局代码占据着你的源文件。但在Storyboard中，一切变得异常简单。</p><p>使用Size Classes，我们只需要选择相对应的size，在那个Size下进行布局。运行时，就会根据设备的尺寸，自动地展示相对应Size的布局。比如iPhone竖屏就展示<code>width Compact height Regular</code>Size下的信息。当手机横屏，系统会自动添加一个过渡动画(虽然有点生硬),并转到<code>width Regular height Compact</code>的Size。这一切不需要一行代码。</p><blockquote><p>能不能再给力点?</p></blockquote><p>Sure.有这么一种情景:<em>iPhone横屏下，拥有一个<code>avatarView</code>,竖屏下拥有一个相同的<code>avatar View</code></em>。这种情况下我们只需要在一个Size中完成这个View,然后在Storyboard的<code>attributed inspector</code>中做一些勾选，将其”install”进相对应的Size中，就可以达到复用的目的。如果有差异，则在对应的Size中定制即可。（如下图）</p><p><img src="/content/images/2016/02/-----2016-02-19-17-07-12-1.png" alt=""></p><blockquote><p>能不能再给力点儿？</p></blockquote><p>Of Course！除了View,约束也可以不同Size配置不同。最厉害的是，图片文件也可以根据Size来区分。我们只需要对<code>.xcassets</code>文件勾选Size Classes,就可以为不同Size配置不同图片.这意味着，在同一个安装包下，通过Size Classes，我们甚至可以为横屏iPhone和竖屏iPhone做出完全不同的App!</p><p><img src="/content/images/2016/02/-----2016-02-19-17-29-01.png" alt=""></p><p><a href="http://shengpan.net/storyboard2">Storyboard的爱与恨(下)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尽管现在已经是Apple将Storyboard整合进Xcode中的第四个年头，大家对于Storyboard的评价仍然褒贬不一。&lt;a href=&quot;http://onevcat.com/2013/12/code-vs-xib-vs-storyboard/&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App Store审核指南-中文版</title>
    <link href="https://shengpan.net/2016/01/24/app-store-review-guidelines/"/>
    <id>https://shengpan.net/2016/01/24/app-store-review-guidelines/</id>
    <published>2016-01-23T23:26:37.000Z</published>
    <updated>2016-05-21T00:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h2><p>本文原文来自<a href="http://www.cocoachina.com/appstore/20160125/15089.html" target="_blank" rel="noopener">Cocoachina</a>.本文对其整理归纳，重点标注出开发者们不熟悉且容易触碰的雷区，并做了页内跳转的制作和格式的美化，以方便阅读和查询。</p><p>英文版文档原文为<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="noopener">App Store Review Guidelines</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感谢您付出宝贵的才华与时间来开发iOS应用程程序。从职业与报酬的角度而言，这对于成千上万的开发员来说一直都是一项值得投入的事业，我们希望帮助您加入这个成功的组织。我们发布了《App Store审核指南》（App Store Review Guidelines），希望通过它帮您避开开发应用程序过程中的一些问题，并帮你在提交应用时加快审核流程。</p><p>我们将应用程序（Apps）视为与书籍或歌曲不同的产品，我们并不存储它们。如果您意欲批评宗教，那就去写本书。如果您想要描述性，那就写本书或写首歌，或者可以创建一个医疗程序。这么做可能会比较复杂，但是我们不允许在应用程序商店（App Store）出现某种禁止内容。这会让您认识到我们秉持的更为深远的目的：</p><p>我们有很多可供儿童可以下载的应用程序。家长的监护可以很好地保护孩子，但是您需要做您应该做的那一部分。因此，您要了解我们时刻在留心着您的孩子。</p><p>App Store中有数百万的应用。如果您的应用程序没有什么有益的用途，不是独一无二的或者不能提供持续性的娱乐功能，那它可能不会被我方接受。</p><p>如果您的应用程序看上去像是那种只花了几天功夫简单拼凑出来的产品，或者只是想在我们的商店中抓住朋友的眼球，请提前做好被拒的准备。我们有很多态度严谨的开发者，不希望他们的高品质应用程序充斥在一些业余作品之中。</p><p>我们将拒绝任何包含越界内容或行为的应用程序。您可能会问道，具体限制是什么？最高法院的法官曾有言：”它出现时我自然心中有数。”当您越过这一范围时，我们认为您也会有自知之明。</p><p>如果您的应用程序被拒，我们设立了一个审查委员会供您上诉。如果您去媒体抨击我们，肯定对您于事无补。</p><p>如果您试着作弊（比如在审核流程中作假，窃取用户数据，抄袭其他开发者作品，或者操作应用评分），我们将会移除您的应用程序，并且将您从开发者计划中除名。</p><p>这是一个动态文档，新提交的应用程序会导致新的问题产生，并可能随时产生新的规则。或许您的应用程序会触及到这一点。 </p><p>最后要说明的是，我们非常珍惜这个平台，并且向您的作品表示敬意。我们确实在尝试尽力创建全球最佳平台，以便让您展示才华，同时获得相应的报酬。如果这读上去让您感觉我们的控制欲过强，那是因为我们曾向用户承诺保证，我们将利用我们的产品让他们获得高品质体验。</p><p>目录</p><ol><li><a href="#1">条款与条件</a></li><li><a href="#2">功能</a></li><li><a href="#3">元数据</a></li><li><a href="#4">位置</a></li><li><a href="#5">推送通知</a></li><li><a href="#6">游戏中心</a></li><li><a href="#7">广告</a></li><li><a href="#8">内容和知识产权</a></li><li><a href="#9">媒体内容</a></li><li><a href="#10">用户界面</a></li><li><a href="#11">购买与货币</a></li><li><a href="#12">抓取与聚合</a></li><li><a href="#13">设备损害</a></li><li><a href="#14">人身攻击</a></li><li><a href="#15">暴力</a></li><li><a href="#16">令人反感的内容</a></li><li><a href="#17">隐私</a></li><li><a href="#18">色情</a></li><li><a href="#19">宗教、文化与种族</a></li><li><a href="#20">竞赛、赌博、彩票和抽奖</a></li><li><a href="#21">慈善与援助</a></li><li><a href="#22">法律要件</a></li><li><a href="#23">Wallet</a></li><li><a href="#24">儿童类别</a></li><li><a href="#25">扩展</a></li><li><a href="#26">HomeKit</a></li><li><a href="#27">HealthKit</a></li><li><a href="#28">TestFlight</a></li><li><a href="#29">Apple Pay</a></li></ol><h3 id="1">1. 条款和条件</h3><br>1.1 为App Store开发程序，开发者必须遵守<a href="https://idmsa.apple.com/IDMSWebAuth/login?&amp;appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2F%2Fmembercenter%2Findex.action#agreements" target="_blank" rel="noopener">Program License Agreement(PLA)</a>、<a href="https://developer.apple.com/library/ios/documentation/UserExperience/conceptual/mobilehig/" target="_blank" rel="noopener">人机交互指南（HIG）</a>以及开发者和苹果签订的任何其他协议和合同。以下规则和例证旨在帮助开发者的程序能获得App Store的认可，而不是修改或删除任何其他协议中的条款。<br><br><h3 id="2">2. 功能</h3><p>2.1 崩溃的程序将会被拒绝。</p><p>2.2 存在错误的程序将会被拒绝。</p><p>2.3 跟开发者宣传不符的程序将会被拒绝。</p><p>2.4 无应用文档或隐藏功能与描述不符的程序将会被拒绝。</p><p>2.5 使用非公开API的程序将会被拒绝。</p><p>==2.6 在指定容器范围外读写数据的程序将会被拒绝。==</p><p>2.7 以任何方式或形式下载代码的程序将会被拒绝。</p><p>2.8 安装或运行其他可执行代码的程序将会被拒绝。</p><p>2.9 Demo版、trial版和test版的程序将会被拒绝。 Beta版应用程序仅能通过TestFlight提交，并且必须遵守相关指南。</p><p>==2.10 iPhone程序必须不经修改就能以iPhone分辨率和2倍 iPhone 3GS的分辨率在iPad上运行。==</p><p>2.11 与App Store已有程序重复的应用可能会被拒绝，特别是数量很多的情况下，比如手电筒应用和爱经应用。</p><p>2.12 没有显著用途、不独特的应用程序或者与网站简单捆绑的应用有可能被拒；不提供任何持久娱乐价值的程序可能会被拒绝。</p><p>2.13 内容主要是营销材料或广告的程序将会被拒绝。</p><p>2.14 包含欺骗或虚假功能，却有没有标明的应用程序将会被拒绝。</p><p>2.15 大于100MB无法通过蜂窝网络下载的应用（App Store会自动禁止）。</p><p>2.16 多任务程序使用后台服务仅限于几种目的：VoIP、音频播放、地理位置、完成任务以及本地提醒等。</p><p>==2.17 应用程序只允许使用iOS WebKit框架和WebKit Javascript浏览web内容。==</p><p>2.18 鼓励酗酒或使用违禁药物，或引诱青少年饮酒或吸烟的程序将会被拒绝。</p><p>2.19 提供错误的系统诊断或不精确的设备数据的应用将会被拒绝。</p><p>==2.20 向App Store上传大量相似版本程序的开发者将会从iOS开发者计划中除名。==</p><p>2.21 简单一首歌曲或者一部影片应用要提交到iTunes store，书籍类应用应该提交到iBookstore。</p><p>==2.22 武断地根据环境（如定位或者运营商）限制用户使用的应用会被拒。==</p><p>2.23 应用必须遵守iOS数据储存指导方针<a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="noopener">（iOS Data Storage Guidelines）</a>，否则应用将被拒。</p><p>2.24 存放在Newsstand的应用必须遵守开发者项目许可协议<a href="https://developer.apple.com/membercenter/index.action#agreements" target="_blank" rel="noopener">（Program License Agreement）</a>的表1、表2以及表3，否则应用将会被拒。</p><p>==2.25 使用户将其与App Store混淆，或者基于购买或者促销的目的而展示其他应用的应用将会被拒绝==</p><p>2.26 只有当app是出于特殊审核需要（比如健康管理、航空以及无障碍需求等）或为特殊群体用户提供具有重大意义的附加值时，才可以展示和推荐自身以外的其他应用程序，否则应用程序将会被拒绝。</p><p>2.27 如果App的核心功能不能使用Siri遥控器，那么App将会被拒绝。不过应用程序可以提供与游戏控制器或者其他周边设备相连接的增强功能。（2015.10 新增）</p><h3 id="3">3. 元数据（名称、描述、评级、排名等）</h3><p>==3.1 应用或者元数据中提到其他任何移动平台将会被拒。==<br>案例：AppStore上架描述中提到”Android同步上架”。</p><p>3.2 带有占位符文本的程序将会被拒绝。</p><p>3.3 应用程序的名称、描述、截图或者预览与应用的内容和功能不相关将会被拒绝。（旧版：3.3 描述中有与程序内容和功能不相关的信息的应用将会被拒绝。）</p><p>==3.4 为了不混淆用户，iTunes Connect中的应用名称应该和展示在设备上的应用名称一致。==</p><p>3.5 不同尺寸的app icon要一致，否则会造成混淆。</p><p>3.6 应用程序的icon、截图、预览以及位于Apple TV主屏幕顶部展区的Apple TV app的图片展示不符合4+年龄评级的程序将会被拒绝。 （2015.10 修正）</p><p>（旧版：应用程序的icon、截图以及预览不符合4+年龄评级的程序将会被拒绝。）</p><p>3.7 目录与类型不适合于程序内容的程序将会被拒绝。</p><p>3.8 开发者有责任为其程序指定适合的评级。不相称的评级可能会由苹果公司修改。</p><p>3.9 开发者有责任为其程序指定恰当的关键字。不恰当的关键词可能会被苹果公司修改/删除。</p><p>3.10试图通过伪造评论或者付费评论的方式在AppStore中操纵或者其欺骗用户评论（或者采用其他不正当方式）以提升排名的开发者将会被苹果从iOS开发者计划中除名。</p><p>3.11 在安装或打开应用之前，推荐用户重启iOS设备的应用将会被拒。</p><p>3.12 提交审核的应用程序应包含能正常运行的URL，比如支持服务URL和隐私政策URL。</p><p>3.13 应用程序的截图、预览或者营销文本没有清晰地指出附加内容或项目需要额外单独购买（比如使用IAP）将会被拒绝。</p><p>3.14 App预览仅能使用从应用程序捕获的视频屏幕、旁白、文本以及design overlays，否则应用程序将会被拒绝。</p><p>==3.15 添加App预览的应用程序，未经许可展示真人个人信息将会被拒绝。==</p><p>3.16 App预览仅能使用在所有选定地区内经过授权许可、用于此目的的音乐。</p><p>3.17 App预览和截图包含未经授权的通过App（如音乐、视频以及以及相关封面艺术设计）播放的内容或流媒体将会被拒绝。（2015.10 修正）</p><p>（旧版：App预览包含未经授权的通过app播放的内容（比如iTunes playlist和YouTube流媒体）的应用将会被拒绝。）</p><h3 id="4">4. 位置</h3><p>4.1 在收集、传输或使用位置数据之前未通知并获得用户同意的程序将会被拒绝。</p><p>4.2 将基于位置的API用于车辆、飞机或其他设备的自动控制或自主控制的应用程序将会被拒绝。</p><p>4.3 将基于位置的API用于应急服务的应用程序将会被拒绝。（旧版：4.3 将基于位置的API用于调度、车队管理或应急服务的程序将会被拒绝。）</p><p>4.4 当与提供的功能或服务密切相关，或者为支持经过授权的广告时，应用程序才可以使用位置数据。</p><h3 id="5">5. 推送通知</h3><p>5.1 不使用苹果推送通知 (APN)应用接口提供推送通知的程序将会被拒绝。</p><p>5.2 未从苹果获得Push Application ID便擅自使用APN服务的程序将会被拒绝。</p><p>5.3 在首次推送消息或者要求运行推送通知之前未获得用户许可的应用将会被拒绝。</p><p>==5.4 使用推送通知发送敏感个人信息或机密信息的程序将会被拒绝。==</p><p>5.5 使用推送通知发送非请求消息，或用于钓鱼或群发垃圾信息用途的程序将会被拒绝。</p><p>5.6 应用程序不可使用推送通知发送广告、促销或任何类型的直销信息。</p><p>5.7 应用程序不能向使用推送通知服务的用户收取费用。</p><p>5.8 使用推送通知会过多利用APN服务的网络流量或带宽或给设备带来过度负担的程序将会被拒绝。</p><p>5.9 如果应用程序传送病毒、文件、计算机代码或程序，并且对APN服务的正常运行造成损害或中断，那么该程序将会被拒绝。</p><h3 id="6">6. 游戏中心</h3><p>6.1 向终端用户或任意第三方显示玩家ID的程序将会被拒绝。</p><p>6.2 将玩家ID用于任何未经游戏中心条款批准用途的程序将会被拒绝。</p><p>6.3 试图进行反向搜索、跟踪、关联、挖掘、获得或利用玩家ID、别名或通过游戏中心获得其他信息的开发者将会iOS开发者计划除名。</p><p>6.4 游戏中心信息（例如排行榜分数），只能用于游戏中心批准的应用程序中。</p><p>6.5 利用游戏中心服务发送非请求信息，或用于钓鱼或群发垃圾邮件的程序将会被拒绝。</p><p>6.6 过多使用游戏中心网络流量或带宽的应用程序将会被拒绝。</p><p>6.7 如果程序能够传送病毒、文件、计算机代码或程序，并且对游戏中心服务的正常运行造成损害或中断，该程序将会被拒绝。</p><h3 id="7">7. 广告</h3><p>7.1 人工刷广告浏览量或者广告点击率的应用程序将会被拒绝。</p><p>==7.2 包含空iAd广告的应用程序将会被拒绝。==<br>例子:使用了广告标识符但是没有展示广告。（审核信息正确填写可以绕过这一案例）</p><p>7.3 主要设计目的在于显示广告的应用程序将会被拒绝。</p><h3 id="8">8. 内容与知识产权</h3><p>8.1 应用程序必须遵守”Guidelines for Using Apple Trademarks and Copyrights”和”Apple Trademark List”中说明的所有条款与条件。</p><p>8.2 任何误导和暗示苹果公司是该应用程序来源或提供商，或者苹果公司以任何形式表示认可其质量或功能的应用程序将会被拒绝。</p><p>8.3 与目前已有苹果产品或者广告主题外观相似或混淆的应用程序将会被拒绝。</p><p>==8.4 在应用程序名称中将苹果产品名拼错的应用程序（例如，GPS for Iphone，iTunz）将会被拒绝。==<strong>注</strong>，拼写注意大小写:iPhone,iPad,iOS…</p><p>8.5 应用程序不得使用受保护的第三方材料（比如商标、版权以及专利），不能违反第三方使用条款。必须提供使用这些材料的授权许可。</p><p>8.6 若无明确授权许可，从第三方来源处（比如YouTube、SoundCloud以及Vimeo等）下载音乐或者视频内容的应用程序将会被拒绝。（2015.3 新增）</p><h3 id="9">9. 媒体内容</h3><p>9.1 不使用媒体播放器框架（MediaPlayer Framework）获取音乐库中媒体内容的应用程序将会被拒绝。</p><p>9.2 用户界面模仿任何iPod或者iTunes界面的应用程序将会被拒绝。</p><p>==9.3 通过蜂窝网络传输的音频流内容每5分钟不得超过5MB。==<br><strong>注</strong>:做音乐播放器的开发者们需要特别关注</p><p>9.4通过蜂窝网络传输超过10分钟的视频流内容必须使用HTTP Live Streaming协议，并且要包含一个基线为192kbps或者更低的HTTP实时流。（2015.3 修正）</p><h3 id="10">10. 用户界面</h3><p>10.1 应用程序必须遵守苹果人机界面设计指南中所有的条款和条件，包括：</p><ul><li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/conceptual/mobilehig/" target="_blank" rel="noopener">iOS Human Interface Guidelines</a></li><li><a href="https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/" target="_blank" rel="noopener">OS X Human Interface Guidelines</a></li><li><a href="https://developer.apple.com/tvos/human-interface-guidelines/" target="_blank" rel="noopener">Apple TV Human Interface Guidelines</a></li><li><a href="https://developer.apple.com/watch/human-interface-guidelines/" target="_blank" rel="noopener">Apple Watch Human Interface Guidelines</a>.（2015.10 修正）</li></ul><p>（旧版：应用程序必须遵守苹果的《iOS Human Interface Guidelines》中所有的条款和条件。）</p><p>10.2 外观与iOS或Watch OS设备自带应用（比如App Store、iTunes Store和iBookstore）相似的应用程序将会被拒绝。（2015.4 修正）</p><p>10.3 未能按苹果《iOS Human Interface Guidelines》描述正确使用系统提供的项目（比如按钮、图标）的应用将会被拒绝。</p><p>10.4 创建桌面/主屏幕环境或者模拟multi-App插件体验的应用程序将会被拒绝。</p><p>10.5 修改音量大小和铃声/静音等标准开关功能的应用程序将会被拒绝。</p><p>10.6 苹果和我们的客户高度推崇简单、精致、富有创造性以及经过精心设计的界面。虽然需要付出更多，但却非常值得。苹果设立了很高的门槛。如果你的用户界面太过复杂或者水准不高，可能会被拒绝。</p><p>10.7 主要功能为报时的Watch app将会被拒。（2015.4 新增）</p><h3 id="11">11. 购买与货币流通</h3><p>11.1 使用App Store以外的渠道解锁或开启附加属性和功能的应用程序将会被拒绝。</p><p>11.2 使用应用内支付系统（IAP）以外的系统购买内容、功能或服务的应用软件将会被拒绝。</p><p>11.3 使用IAP购买实物商品或者用于该软件之外的商品和服务的应用软件将会被拒绝。</p><p>11.4 使用IAP购买积分（信用点）或者其他货币必须在本应用中消费。</p><p>11.5 使用IAP购买已过期积分或其他货币的应用软件将会被拒绝。</p><p>11.6 使用IAP订阅的内容至少要持续7天，而且允许在用户的其他iOS设备间共享。</p><p>11.7 使用IAP购买项目的应用程序必须指派正确的购买类型。</p><p>11.8 使用IAP购买使用iOS、watchOS以及tvOS内置功能（如照相机，陀螺仪）或者苹果品牌周边产品（比如苹果键盘、苹果电容笔）的应用程序将会被拒绝。（2015.10 修正）</p><p>旧版：使用IAP购买iOS内置功能（如照相机，陀螺仪）的应用程序将会被拒绝。</p><p>11.9 含有超过限定时间的内容或服务的应用程序将会被拒绝，除经特定批准的内容（比如电影、电视节目音乐以及书籍）。</p><p>11.10 保险类应用程序必须免费，要遵守发布地区的法律，并且不能使用IAP。</p><p>11.11 一般而言，你的应用程序越贵，我们的评审会越深入。</p><p>11.12 提供订阅功能的应用必须使用IAP，苹果将会按照 Developer Program License Agreement 中的约定与开发者按30/70比例分成。</p><p>==11.13 在应用内使用跳转至外部购买或订阅链接的应用将会被拒，比如”buy”按钮跳转至一个购买电子书的web页面。==</p><p>11.14 只要应用内没有跳转至外部购买、订阅的按钮或链接，苹果允许这些应用读取或展示经批准的、在应用外购买或订阅内容(特别是杂志、报纸、书籍、音频、音乐、视频以及云存储内容)。苹果只能通过应用程序内的购买获得一部分收益。</p><p>11.15 应用程序可以只使用自动更新订阅期刊(报纸、杂志)、商业应用程序(企业类、效率类、专业创意类以及云存储类)和媒体类应用程序(视频、音频、声音)，否则应用程序将被拒绝。</p><p>11.16 当与特定的经过审核的实体产品（比如玩具）结合使用时，应用程序可以使用获得批准的附加特性和功能，只要附加功能完全依赖于该硬件产品（比如一款用于控制望远镜的应用程序）或者也可以在不使用实物产品的情况下使用应用程序，比如成就奖励或者使用IAP。</p><p>11.17 如果应用功能遵照各州和联邦法律，那么应用可以用来促进被认可的虚拟货币的流通。</p><h3 id="12">12. 抓取和聚合</h3><p>==12.1 从苹果网站（例如apple.com、iTunes Store、App Store、iTunes Connect以及Apple Developer Programs等）抓取任何信息或者使用苹果网站内容和服务进行排名的应用程序将会被拒绝。 ==<br><strong>例子:</strong>检查版本更新</p><p>12.2 应用软件可以使用获得批准的苹果RSS feeds，例如iTunes Store RSS feeds。</p><p>12.3 只是简单的网页剪切、内容整合或者收集链接的应用程序可能会被拒绝。</p><h3 id="13">13. 损害设备</h3><p>13.1 怂恿用户以可能造成损害的方式使用苹果设备的应用软件将会被拒绝。</p><p>13.2 快速耗光设备电量或产生过多热量的应用软件将会被拒绝。</p><p>13.3 能导致用户人身伤害的app将会被拒绝。</p><h3 id="14">14. 人身攻击</h3><p>14.1 涉及诽谤、人身攻击性质以及内容狭隘卑鄙的应用软件或者打击特定个人或组织的应用软件将会被拒绝。</p><p>14.2 职业政治讽刺家和幽默作家不受这一条款约束。</p><p>==14.3 展示用户创作内容（UGC）的应用程序必须提供一个过滤不良资讯的方法，一个用户可以标记侵犯性内容的机制，以及可以阻止辱骂用户的能力。==<br><strong>注:</strong>社交类软件需要提供举报和反黄反暴力的机制。</p><h3 id="15">15. 暴力</h3><p>15.1 应用程序中出现人或动物被杀、致残以及枪击、刺伤、拷打等受伤情形的真实画面将会被拒绝。</p><p>15.2 出现描绘暴力或虐待儿童等内容的应用程序将会被拒绝。</p><p>15.3 游戏中出现的”敌人”不可指向一个特定种族、文化、一个真实存在的政府、企业或者其他任何现实中的实体。</p><p>15.4 对武器进行真实描述以怂恿非法使用或滥用这些武器的应用程序将会被拒绝。</p><p>15.5包含俄罗斯轮盘赌博内容的游戏将会被拒。</p><h3 id="16">16.令人反感的内容</h3><p>16.1 应用程序中出现过于令人反感或者低俗的内容将会被拒绝。</p><p>16.2 在设计上激怒用户或令人感到厌恶的应用程序将会被拒绝。</p><h3 id="17">17.隐私</h3><p>17.1 在未经用户事先许可，或未告知用户如何使用信息以及在何处使用信息的情况下，应用程序不能传输用户数据。</p><p>17.2 要求用户共享电子邮箱地址和出生日期等私人信息才可使用其功能的应用程序将会被拒绝。</p><p>17.3 仅出于遵守适用的儿童隐私法规的目的，应用程序可以要求用户的出生日期（或者使用其他年龄评级机制），但是必须包括一些有用的功能或者娱乐价值，不管用户年龄大小。</p><p>17.4 收集、传输以及分享未成年用户个人信息（比如名字、地址、邮件、位置、照片、视频、绘画、聊天信息以及其他个人数据，或者与以上所述相关的永久性标示符）的应用程序必须遵守应用儿童隐私法规，并且必须包含隐私条款。</p><p>17.5 包含账号注册或者访问用户现有账号的应用程序必须包含隐私策略，否则将会被拒绝。</p><h3 id="18">18. 色情</h3><p>18.1 含有色情素材，也就是《韦氏词典》中定义的”旨在激发情欲，对性器官或性行为的明确描述或展示，而无关美学或情绪感受”的程序将会被拒绝。</p><p>18.2 包含用户频繁提供的色情内容的应用程序（比如以前的“Chat Roulette”程序）将会被拒绝。</p><h3 id="19">19.宗教，文化与种族</h3><p>19.1 涉及宗教、文化或种族群体的引用或评论包含诽谤性、攻击性或狭隘内容，或会使特定群体遭受伤害或暴力的应用程序将会被拒绝。</p><p>19.2 程序可以包含或引用宗教经文，程序所提供的引用或翻译必须准确且不会引起误导。评论应该有教育意义，可以令人开阔眼界，而不应有煽动性。</p><h3 id="20">20. 竞赛、赌博、彩票以及抽奖</h3><p>20.1 彩票抽奖和竞赛必须由应用程序的开发者或者app所属公司发起。</p><p>20.2 应用程序必须展示彩票抽奖和竞赛的正式规则，并声明苹果不是发起者，也没有以任何方式参与活动。</p><p>20.3 开发者运营一款具有抽奖性质的应用必须经过法律允许，并且抽奖应用必须具备以下特征：报酬、运气以及奖品。</p><p>20.4 允许用户在应用中直接购买彩票或彩券的应用将会被拒。</p><p>20.5 提供真钱游戏（比如体育博彩、扑克牌、赌场游戏、赛马以及彩票）的应用程序必须有应用程序适用地区当地必要的许可和允许，必须限制在这些区域，必须可以从App Store免费下载。</p><p>20.6 使用IAP购买信誉或者货币，且结合真钱游戏的应用将会被拒绝。</p><p>21.慈善与援助</p><p>21.1 包含可以向已认证的慈善组织捐赠功能的应用程序必须是免费的。 </p><p>21.2 捐赠款项的募集必须通过Safari浏览器访问web页面或是手机短消息完成。</p><h3 id="22">22. 法律要件</h3><p>22.1 应用程序必须遵守所有发布地区当地法律，开发者有义务了解并遵守所有当地法律。</p><p>22.2 包含虚假，欺诈或误导性陈述的程序将会被拒绝。</p><p>22.3 任何用于招徕、促进或鼓励犯罪或明显鲁莽行为的应用程序将会被拒绝。</p><p>22.4 支持非法文件共享的程序将会被拒绝。</p><p>22.5 被设计用以非法赌博工具的应用程序（包括点算牌）将会被拒绝。</p><p>22.6 具有匿名或恶作剧拨打电话或发送类似短信/彩信功能的程序将会被拒绝。</p><p>22.7 任何开发暗中收集用户密码或用户私人数据程序的开发者将会从iOS开发者计划中除名。</p><p>22.8 包含非执法机构发布的DUI检查点信息，或者怂恿/协助酒后驾车的应用将会被拒绝。</p><p>22.9 计算药剂用量的应用程序必须由药品制造商或者认可机构发布，比如医院、保险公司以及高校。</p><p>22.10.在未授权的情况下使用iTunes音乐预览的应用程序将会被拒绝。</p><h3 id="23">23. Wallet</h3><p>23.1 Wallet Passes可被用来支付或者接收支付，传递商业信息或者提供验证（比如电影票、飞机票、优惠券以及其他），但把Wallet Passes用于其他用途的应用程序可能会遭到拒绝，并且会被撤销Wallet证书。（2015.9 修正）</p><p>（旧版：Passbook Passes可被用来支付或者接收支付，传递商业信息或者提供验证（比如电影票、飞机票、优惠券以及其他），但把Passbook Passes用于其他用途的应用程序可能会遭到拒绝，并且会被撤销Passbook证书。）</p><p>23.2 Passes必须包含有效的pass发行人有效的联系资料，否则app将会被拒绝，并且Wallet证书也会被取消。（2015.9 修正）</p><p>（旧版：Passes必须包含有效的pass发行人有效的联系资料，否则app将会被拒绝，并且Passbook证书也会被取消。）</p><p>23.3 Passes必须经过实体签名，并基于其名字、商标或者品牌进行分发，否则应用程序将会被拒绝，而Wallet证书也可能会被撤销。（2015.9 修正）</p><p>（旧版：Passes必须经过实体签名，并基于其名字、商标或者品牌进行分发，否则应用程序将会被拒绝，而Passbook证书也可能会被撤销。）</p><h3 id="24">24.儿童类别</h3><p>24.1 儿童类别中的应用程序必须包含隐私政策，必须遵守适用的儿童隐私法规。</p><p>24.2 儿童类别中的应用程序不允许包括行为广告（比如app内部基于用户行动的服务广告），任何在应用程序中展示的上下文广告必须适合儿童。</p><p>24.3 儿童类别中的应用程序必须得到家长许可或使用parental gate才能链接至应用程序外部或进行交易。</p><p>24.4 儿童类别中的应用程序必须标明”5岁以下，6-8岁或者9-11岁”。</p><h3 id="25">25.扩展</h3><p>25.1 包含扩展的应用程序必须遵照 App Extension Programming Guide要求。</p><p>25.2 包含扩展的应用程序必须提供某些功能（辅助屏幕，附加设置），否则将会被拒绝。</p><p>25.3 如果扩展的视图中包含营销推广、广告或者IAP内容，那么包含该扩展的应用将会被拒绝。</p><p>25.4 键盘扩展必须提供一个切换至下个键盘的方法。</p><p>25.5 键盘扩展必须具有离线访问功能，否则将会被拒绝。</p><p>25.6 键盘扩展必须提供和 App Extension Programming Guide 描述一致的数字和十进键盘类型，否则将会被拒绝。</p><p>25.7 提供键盘扩展的应用必须拥有基本的功能分类和隐私政策，否则将会被拒绝。</p><p>25.8 提供键盘扩展的应用程序只允许收集用户活动以增强键盘扩展在iOS设备上的功能，否则将会被拒绝。</p><h3 id="26">26.HomeKit</h3><p>26.1使用HomeKit框架的应用程序必须有提供家庭自动化服务的主要目的。</p><p>26.2 使用HomeKit框架的应用程序必须在营销文本中说明用途，同时必须提供隐私政策，否则将会被拒绝。</p><p>26.3应用程序不允许将从HomeKit API收集的数据用于广告宣传或者其他基于使用的数据挖掘。</p><p>26.4 出于其他目的使用从HomeKit API收集的数据，而不是用于提高用户体验或者家庭自动化功能中硬件/软件性能，这类应用将会被拒绝。</p><h3 id="27">27.HealthKit和人体生物学研究</h3><p>27.1 使用HealthKit或者ResearchKit框架（出于健康目的用于进行人体生物学研究的框架）的应用程序，必须遵守其所有适用区域的法律，以及iOS Developer Program License Agreement中的3.3.28和3.39条款。（2015.3 新增）</p><p><strong>27.2 将虚假或者错误的数据写入HealthKit的应用程序将会被拒绝。</strong></p><p>27.3 使用HealthKit框架的应用程序在iCloud中储存用户健康信息将会被拒绝。</p><p>27.4 应用程序不允许使用通过HealthKit API或者进行人体生物学研究收集的用户数据，或者将其泄露给第三方用作广告宣传或者基于使用的数据挖掘目的，除了改善健康、医疗、健康管理以及医学研究。（2015.3 修正）</p><p>27.5 未经用户许可与第三方分享通过HealthKit API获得的用户数据的应用程序将会被拒绝。</p><p>== 27.6 使用HealthKit框架的应用程序必须在营销文本中说明集成了Health app，同时必须在app用户界面清楚阐释HealthKit的功能。==</p><p>例如: 在 itunes connect 的 app description 中，写明：</p><blockquote><p>*XXX 会在您的授权允许下获取苹果自带应用“健康”中的运动步数用于XXX</p></blockquote><p>并在提交给审核员的Note中，注明App内的何处写明了需使用”健康”软件。</p><p>27.7 使用HealthKit框架或者进行人体生物学研究的应用程序必须提供隐私政策，否则将会被拒绝。（2015.3 修正）</p><p>27.8 提供诊断、治疗建议，或者控制诊断疾病的硬件，或者治疗疾病的应用程序，若没有根据要求提供书面的监管审批，将会被拒绝。</p><p>27.9 收集人体生物学研究相关数据的应用程序必须要获得参与者的许可，对于未成年人，应用程序要得到其父母或者监护人的许可。许可内容必须包括：(a)研究的性质、目的以及持续性；(b)参与流程、风险以及受益（福利）；(c)信息的机密性和数据处理（包括与任何与第三方的共享）；(d)参与者问题切入点；(e) 取消方法（2015.3 新增）</p><p>27.10 进行健康相关的人体生物学研究的应用程序必须得到独立伦理审查委员会的批准。并根据要求提供证明。（2015.4 新增）</p><h3 id="28">28.TestFlight</h3><p>28.1应用程序仅能使用TestFlight对以公开发布为目的的应用进行beta版测试，且必须遵守完整的App Review Guidelines。</p><p>28.2 当版本中包含的内容或功能有重大变化时，使用TestFlight的应用程序必须提交审核。</p><p>28.3 使用TestFlight的应用程序不允许分发给测试者，以作为任何形式的补偿。</p><h3 id="29">29. Apple Pay</h3><p>29.1使用Apple Pay的应用程序必须在出售任何商品或者服务之前为用户提供所有材料的购买信息，否则将会被拒绝。使用Apple Pay进行重复付款（译者注：定期付款）的应用程序必须提供最低限度续费期限，付费将持续直至被取消，每个阶段所付款额，费用付款方为客户，以及如何取消等。（2015.3 修正）</p><p>29.2 使用Apple Pay的应用程序必须正确使用<a href="https://developer.apple.com/apple-pay/Apple-Pay-Identity-Guidelines.pdf" target="_blank" rel="noopener">Apple Pay Identity Guidelines</a>中的Apple Pay标识和用户界面元素，否则将会被拒绝。（2015.3 修正）</p><p>29.3 使用Apple Pay作为购买机制的应用程序所提供的商品或服务不能触犯任何交付地范围内的法律，也不能用作任何非法目的。</p><p>29.4 使用Apple Pay的应用程序必须提供隐私政策，否则将会被拒绝。</p><p>29.5 只有为了促进或提高商品和服务的交付，或者依照法律要件，使用Apple Pay的应用程序才能与第三方分享通过Apple Pay获得的数据。</p><p>动态文档</p><p>这份文档展现了我们在竭尽所能向您分享我们对提交到App Store的程序的审查方式，我们希望您在开发和提交程序时，这份指南能对您有所帮助。这是一份动态文档，随着新程序和新情况的发生会有所变化。我们会定期更新，以反映这些变化。</p><p>感谢您参与到iOS的开发中来。虽然此文档是一份”不该做事宜”的列表，但也请将那份短得多的”必做事宜”列表牢记在心。最重要的是，与我们一道 共同努力让用户感到惊奇和欣喜。用创新方式向他们展示世界，让他们用前所未有的方式与之交流。根据我们的经验，无论是在功能和用户界面上，用户确实会对完善的程序有所响应。更进一步，给他们期望之外的东西，带他们去从未去过的地方。我们愿意提供帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;出处&quot;&gt;&lt;a href=&quot;#出处&quot; class=&quot;headerlink&quot; title=&quot;出处&quot;&gt;&lt;/a&gt;出处&lt;/h2&gt;&lt;p&gt;本文原文来自&lt;a href=&quot;http://www.cocoachina.com/appstore/20160125/15089.html&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用HeaderDoc自动生成API文档</title>
    <link href="https://shengpan.net/2016/01/24/headerdoc/"/>
    <id>https://shengpan.net/2016/01/24/headerdoc/</id>
    <published>2016-01-23T20:23:57.000Z</published>
    <updated>2016-01-23T22:54:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在为公司写框架和组件库。大家都建议在文档上需要更加完善一些。于是在思考如何规范地完善文档？<br>面向非技术型的boss们的说明性文档，手工写即可。面向组件使用者的文档呢？一方面，要保证注释的完整性，以保证其他同事在使用的时候只看注释即可。另一方面又需要要一份文本文档，以便随时查阅。如何同时做到这两点？</p><p>关于文档，业界有一些成熟的解决方案。例如评价颇高的<a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">AppleDoc</a>，还有从Xcode 5,iOS7开始集成在Xcode中的<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/usage/usage.html" target="_blank" rel="noopener">HeaderDoc</a>。本着一切以官方为准的原则，选择了HeaderDoc来完成这项工作。</p><h3 id="用HeaderDoc有什么好处？"><a href="#用HeaderDoc有什么好处？" class="headerlink" title="用HeaderDoc有什么好处？"></a>用HeaderDoc有什么好处？</h3><p><strong>与Xocde兼容</strong></p><p>将鼠标移动到某一行方法上，按option+鼠标左键试试？</p><p><img src="/content/images/2016/01/-----2016-01-24-13-32-04-2.png" alt=""></p><p><strong>可以自动导出文档</strong></p><p><img src="/content/images/2016/01/-----2016-01-24-13-34-03-1.png" alt=""><br><img src="/content/images/2016/01/-----2016-01-24-13-36-47-1.png" alt=""></p><p>居然如此炫酷，还不赶紧跟我一起用起HeaderDoc,走(tiao)上(jin)人(wen)生(dang)巅(da)峰(keng)？</p><h3 id="HeaderDoc-的注释标准"><a href="#HeaderDoc-的注释标准" class="headerlink" title="HeaderDoc 的注释标准"></a>HeaderDoc 的注释标准</h3><p>HeaderDoc的注释，一般我们会用到以下几种：</p><p><strong>头文件注释</strong></p><p>头文件基本信息。这个用在每个源代码文件的头文件的最开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> </span><br><span class="line"> @header UIImage+Scale.h</span><br><span class="line"> </span><br><span class="line"> @abstract 图片压缩的Category</span><br><span class="line"> </span><br><span class="line"> @author Created by Pan on 16/1/24.</span><br><span class="line"> </span><br><span class="line"> @version 1.2.0 16/1/24 Creation</span><br><span class="line">  </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li><code>@header</code> 与该源代码文件的名字一致</li><li><code>@abstract</code> 关于这个源代码文件的一些基本描述</li><li><code>@author</code> Sheng Pan (作者信息)</li><li><code>@version</code> 1.2.0 2012/01/20 Creation (此文档的版本信息)</li></ul><p><strong>类注释</strong></p><p>关于此类的一些信息。此注释用在类声明的开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"></span><br><span class="line">@class PSCarouselView</span><br><span class="line"></span><br><span class="line">@abstract 轮播控件，实现了常见的图片轮播功能。</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li><code>@class</code> 与该类名一致</li></ul><p><strong>属性注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"></span><br><span class="line">@property nameLabel</span><br><span class="line"></span><br><span class="line">@abstract 用于显示用户名的Label</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li><code>@property</code> 与该属性名一致</li></ul><p><strong>方法注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> </span><br><span class="line"> @abstract 将图片等比缩小</span><br><span class="line"> </span><br><span class="line"> @discussion 将图片等比缩小,注意:此方法在主线程运行，处理大量图片请使用scaleImageOnBackgroud:</span><br><span class="line"> </span><br><span class="line"> @param ratio 缩小的倍数。例如，如想缩小为原图的1/2 ratio = 2.0</span><br><span class="line"> </span><br><span class="line"> @result UIImage</span><br><span class="line"> </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li><code>@discussion</code> 该方法的详细描述，包括方法的一些注意事项，适用情况条件等等。</li></ul><p><strong>枚举注释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> </span><br><span class="line"> @enum Gender</span><br><span class="line"> </span><br><span class="line"> @abstract 性别枚举</span><br><span class="line"> </span><br><span class="line"> @constant GenderUnknow 性别未知</span><br><span class="line"> </span><br><span class="line"> @constant GenderMale 男</span><br><span class="line"></span><br><span class="line"> @constant GenderFemale 女</span><br><span class="line"></span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li><code>@enum</code> 与枚举名称一致</li><li><code>@constant</code> 与枚举值一致，后面添加描述</li></ul><p><strong>Category注释</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> </span><br><span class="line"> @category  Scale</span><br><span class="line"> </span><br><span class="line"> @abstract  UIImage的Category,添加图片压缩的相关功能</span><br><span class="line"> </span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><ul><li><code>@category</code> 与Category名称一致</li></ul><p><strong>Protocol注释</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"></span><br><span class="line">@protocol HTModelCallBack</span><br><span class="line"></span><br><span class="line">@abstract Model的回调接口。</span><br><span class="line"></span><br><span class="line">@discussion 想接收Model回调的类，申明并实现此接口，即可获取从HTBaseModel中回调的信息。注意：接收回调的前提，是使用DESIGNATED_INITIALIZER来初始化HTBaseModel(或其子类).</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><ul><li><code>@Protocol</code> 与Protocol名称一致</li></ul><p>常用的注释基本上就是这些，如果还需要了解更多注释的关键字请查阅<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/HeaderDoc/usage/usage.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="自动生成标准注释"><a href="#自动生成标准注释" class="headerlink" title="自动生成标准注释"></a>自动生成标准注释</h3><p>以上的注释格式如此繁琐，手工输入绝对不是我等懒鬼的作风。自动生成注释有以下几种方法</p><ol><li>修改Xcode模版文件，一劳永逸。</li><li>利用Xode的code snapshot，快速编写注释。</li><li>fork一份<a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="noopener">VV-Documentor-Xcode</a>然后修改里面的注释风格。（VV-Documentor-Xcode原来的注释风格不支持导出文档）。</li></ol><p>后两种不多做介绍，在此介绍一下修改Xcode模版文件的方法。</p><p><strong>打开finder，前往如下路径</strong></p><p><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/Source/Cocoa Touch Class.xctemplate</code></p><p>我们会看到这样一个目录</p><p><img src="/content/images/2016/01/-----2016-01-24-13-53-50.png" alt=""></p><p>每个文件夹下面的文件，就是各种系统类(包括你继承下来的子类)的模版文件。修改哪个文件夹下的模版文件，创建对应类(和继承自其子类的类)时，就会自动生成模版里预定的注释。</p><p>文件夹内包含了.h和.m两份文件，分别对应.h和.m文件的模版</p><p><img src="/content/images/2016/01/5.png" alt=""></p><p>我们打开.h模版文件，可以看到如下信息</p><p><img src="/content/images/2016/01/-----2016-01-24-13-55-14.png" alt=""></p><p>此处有几个系统的宏</p><ul><li><code>FILENAME</code>：文件名</li><li><code>PROJECTNAME</code>：项目名</li><li><code>FULLUSERNAME</code>：当前mac用户全称</li><li><code>DATE</code>：日期</li><li><code>COPYRIGHT</code>：版权声明</li></ul><p>我们将头文件修改为如下格式，在创建类的时候就可以自动生成我们需要的注释格式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*! </span><br><span class="line"></span><br><span class="line">  @header ___FILENAME___</span><br><span class="line"></span><br><span class="line">  @abstract &lt;#abstract#&gt;</span><br><span class="line"></span><br><span class="line">  @author Created by ___FULLUSERNAME___ on ___DATE___.</span><br><span class="line"></span><br><span class="line">  @version &lt;#version#&gt; ___DATE___ Creation</span><br><span class="line"></span><br><span class="line">___COPYRIGHT___</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">___IMPORTHEADER_cocoaTouchSubclass___</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line"> </span><br><span class="line">  @class ___FILEBASENAMEASIDENTIFIER___</span><br><span class="line"> </span><br><span class="line">  @abstract &lt;#description#&gt;</span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line">@interface ___FILEBASENAMEASIDENTIFIER___ : ___VARIABLE_cocoaTouchSubclass___</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其他文件如法炮制即可。</p><p>==*<em>注意:</em>== 记得逐一修改<code>Cocoa Touch Class.xctemplate</code>文件夹内每一个类的模版文件。只有修改过的类和其子类会起作用。</p><h3 id="自动导出文档。"><a href="#自动导出文档。" class="headerlink" title="自动导出文档。"></a>自动导出文档。</h3><p>规范的注释标好后，导出文档就很方便了。有两种方法可以导出文档。</p><h4 id="用命令行导出文档"><a href="#用命令行导出文档" class="headerlink" title="用命令行导出文档"></a>用命令行导出文档</h4><p>首先输出文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headerdoc2html -o DESTINATION_PATH PROJECT_PATH</span><br></pre></td></tr></table></figure><ul><li><code>DESTINATION_PATH</code>：文档输出目标文件夹。如<code>~/Desktop/documentation</code></li><li><code>PROJECT_PATH</code> ：项目目录。如<code>~/Desktop/project</code></li></ul><p>然后创建一个文档索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatherheaderdoc DESTINATION_PATH INDEX_PAGE_NAME</span><br></pre></td></tr></table></figure><ul><li><code>DESTINATION_PATH</code>：文档输出目标文件夹。如<code>~/Desktop/documentation</code></li><li><code>INDEX_PAGE_NAME</code>：索引页的名字。如<code>index.html</code></li></ul><h4 id="用Xcode-Build一份文档"><a href="#用Xcode-Build一份文档" class="headerlink" title="用Xcode Build一份文档"></a>用Xcode Build一份文档</h4><p>这个方法本质上也是用命令行导出文档。无非是可以不再需要手动管理文档路径，每个项目可以对应一个文档路径。用流行的话来说，就是一次配置，到处留情。哦不，是一次配置，自动运行。</p><p>首先在你的项目中新建一个target。类型选择为Other-Aggregate。</p><p><img src="/content/images/2016/01/-----2016-01-24-14-28-23.png" alt=""></p><p>在Target的Build-Phases中，点击加号，选择New Run Phases Script。</p><p><img src="/content/images/2016/01/-----2016-01-24-14-26-41-1.png" alt=""></p><p>粘贴如下脚本（注意修改你自己的工程目录和导出目录）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell script goes here</span></span><br><span class="line"></span><br><span class="line">headerdoc2html -o ~<span class="regexp">/Desktop/doc</span> /Users/pan/DEV/iOS/ios-standardization/Example/Pods/Headers/Public/HTStandard</span><br><span class="line"></span><br><span class="line">gatherheaderdoc ~<span class="regexp">/Desktop/doc</span> index.html</span><br><span class="line"></span><br><span class="line">exit <span class="number">0</span></span><br></pre></td></tr></table></figure><p>最后，选择这个target，并Run。然后就等待奇迹的发生吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在为公司写框架和组件库。大家都建议在文档上需要更加完善一些。于是在思考如何规范地完善文档？&lt;br&gt;面向非技术型的boss们的说明性文档，手工写即可。面向组件使用者的文档呢？一方面，要保证注释的完整性，以保证其他同事在使用的时候只看注释即可。另一方面又需要要一份文本文档，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译] iOS 9 开发小技巧</title>
    <link href="https://shengpan.net/2015/12/15/top-tips-for-ios9/"/>
    <id>https://shengpan.net/2015/12/15/top-tips-for-ios9/</id>
    <published>2015-12-15T00:26:57.000Z</published>
    <updated>2016-02-22T22:31:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>###前言<br>“小黄鸭”法不仅适用于debug,也适用于学习新知识。表达是最好的吸收。<a href="https://realm.io/news/tips-for-ios-9-development/" target="_blank" rel="noopener">本文原文</a>发表在realm.io上。我翻译并整理成此文。希望可以为国内的iOS朋友提供一些资料。</p><p>###LayoutGuide</p><p>在iOS9.0 和 OS X10.11中，分别有两个新的类：<code>UILayoutGuide</code> 和 <code>NSLayoutGuide</code>。他们可以作为一种类似View的对象，参与到AutoLayout的布局约束中。作为一种新的布局解决方案,这两个类的出现使你无需再创建、显示无关的View了。举个栗子，原本需要一个空的<code>UIView</code>占位的地方，现在只需要用<code>UILayoutGuide</code>去替代它就可以了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建LayoutGuide</span></span><br><span class="line"><span class="keyword">let</span> layoutGuideA = <span class="type">UILayoutGuide</span>()</span><br><span class="line"><span class="keyword">let</span> layoutGuideB = <span class="type">UILayoutGuide</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到View上</span></span><br><span class="line"><span class="keyword">let</span> view: <span class="type">UIView</span> = ...</span><br><span class="line">view.addLayoutGuide(layoutGuideA)</span><br><span class="line">view.addLayoutGuide(layoutGuideB)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用UILayoutGuide来添加布局约束</span></span><br><span class="line">layoutGuideA.heightAnchor.constraintEqualToAnchor(layoutGuideB.heightAnchor).active = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Identifier，为了方便DEBUG</span></span><br><span class="line">layoutGuideA.identifier = <span class="string">"layoutGuideA"</span></span><br><span class="line">layoutGuideB.identifier = <span class="string">"layoutGuideB"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...然后看看他们的Frame吧</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"layoutGuideA.layoutFrame -&gt; <span class="subst">\(layoutGuideA.layoutFrame)</span>"</span>)</span><br></pre></td></tr></table></figure><p>###NSLayoutAnchor<br>iOS9中另一个新增的API是<code>NSLayoutAnchor</code>。它的出现不仅仅是让使用代码添加约束变得简洁明了。通过该类强大的静态检查能力，还提供了额外的约束正确定保证。举个栗子，考虑以下使用<code>NSLayoutConstraint</code>API创建的约束会出现什么问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSLayoutConstraint *constraint = </span><br><span class="line">    [NSLayoutConstraint constraintWithItem:view1 </span><br><span class="line">                                 attribute:NSLayoutAttributeLeading </span><br><span class="line">                                 relatedBy:NSLayoutRelationEqual </span><br><span class="line">                                    toItem:view2 </span><br><span class="line">                                 attribute:NSLayoutAttributeTop </span><br><span class="line">                                multiplier:1.0 </span><br><span class="line">                                  constant:0.0];</span><br></pre></td></tr></table></figure><p>这个约束是无效的。因为你将一个X轴上的属性(leading)同一个Y轴属性(top)绑定。然而，这个错误可以毫无警告地通过编译，在运行的时候<strong>默默地</strong>就失效了，最终留下一个出错的布局。由于这个错误不会产生任何的日志信息，导致极难debug。假如工程里有许多(成千上万)这样的约束代码，那对于维护来说真是一场噩梦。</p><p>好在<code>NSLayoutAnchor</code>利用了”泛型”解决了这个问题。”泛型”现在在Swift和Objective-C中都已经得到了支持。<code>UIView</code>中<code>NSLayoutAnchor</code>相关的存取方法，明确指出了需要哪些继承自<code>NSLayoutAnchor</code>的子类。这些子类被分为了三类，X轴，Y轴，和尺寸(宽/高)，一种类型的Anchor只允许绑定约束到另外一个相同类型的Anchor上。通过指定<code>NSLayoutAnchor</code>中参数的类型，这个API可以通过类型检查，来避免创建出例子中无效的约束。</p><p>我们回到之前的例子，用<code>NSLayoutAnchor</code>来实现一下这个约束：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSLayoutConstraint *constraint = </span><br><span class="line">    [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];</span><br></pre></td></tr></table></figure></p><p>相比旧的API，新的API非常明显地提升了代码可读性。并且，当你传入错误的Anchor类型时，新的API会抛出一个”Incompatible pointer type”警告，因为编译器知道这个是两个不同的类。</p><p>想要了解更多，请查阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/index.html#//apple_ref/occ/instm/NSLayoutAnchor/constraintEqualToAnchor:constant:" target="_blank" rel="noopener">NSLayoutAnchor官方文档</a></p><p>###HTTPS 和 HTTP<br>Apple介绍了iOS9中的<a href="https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/" target="_blank" rel="noopener">App Transport Security</a>，它要求所有App在默认情况下使用HTTPS来进行网络请求。由于不是所有的服务器都运行在HTTPS环境下，Apple也提供了相关的方法来禁用ATS。</p><p>如果你的App需要请求的网址不可控（比如说UIWebVeiw请求的网站，有可能是HTTP的，也有可能是HTTPS的)，那么你应当将Info.plist文件中的<code>NSAllowsArbitraryLoads</code>设置为YES，来完全禁用ATS。出于数据安全考虑，在完全禁用ATS的情况下，你也应该为某些重要的站点打开ATS。你可以通过<code>NSExceptionDomains</code>key来禁用/启用特定的站点的ATS。参照如下图片:<br><img src="/content/images/2015/12/ios9-tips-conrad-info-plist.png" alt=""></p><p>该plist文件允许用户在HTTP环境下下载文件，但是只能在HTTPS情况下访问”workflow.is”</p><p>需要提醒的是，ATS的设置只针对当前bundle。这意味着你不仅需要在你主项目的info.plist中添加ATS相关的Key,同时也需要在其他bundle下的info.plist中添加相关配置。</p><p>关于iOS9的适配，github上有一个中文项目<a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="noopener">iOS9AdaptationTips</a>可以提供很大的帮助。</p><p></p><h3 id="StoryboardReference">Storyboard Reference</h3><br>Storyboard真是让人又爱又恨，每个在多人合作项目中使用Storyboard的人，都遇到过Storyboard文件的冲突。类似的冲突解决起来比较棘手，常常是以回滚告终。这一点直接造成了一些团队放弃使用Storyboard开发而推荐纯代码布局。<p></p><p>如果需要使用Storyboard，但又想最大化地避免冲突呢？最好的方法就是将UI划分的更小的、不同的Storyboard文件中。在过去如果想要做到这一点，意味跨Storyboard的跳转方法，需要在代码里完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIStoryboard *destinationStoryboard = [UIStoryboard storyboardWithName:@&quot;StoryboardName&quot; bundle:nil];</span><br><span class="line">DestinationViewController *vc = [destinationStoryboard instantiateViewControllerWithIdentifier:@&quot;identifier&quot;];</span><br><span class="line"></span><br><span class="line">//一顿设置</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[self.navigationController pushViewController:vc animated:YES];</span><br></pre></td></tr></table></figure><p>在Xcode7 和 iOS 9中，只需要用Storyboard Reference就可以用Segue轻松实现跨Storyboard的跳转了。<code>Storyboard Reference</code>的出现，保留了单个Storyboard文件跳转的优点的同时，提供了多Storyboard文件时利于合并的便利。</p><p>开始分割你那巨大的Storyboard文件吧。最快的方法是:</p><ol><li>缩放Storyboard</li><li>框选一组逻辑相近的scenes</li><li>选择Editor &gt; Refactor to Storyboard…</li></ol><p>自动Refactord的故事板文件会为每一个scenes留下一个<code>UIStoryboard Reference</code>，并且在需要的地方自动创建可读性不好的Storyboard ID。所以就个人来说，我更推荐手动复制scenes到新的故事板文件中，然后在源文件中删除这些scenes并手动添加<code>Storyboard Reference</code>。</p><p>如果你已经有多个故事板文件了，为自己庆祝一下吧——你又可以精简你的代码了！从Object库中拖拽一个<code>UIStoryboard Reference</code>，并配置segue。然后选取你手动跳转的代码，大力地按下删除键吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###前言&lt;br&gt;“小黄鸭”法不仅适用于debug,也适用于学习新知识。表达是最好的吸收。&lt;a href=&quot;https://realm.io/news/tips-for-ios-9-development/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈组件封装的思路和实现--PSCarouselView</title>
    <link href="https://shengpan.net/2015/11/12/pscarouselview/"/>
    <id>https://shengpan.net/2015/11/12/pscarouselview/</id>
    <published>2015-11-12T01:08:29.000Z</published>
    <updated>2016-11-23T22:04:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天面试了一个应聘者，他的演示项目里有广告轮播功能。恰好之前我封装过一个实现了此功能的控件，于是就顺着他广告轮播的实现一直往下聊，从需求的抽象一直聊到各种实现的细节和需要考虑的问题等等。组件的封装是开发中比较有趣的一件事。今天我们就拿轮播控件举例，聊聊组件的封装。</p><p>授人予渔先要授人予鱼。<a href="https://github.com/DeveloperPans/PSCarouselView" target="_blank" rel="noopener">先给出鱼(PSCarouselView)</a>，再慢慢讲渔。</p><p>##分析需求<br>一般来说，我们在封装组件的时候，会先思考以下几点</p><ul><li>这个组件要做什么</li><li>这个组件<strong>至少</strong>需要知道哪些信息</li><li>这个组件会反馈哪些信息</li></ul><p>这个阶段，我们还不会考虑组件的具体实现，仅仅对其做抽象。我们要做的东西不仅仅是适用于单个项目的，而应该是通用的，可以适应大部分同种类需求的。</p><p>####Scene I<br>BA说，客户要在首页加个轮播。于是半天后设计师出了张图，看起来大概像这样：</p><p><img src="/content/images/2015/11/-----1.jpg" alt=""> </p><p>我们按照上面的思路，拆分一下这个需求。</p><p>###这个组件要做什么<br>显而易见的：</p><blockquote><p>1.展示多张图片</p></blockquote><blockquote><p>2.可以向左向右翻页</p></blockquote><blockquote><p>3.PageControl的状态会根据图片的滚动而相应改变</p></blockquote><p>隐含可能要做的：</p><blockquote><p>1.支持左右两侧无限循环滚动</p></blockquote><blockquote><p>2.自动轮播</p></blockquote><blockquote><p>3.支持手动滑动</p></blockquote><blockquote><p>4.支持点击并进行相关的响应</p></blockquote><blockquote><p>5.图片的缓存</p></blockquote><p>###这个组件<strong>至少</strong>需要知道哪些信息<br>一个封装得优秀的复杂度不高组件就像一个魔法盒子，只需要触发启动开关，就可以达到你期待的效果。极简的触发参数和条件是组件封装的精髓。在内容型App中，轮播图一般会用作推荐内容展示区域。在O2O类App中，轮播图一般会用作广告位。因此轮播区域图片的内容绝大多数都是动态的。在一般的C/S开发中，客户端要获取存储在服务器上的图片会获取它的URL,然后在需要的时候根据URL异步地加载这些图片。因此，我们找出了的轮播空间第一个必备条件：</p><p><strong>一个图片URL地址数组。</strong></p><pre><code>@property (nonatomic, strong) NSArray *imageURLs;/**&lt; 必须赋值。只要给这个imageURL赋值，会自动获取图片*/</code></pre><p>这个时候我们已经可以根据数组内的URL,数组内URL的数量，完成轮播效果了。但还不够完善。试想，当数组为空的时候，我们的轮播控件是一个什么状态？网络比较慢，图片还在加载中的时候，我们的轮播控件是什么状态？就目前来说—-空白一片。</p><p>每个App都有每个App的设计，但无论如何谁也不会容忍首页最醒目的部分出现一大片空白，因此占位图是必须的。我们告诉我们的控件，“没有图片的时候别傻愣着，显示这张图”。必备条件二：</p><p><strong>占位图</strong></p><pre><code>@property (nonatomic, strong) UIImage *placeholder;/**&lt; 没有轮播图时的占位图*/</code></pre><p>有了以上信息我们的轮播控件已经可以在运行得比较好了。但是缺少了一定的定制性，能满足的需求面还不够广。比如说，让控件在需要自动轮播的地方自动轮播，在不需要自动轮播的地方保留无限滚动的特性，可以手动拨动？（之前有个产品提过这样的需求）比如说,这个控件是否应该提供可选的PageControl实现？依据设计师给的图不同，我们可能需要实现不同的PageControl，不管是颜色，布局，还是其可见隐藏都可能会有不同。这一部分复杂度不应该归到轮播控件中。但考虑到一些快速开发的需求,控件还是提供了一个默认选项。这些都是让控件变得更加可配置和灵活（同时也变得复杂）的可选信息。综上我们大概可以整理出以下属性：</p><pre><code>@property (nonatomic,getter=isAutoMoving)      BOOL autoMoving;/**&lt; 是否自动轮播,默认为NO*/@property (nonatomic,getter=isShowPageControl) BOOL showPageControl;/**&lt; 是否展示默认的PageControl，默认为YES*/</code></pre><p>###这个组件会反馈哪些信息<br>上一点中，如果使用者需要自己实现PageControl，那么当前控件滚动到哪一页了，应该给出反馈。</p><p>不论在O2O的App中，还是资讯类App中，用户点击轮播必定会有相对应的响应，例如之乎日报点击跳转到对应的文章，淘宝点击查看大图等。因此用户点击的信息也必须反馈出来，以让控制器根据用户的操作进行不同的响应。</p><p>View层对Controller层的反馈一般有两种，一种是Target-Action，一种是Delegate。此处我们类似UITableView,给出一定的代理方法。遵循苹果的设计规范，让使用的开发者容易上手。</p><pre><code>@protocol PSCarouselDelegate &lt;NSObject&gt;@optional/** *  告诉代理滚动到哪一页了 * *  @param carousel self *  @param page     已经计算好，直接使用即可 */- (void)carousel:(PSCarouselView *)carousel didMoveToPage:(NSUInteger)page;/** *   告诉代理用户点击了某一页 * *  @param carousel *  @param index  imageURL的index   */- (void)carousel:(PSCarouselView *)carousel didTouchPage:(NSUInteger)page;@end</code></pre><p>至此，轮播组件的架子已经明晰，剩下的就是如何实现，以及实现的时候需要考虑的一些细节。</p><p>##实现过程</p><p>###选择基类<br>苹果的UIKit提供了非常多优秀的类，可以作为我们轮播视图的基类。根据以上的分析，我们根据直觉，立马可以联想到以下三个类：<br><code>UIPageViewController</code>、<code>UIScrollView</code>、<code>UICollectionView</code>。</p><p><code>UIPageViewController</code>提供了非常好的翻页封装，仅需要指定翻页的方向，和子ViewController的数组，就可以提供类似轮播的功能。并且<code>UIPageViewController</code>提供了供翻页的接口和必要的反馈信息，定义在<code>UIPageViewControllerDelegate</code>协议中。用UIPageViewController,我们只需要将每个轮播页封装成一个仅包含一个UIImageView的ViewController，并将其设为UIPageViewController的ViewControllers，并实现它的代理方法就很容易实现我们的轮播图。</p><p><code>UIScrollView</code>提供了最基本的滚动封装。采用UIScrollView作为基类，需要自己根据图片的数量计算ContentSize,并在ScrollView相对应的代理方法中，根据Frame相关信息来计算页码，会比UIPageViewController稍微复杂。但好在，它是一个<code>View</code>。</p><p><code>UICollectionView</code>做为UIScrollView的子类提供了比UIScrollView更好的封装，也提供了”翻页”的接口，并提供了一系列定位CollectionView的状态信息。相比UIScrollView,他提供了更深层的封装。同UIPageViewController一样，非常适合本作为本组件的基类。同时，当UICollectionView的一些代理方法不足以提供相关信息时，还可以通过UIScrollView的代理方法来解决。</p><p>采用<code>UIPageViewController</code>作为子类，考虑到使用者需要将其作为subViewController添加到它们的项目中，没有将一个View添加到ViewController中来得直观，综合考虑，PSCarouselView选择了UICollectionView作为其基类。</p><p>###实现功能<br>如何利用UICollectionView在有限的图片数量下实现无限轮播？只需在原有图片数组头尾各新增一张图片就可以实现。如图</p><p><img src="/content/images/2015/11/----001.jpeg" alt=""></p><p>将imageURL数组中的URL,扩充为N+2。同时，将imageURLs的最后一个URL作为新数组的第一个URL,将imageURLs的第一个URL作为新数组的最后一个URL。然后在我们的CollectionView滚动到最后一个Cell时，跳转到第二个URL表示的IndexPath即可。自动轮播采用计时器来完成。在实现的时候，我们需要注意一下的几点</p><p>1.计时器的开启与暂停</p><p>自动轮播，通常我们会使用到计时器NSTimer。当我们在页面切换的过程中，需要注意计时器的开启与暂停，不然可能会出现一些不可预料的BUG。PSCarouselView 作为一个 <code>View</code> 是不可能也不应该知道一个 <code>ViewController</code> 的生命周期的。因此我们需要提供两个接口，供使用者开启/暂停计时器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startMoving;</span><br><span class="line">- (<span class="keyword">void</span>)stopMoving;</span><br></pre></td></tr></table></figure><p>另外，我们还需要注意App的生命周期，当App进入不活动的状态时，我们也需要将计时器暂停，并在回到活动状态时相应地启动。</p><pre><code>#pragma mark - Notification//程序被暂停的时候，应该停止计时器- (void)applicationWillResignActive{    [self stopMoving];}//程序从暂停状态回归的时候，重新启动计时器- (void)applicationDidBecomeActive{    if (self.isAutoMoving)    {        [self startMoving];    }}</code></pre><p>2.用户操作与自动轮播的冲突<br>用户操作时如果轮播还是继续滚动，会导致用户产生不可控的错觉。《iOS Human Interface Guide》中强调过App需要给于用户控制感。因此，在用户手动”翻页”的时候，我们需要暂时暂停一下自动轮播，并在用户手动”翻页”完成后，重新进行轮播。</p><pre><code>//用户手动拖拽，暂停一下自动轮播- (void)scrollViewWillBeginDragging:(UIScrollView     *)scrollView{    [self removeTimer];}//用户拖拽完成，恢复自动轮播（如果需要的话）- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{    if (self.isAutoMoving)    {        [self addTimer];    }}</code></pre><p>3.图片的缓存与展示<br>如何通过图片的URL来获得相对应的图片，并做好图片的缓存，以实现最大限度地节省流量？这个模块其实应该单独做一个有关图片缓存的库，而不应该包含到View层中来。本作采用了SDWebImage来实现这一功能。有兴趣的朋友可以尝试着实现一个图片缓存库。</p><p>以上，一个轮播组件的封装基本上完成了。更多实现上的细节请参看GitHub上的<a href="https://github.com/DeveloperPans/PSCarouselView" target="_blank" rel="noopener">Demo</a>。</p><p>That’s all.Hope you enjoy it :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天面试了一个应聘者，他的演示项目里有广告轮播功能。恰好之前我封装过一个实现了此功能的控件，于是就顺着他广告轮播的实现一直往下聊，从需求的抽象一直聊到各种实现的细节和需要考虑的问题等等。组件的封装是开发中比较有趣的一件事。今天我们就拿轮播控件举例，聊聊组件的封装。&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>漫谈iOS中的MVC</title>
    <link href="https://shengpan.net/2015/10/14/man-tan-ioszhong-de-mvc/"/>
    <id>https://shengpan.net/2015/10/14/man-tan-ioszhong-de-mvc/</id>
    <published>2015-10-14T06:58:31.000Z</published>
    <updated>2015-10-14T07:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>###前言</p><p>做过一段iOS开发的开发者们对MVC肯定不陌生。这是<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="noopener">Apple推荐</a>的开发iOS应用程序的标准设计模式。</p><p>我们从一张图开始，谈谈MVC。</p><p>###MVC<br><img src="/content/images/2015/10/MVC.png" alt=""><br>传统的MVC如上图。将不同的对象划分到三个阵营<code>Model</code>、<code>View</code>、<code>Controller</code>。View负责绘图、接收用户的交互，并将交互以<em>Blind</em>的方式传达到Controller。Controller则负责处理相对应的业务逻辑，并告诉Model更新数据。Model则负责更新数据，并将数据以Blind的方式交给View或者Controller。在传统的MVC中C同时知晓V和M两者的状态和所有信息。<strong>View也知晓Model的信息</strong>，但Model是不知道其他两者的任何信息的。</p><p>这种设计在JavaWeb的开发中被广泛使用。因为View层的页面布局，响应，由js和css完成，jsp此时可以直接拿Model解析数据。。在这种情况下，View和Controller的任务最重，Model更像是一个有数据查询功能的Entity。</p><p>###iOS中的MVC</p><p><img src="/content/images/2015/10/StandfordMVC.png" alt=""><br>iOS中的MVC和传统的MVC大同小异，小异的地方是对传统MVC的改进。</p><p>首先是<strong>View</strong>层。View依然负责着接收用户交互和图像的绘制，但是，<strong>View不再直接处理数据了</strong>。而是将数据相关的实现逻辑用协议的形式，交给其他对象（一般是ViewContorller），由这个对象告诉View，View应该如何展现。苹果的TableView、PickerView等View的设计很好地印证了这一点。此时View变成了纯粹的”View”，一个”Data Independent”的View，复用性无疑是非常高的。</p><p><strong>Model</strong>在iOS中也扮演着与Web开发中相同的角色。常常被开发者们误当成Entity使用。它负责持有数据，并且有少量的逻辑。在这样的设计下，Model其实是非常瘦的。</p><p>在iOS中，Model和View是相互分离的，既不相互拥有，也相互不交互，即时是以Blind的模式。当Model有所变化时，常常通过KVO或者Notification的方式通知Controller，而不是View。因此，即时有的时候View中会有Notification的监听者，但也绝对不会是Model发出的Notification的监听者。更何况是，我们在实际开发中，Controller有各种方式来告诉View，你应该显示什么，所以View与Model是可以绝对隔离开的。</p><p>最后是<strong>Controller</strong>。Controller在iOS中被命名为ViewController。从命名就可以看出Controller和View的关系非常密切，它直接拥有View，负责着View的创建，显示，隐藏等等。View的代理，数据源，用户交互的响应，也都由Controller负责。</p><p><code>Controller</code><strong>拥有</strong><code>View和Model</code>。知晓他们二者的一切情况，负责将Model的数据解释给View，负责根据View中的用户交互让Model处理数据并让View做出相对应的反馈。并且Controller也负责接收Model发出的Notification，在Model状态改变时，及时让View做出相对应的变化。</p><p>Controller在iOS开发中扮演了重量级的角色。的在实际的开发过程中，有80%的时间是在ViewController上面做文章。这也直接导致了一些问题…</p><p>###臃肿的Controller</p><p>在以上的MVC中，Model其实大多和业务相关，所以Apple的API设计并没有对这一层有所体现。Apple将诸如<code>didReceiveMemoryWarning</code>的方法都放在了ViewController里面，这让我们有种ViewController什么都可以干的直觉。<br>生命周期管理、依照View的需求将数据格式化，View的初始化及组织,各种Delegate，界面的跳转等等都在Controller中完成。</p><p>正是由于Controller扮演了太过重要的角色。导致Controller在编程过程中变得越来越臃肿。其中的代码动辄上千行。有些其他模块也需要的可以复用的代码只能通过复制黏贴的方式。一旦业务和需求有所修改，就得在混合了各种逻辑的Controller的一堆代码中上下翻找。这对像我一样喜欢偷懒的开发者来说就是噩梦。</p><p>###网络请求放哪儿<br>在以上的MVC分类中，并没有涉及到网络请求。而网络请求几乎是每一个App必须的。那么，网络请求应该归类到哪边？稍微思考一下，觉得放在Model里会不错。但是网络请求是异步的，如果网络请求还没返回，Model的生命周期却结束了，那可不是一件好事。当然，肯定不会把请求放在View里…所以，最后网络请求还是放到了Controller中。在与我共事的许多有经验的iOS开发者都是这么选择的。但是，这又加剧了Controller的臃肿。</p><p>###为Contrller瘦身<br>So，怎么样优化这一结构呢。首先想到的是，把网络请求先移出来。如果解决了Model的生命周期和网络请求的生命周期问题，网络请求相关的代码就可以放在Model里。前面把网络请求放在ViewController里，那么只要保持Model和ViewController的生命周期一致，就可以将网络请求移动到Model里了。</p><p><strong>Bingo，让Model成为ViewController的一个Strong属性。</strong></p><pre><code>@interface ShopListController ()@property (strong, nonatomic) ShopListModel *model;@end</code></pre><p>这个时候Model里可以尽情访问网络请求了。因为Model和ViewController生命周期一直，也不必再担心网络请求着陆点丢失的问题。</p><pre><code>@interface ShopListModel : BaseModel- (void)fetchShopListData;@end</code></pre><p>那么数据的存储和格式化也自然而然地在Model中处理了。同时我们还可以把数据持久化，一些类似于验证用户输入等等与UI不相关的数据处理和计算，都可以放在Model里。</p><pre><code>@interface ShopListModel : BaseModel@property (strong, nonatomic) NSMutableArray *dataSource;- (void)fetchShopListData;@end</code></pre><p>最后我们在model中网络请求完成的回调里，处理好相关数据整理成包含UI直接可用对象的DataSource，并发送相对应的Notification来通知ViewController对View进行更新。</p><p>Model实现：</p><pre><code>@implementation ShopListModel- (void)fetchShopListData{    ...    ...    [[NSNotificationCenter defaultCenter] postNotificationName:FETCH_SHOP_LIST_DATA_NOTIFICATION object:nil];    ...    ...}</code></pre><p>ViewController实现：</p><pre><code>- (void)viewDidLoad{    [super viewDidLoad];    [[NSNotificationCenter defaultCenter] addObserver:self                                             selector:@selector(didReceiveModelNotification:)                                                 name:FETCH_SHOP_LIST_DATA_NOTIFICATION                                               object:nil];}- (void)didReceiveModelNotification:(NSNotification *)notification{    if ([notification.name isEqualToString:FETCH_SHOP_LIST_DATA_NOTIFICATION])    {        [self.tableView reloadData];        return;    }}</code></pre><p>此时我们得到了一个功能丰富的且易于复用的Model。如果别的界面也需要相同的数据，我们只需要将这个Model给另一个Controller使用，并注册相对应的Notification监听即可。</p><p>###MVC进化版——MVCE<br>其实我们做的这一系列事情，无非是不断地将代码分离。力求做到一种”原子性”。最终最求的目标就是更高的可维护性、可拓展性和复用性。以这种思维反观上面的MVC，Controller已经变得相对较瘦，但随之而来的是Model又胖了起来。</p><p>于是就有人提出了<strong>MVCS</strong>的模式。<strong>S</strong>即<strong>Store</strong>。将网络请求与数据持久化相关的操作，分到Store模块中去。</p><p>借鉴微软的<strong>MVVM</strong>，应用到iOS中的<strong>ReactiveCocoa</strong>，考虑到View与Controller的紧密联系，将View和ViewController直接划分为View。开辟出一个ViewModel来解决上述问题。在MVVM里，你可以把输入验证，网络请求，数据持久化都放在ViewModel里，Model仍然是Model，不与View直接交互。</p><p>其实以上的设计模式，都脱不开MVC的影子，只是在实践中不断借鉴，不断优化。包括我想到的这些解决方案。在了解过MVVM设计模式后，这套解决方案还真颇有点MVVM的味道。在我的解决方案里，Model差不多等于MVVM中的ViewModel，而MVVM中的Model在这边等同于Entity。嗯。。于是我打算给它取个名字叫——MVCE。哈哈。。开个玩笑。（为了下文方便，暂且称为MVCE）。</p><p>###留下的思考<br>设计模式这么多，该如何选择？</p><p>在实战中，不一定非要抓住某个模式不放，更重要的是理解模式背后的意义，并且灵活运用。比如说在MVCE中，ViewController中还剩下什么呢？生命周期，Delegate，界面跳转，Notification响应。有这么一种情况：</p><pre><code>有时候有几个TableView高度相似，想要复用之前ViewController中的代理。一般来说，我们复制黏贴相关代理方法到另一个ViewController中，并稍微修改一下不同的地方。</code></pre><p>以上情况其实可以抽象出一个Adapter，专门放TableView的代理，这样在ViewController中，只需要Import这个Adapter，稍微修改Adapter的一些属性，而不需要一遍遍地复制黏贴代理代码。</p><p>当然，这样做的后果，牺牲了少部分原有代理的灵活性——我们可以在ViewController中任意定义TableView，切我们的代码中又多出了一个Adapter类。但好处是，封装性更好了，复用性更好了。</p><p>##最后<br>返璞归真，所有的设计模式，都是为了更好地解决问题存在的。每个系统有每个系统固有的复杂度，当设计模式将其细分到一定程度，所做的事情只不过是将复杂度的位置挪了挪。所以，我们要了解设计模式，更要在合理的地方，合理地利用设计模式。诸如App中的关于页面，信息量少，逻辑少。所有逻辑直接放在ViewController里，也不会超过100行代码，那就放吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###前言&lt;/p&gt;
&lt;p&gt;做过一段iOS开发的开发者们对MVC肯定不陌生。这是&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS项目架构 - 统一行为</title>
    <link href="https://shengpan.net/2015/10/14/basevc/"/>
    <id>https://shengpan.net/2015/10/14/basevc/</id>
    <published>2015-10-14T06:55:43.000Z</published>
    <updated>2015-10-14T06:58:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>“我们虽然在构造软件，但软件也会重新塑造我们”。在写<a href="http://shengpan.coding.io/architecture-module/" target="_blank" rel="noopener">iOS项目架构-模块化</a>的时候，我仍然觉得我所构建的统一行为方式还算不错，可以写出来与大家探讨探讨。昨日将应用发布的闲暇之余阅读了<a href="http://objccn.io/issue-13-4/" target="_blank" rel="noopener">objc中国的这篇文章</a>，令我明白尚有更优的解决方案。本文从实际的例子出发，发表一下我的拙见，用以和上文做对照，权当抛砖引玉。</p><p>###BaseViewController</p><p>####例子1<br>我们在构建一个App的时候，会有许多相同的行为。例如，任何需要网络请求的界面，总会需要一个indicator来告诉用户，“噢，我正在操作，请等我一下”。或者某个时候我们需要给用户一点小提示，来对他们的操作进行反馈等等。每一个ViewController都会有这样的行为。这是我们很直接地想到<strong>我们需要一个父类</strong>。</p><p>于是我们新建一个基类，<code>BaseViewController</code>继承于<code>UIViewController</code></p><pre><code>@interface BaseViewController : UIViewController/** *  a little pop window used to replace laertView * *  @param tips tips will show to user */- (void)showTips:(NSString *)tips;/** *  When some operation need user waiting,use this method to show a HDU. * *  @param title will show to user */- (void)showIndicatorWithTitle:(NSString *)title;- (void)hideIndicator;@end</code></pre><p>好了，现在我们所有的业务相关ViewController都继承自BaseViewController，并且在调用网络请求前轻松地写一句<code>[self showIndicatorWithTitle:@&quot;加载中...&quot;]</code>，并且在网络请求完成后的回调里写下<code>[self hideIndicator]</code>就可以轻松地完成指示器的显示隐藏了。感谢我们的继承！</p><p>####例子2<br>再举个例子。在我的项目里访问服务器的时候需要Token，Token在某些情况下有可能过期。Token过期的时候会返回一个Token过期的状态码，此时需要用户重新登录。这个情况我们可以总结成：</p><ul><li>绝大多数ViewController都会发送网络请求</li><li>每一个网络请求都会返回Token过期</li><li>每个ViewController都需要处理Token过期的情况</li></ul><p>因此我们可以将这一行为抽取出来，写在BaseViewController中。这样只需要在各个业务模块的的Model层收到Token过期消息的时候，用Notification转发给BaseViewController就可以了。其他诸如网络请求失败等情况都是如此。</p><p>每个项目有不同的统一行为，我们需要根据不同的行为抽取不同的基类。</p><p>###使用协议<br>但是有一种情况。例如<code>LoginViewController</code>需要和<code>BaseViewController</code>一样的显示/隐藏Indicator的接口，但却没有其他相同的行为。这时继承就显得不太合适了。</p><p>想象一下<code>BaseViewController</code>因为Token过期Present了<code>LoginViewController</code>,而<code>LoginViewController</code>因为继承了<code>BaseViewController</code>又不停地Present另一个<code>LoginViewController</code>…这时候如果使用继承的话，就不得不写一些脏代码来避免这样的情况。</p><p>正如那篇文章所说，此时我们可以用协议<code>@protocol</code>来替代继承。</p><pre><code>@protocol PSIndicator &lt;NSObject&gt;- (void)showTips:(NSString *)tips;- (void)showIndicatorWithTitle:(NSString *)title;- (void)hideIndicator;@end</code></pre><p>然后在<code>LoginViewController</code>中：</p><pre><code>@interface LoginViewController : UIViewController&lt;PSIndicator&gt;@end</code></pre><p>###最后<br>如果你在读这篇文章的时候想到，网络请求相关的内容为什么不直接封装在网络操作相关的模块，由它来负责指示器的显示和隐藏。这样还能省去手动调用的麻烦。关于这一点，在<a href="http://shengpan.coding.io/architecture-module/" target="_blank" rel="noopener">这篇文章</a>里已经做了讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“我们虽然在构造软件，但软件也会重新塑造我们”。在写&lt;a href=&quot;http://shengpan.coding.io/architecture-module/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS项目架构-模块化&lt;/a&gt;的时候，我仍然觉
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS项目架构 - 规范</title>
    <link href="https://shengpan.net/2015/10/14/standard/"/>
    <id>https://shengpan.net/2015/10/14/standard/</id>
    <published>2015-10-14T06:51:46.000Z</published>
    <updated>2015-10-14T06:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得刚工作的时候，我的Mentor带我参加某银行业务系统研发成果交流分享会。会议让我印象很深的一点，是关于规范。发言人在说规范的时候，举了他见过的这么一个例子：</p><pre><code>&lt;div class=&quot;div1&quot; ...&gt;  &lt;div class=&quot;div2&quot; ...&gt;    &lt;div class=&quot;div3&quot; ...&gt;     ...    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>“只有鬼才知道他的div1是什么！”</p><p>没有规范的代码，增加了代码的阅读成本，也因此大大降低了团队合作的效率。当产品上线后，出了BUG需要修复，而负责维护的却不是当初的开发团队，这是看混乱的代码成了一个噩梦。我们不只一次地听别的程序猿哀嚎过：“嗷，又要看别人的代码”。不规范的代码也是一方面的成因。</p><p>为了提高生产效率，同时也是本着对自己产出的代码，以及对他人负责的理念，在公司内部（如果客观条件做不到，至少在团队内部）需要践行代码的规范。一般来说，各司有各司的代码规范，基本的代码规范在此就不赘述了。然而，有一些<strong>原则</strong>是通用的，在此略作梳理：</p><p><strong>1. 首先是为人编写程序，其次才是计算机。</strong><br>软件的生命周期贯穿产品的开发，测试，生产，用户使用，版本升级和后期维护等过程，只有易读，易维护的软件代码才具有生命力。</p><p><strong>2. 保持代码的简明清晰，避免过分的编程技巧。</strong><br>简单是最美。不要过分追求技巧，否则会降低程序的可读性。</p><p><strong>3. 编程时首先达到正确性，其次考虑效率。</strong><br>编程首先考虑的是满足正确性，健壮性，可维护性，可移植性等质量因素。</p><p><strong>4. 编写代码时需要考虑到代码的可测试性。</strong><br>不可以测试的代码是无法保障质量的。实现设计功能的同时，要提供可以测试、验证的方法。</p><p><strong>5. 函数（方法）是为一特定功能而编写，不是万能工具箱。</strong><br>方法是一个处理单元，是由特定功能的，所以应该很好地规划方法，不能是所有东西都放在一个方法里实现</p><p><strong>6. 鼓励多注释。</strong></p><p>###一些较为实用的iOS规范小Tips<br>在项目实战中，我总结出了一些比较实用的小点，在此分享一下，希望对大家有所帮助。</p><p><strong>1.所创建项目的文件夹目录结构和Xcode中的虚拟Group文件夹的结构须一致，便于代码文件的维护。</strong></p><p>规范的文件目录结构如下：</p><p><img src="/content/images/2015/10/standard-floder.jpg" alt="文件夹结构"></p><p>推荐划分文件夹的时候按功能模块划分，便于修改BUG的时候寻找。</p><p>不规范的文件夹目录结构如下：</p><p><img src="/content/images/2015/10/floder.jpg" alt="不规范的文件夹结构"></p><p>资源文件、源码文件、第三方库全部混合放置，每个文件引用次数未知，稍微移动便会造成引用错误编译失败，都是因为文件夹目录结构不规范T T。</p><p><strong>2. 胖Model瘦Controller。</strong></p><p>大部分业务逻辑放在Model中做，Controller只负责Model和View的调配。Model和View不可直接沟通。Model-&gt;Controller，使用NSNotification传递消息。View-&gt;Controller采用Targt-action或者Delegate传递消息。<em>ViewController终于从上千行代码的困境中解放出来了！</em> </p><p><strong>这条规范</strong>的<strong>为什么</strong>我们会在MVC的文章中详细讨论。</p><p><strong>3.标注方法块</strong></p><p>同类方法写在一起，并用<code>#pragma mark</code>做标注。一个.m文件的方法至上而下应该是这样的：</p><pre><code>#pragma mark - Life cycle- (void)viewDidLoad {...}- (void)viewWillAppear:(BOOL)animated {...}#pragma mark - Private Method-(void)setContentofScrollView {...}#pragma mark - Notification- (void)userDidLogin:(NSNotification *)notification {...}- (void)mainViewPicsDownloaded:(NSNotification *)notification {...}#pragma mark - UIScrollViewDelegate- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {...}- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {...}#pragma mark - Navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {...}#pragma mark - Getter and Setter- (MainViewModel *)model{...}</code></pre><p>在标注<code>Delegate</code>的时候，把Delegate名称直接做作为标注，比如<code>UITableViewDelegate</code>,<code>UITableViewDataSource</code>。这样的好处是，当这个Delegate是自定义的时候，别人在看代码的时候可以直接<em>command+左键</em>点击跳转到Delegate，便于他人阅读和寻找自定的Delegate。</p><p>Getter 和 Setter放在最后。</p><p>另外，尽可能地减少Controller中的私有方法。私有方法大多可以在Model中实现。</p><p><strong>4.所有属性都使用Getter and Setter</strong></p><p>不要在<code>viewDidLoad</code>里面初始化view然后再add，这样代码就很难看。在<code>viewDidload</code>里面只做<code>addSubview</code>的事情，然后在<code>viewWillAppear</code>里面做布局的事情，<del>最后在<code>viewDidAppear</code>里面做<code>Notification</code>的监听之类的事情</del><em>监听也同时放在<code>ViewWillAppear</code>中，在某些特殊的情况下，在<code>ViewDidAppear</code>中注册的监听会导致无法<code>removeObserver</code></em>。至于属性的初始化，则交给getter去做。</p><p>不要：</p><pre><code>- (void)viewDidLoad{   [super viewDidLoad];   self.textLabel = [[UILabel alloc] init];   self.textLabel.textColor = [UIColor blackColor];   self.textLabel ... ...   self.textLabel ... ...   self.textLabel ... ...   [self.view addSubview:self.textLabel];}</code></pre><p>而是：</p><pre><code>- (UILabel *)textLabel{    if (!_textLabel)    {        _textLabel = [[UILabel alloc] init];        _textLabel.textColor = [UIColor blackColor];        _textLabel ... ...        _textLabel ... ...        _textLabel ... ...    }    return _textLabel;}</code></pre><p><strong>5.注释你的公有方法</strong></p><p>使用<a href="https://github.com/onevcat/VVDocumenter-Xcode/archive/master.zip" target="_blank" rel="noopener">这个工具</a>规范注释.h头文件中的属性和方法。十分直白的方法和属性可以不注释。</p><p>That’s all.Hope u enjoy it. : )</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记得刚工作的时候，我的Mentor带我参加某银行业务系统研发成果交流分享会。会议让我印象很深的一点，是关于规范。发言人在说规范的时候，举了他见过的这么一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;div1&amp;quot; ...&amp;gt;
  
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS项目架构 - 模块化</title>
    <link href="https://shengpan.net/2015/10/14/module/"/>
    <id>https://shengpan.net/2015/10/14/module/</id>
    <published>2015-10-14T06:49:30.000Z</published>
    <updated>2015-10-14T06:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>###当我们谈论iOS架构的时候我们在谈论什么</p><ol><li>模块化</li><li>规范化</li><li>统一行为</li></ol><p>本文主要就以上模块化，以网络请求模块的抽取为例稍作讨论。</p><p>###模块化<br>模块化的目的是实现解耦，提升模块、组件的复用性。一个很简单的例子，App需要与服务器交换数据，最差的做法，是把网络请求、回调、业务处理、界面操作全部写在<code>ViewController</code>里。如果把网络请求抽取出来，建一个<code>Webservice</code>类，仅负责最基本的RESTful请求，并在回调中处理好类似404，无网络等各种网络状况。那么，这个类就变成了通用的网络服务处理模块，便于维护和复用。</p><p>###遇到的问题<br>在划分模块的一个前提是，模块不要对其他层有依赖性。最好的情况是，这个模块拿到任意一个项目都可以直接使用。在这一点上，我遇到了一个值得思考的问题。</p><p>在iOS客户端里，网络请求可以分为两种，一种是<strong>静默请求</strong>,也就是在用户不知情的情况下默默地进行网络请求处理。典型的例子有微信朋友圈点赞。用户在点赞时，UI直接进行点赞成功的反馈，同时网络请求在静默进行，不阻碍用户的正常操作。另一种是<strong>显示请求</strong>，用户需等待操作完成后才能进行下一步操作。典型的例子一种是下拉刷新，另一种是支付宝付款。付款的请求中，UI暂时显示一个Loading图标，用以提示用户程序正在处理，而非卡死（设计思想：<strong>反馈</strong> ——<a href="http://zhuanlan.zhihu.com/langqixu/19675089" target="_blank" rel="noopener">《iOS Human Interface Guidelines》</a>）。</p><p>遇到的选择，是在第二种<strong>显示请求</strong>的情况下如何更好地封装。我所负责的这个项目，除网络请求外，并没有耗时很长的I/O等情况需要处理。因此，有两个方案。</p><p>将UI的Loading封装在WebService中，仅暴露<code>isShowIndicator</code>和<code>toView</code>两个参数在网络请求的接口中</p><pre><code>- (void)requestWithPath:(NSString *)path             parameters:(id)parameters        isShowIndicator:(BOOL) isShowIndicator                  toView:(UIView *)toView               labelText:(NSString *)labelText                 success:(SuccessBlock)success                 failure:(FailureBlock)failure;</code></pre><p>或者，将UI的Loading封装在BaseViewController中，作为一个ViewController的基础行为，相应的业务模块需要显示请求时，调用显示指示器方法。</p><pre><code>@interface BaseViewController : UIViewController- (void)showTips:(NSString *)tips;- (void)showIndicatorWithTitle:(NSString *)title;- (void)hideIndicator;@end</code></pre><p>前一种方式在写具体的业务逻辑时非常方便。只需要在调用前考虑一下这个请求是否为静默请求，然后将<code>BOOL</code>和<code>View</code>参数传入此方法中即可。这样封装的==好处==是，可以在网络层的回调中，处理好指示器的隐藏，以免出现忘记调用Hide方法的情况，并且<code>ViewController</code>不必因为需要这两个方法，就继承<code>BaseViewController</code> 。==缺点==是不够灵活，如果有不同的业务需要处理不同的显示，隐藏方式，还是需要在<code>ViewController</code>中重新写一下。</p><p>后一种方式在写具体的业务时==缺点==是略微麻烦一些，需要考虑好相对应业务具体情况，具体调用显示隐藏指示器，优点是灵活，<strong>并且做到了网络层的去UI依赖</strong>。</p><p>就MVC模式来说，<code>UI</code>响应数据的处理，应当由<code>Controller</code>负责调度。苹果自己在设计的时候，也都遵循了这一设计模式。<code>WebService</code>层，可以算作<code>Model</code>层的一个工具。而<code>Model</code>层与<code>View</code>层，在iOS的设计上是<strong>绝对不允许直接交互</strong>的。引用一张斯坦福大学iOS7公开课上的图来形象地展示一下。<br><img src="/content/images/2015/10/stanford.png" alt=""></p><p>Model和View之间是双黄线，就像开车一样，绝对不能压过双黄线 ：）至于为什么，我们以后讨论到MVC设计模式再详细讨论。</p><p>因此，在WebService中封装了View，实际上是在Model层操作View。多了这么一个View，多出来的事可就多了。我们不仅需要Import进UIKit，还需要Import通用的Indicator。这一依赖就产生了模块之间的依赖，原本为了解耦合而提取的WebService层反而耦合了Indicator。同时，也造成Webservice的粒度增大。需要处理的事情变得更多。</p><p>反观第二种方法，需要所有ViewController继承BaseViewController。继承本身是紧耦合的。然而纵向的紧耦合有时候减少了重复工作，将一些相同的行为，做统一化的处理，并且没有造成横向跨层的依赖。类似于无网络时的处理，网络请求出错时的处理，Token过期的处理，都应该放在BaseViewController里面。因为这是所有Controller都需要面对的问题。因此，继承BaseViewController是必要的。在统一行为之余，把这几个方法封装在BaseViewController中，又让WebService层实现了细颗粒的模块化组件化。同时，Controller本身就需要控制View，不会因此Import进许多不相关的模块。所需要付出的仅仅是在网络请求结束的时候别忘记调用Hide方法，不然测试小妹的“界面失去响应”BUG就会指派到我们头上 ：（</p><p>最终，我们的Webservice是封装成这样的：</p><pre><code>/** *  post a request to server * *  @param path       the request path append at BASEURL *  @param parameters parameters *  @param token      Authorization token *  @param success    when success goto this block *  @param failure    when failure goto this block */    - (void)postWithPath:(NSString *)path     parameters:(NSDictionary *)parameters          token:(NSString *)token        success:(void (^)(id JSON))success        failure:(void (^)(NSError *error, id JSON))failure;</code></pre><p>综上所述，模块化所需要遵循的思想就是：轻，少，专。其实思想和我们写方法的时候考虑的“一个方法只做一件事”有类似的地方。</p><p>That’s all，hope you enjoy it ：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###当我们谈论iOS架构的时候我们在谈论什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;规范化&lt;/li&gt;
&lt;li&gt;统一行为&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文主要就以上模块化，以网络请求模块的抽取为例稍作讨论。&lt;/p&gt;
&lt;p&gt;###模块化&lt;br&gt;模块化的目的是实现
      
    
    </summary>
    
    
  </entry>
  
</feed>
