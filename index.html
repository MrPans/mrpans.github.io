<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>PPPan&#39;s 平凡之路</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="PPPan&apos;s 平凡之路 一个技术博客覆盖范围包括 iOS Objecticve-C Swift Xcode 等">
<meta property="og:type" content="website">
<meta property="og:title" content="PPPan&#39;s 平凡之路">
<meta property="og:url" content="https://shengpan.net/index.html">
<meta property="og:site_name" content="PPPan&#39;s 平凡之路">
<meta property="og:description" content="PPPan&apos;s 平凡之路 一个技术博客覆盖范围包括 iOS Objecticve-C Swift Xcode 等">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PPPan&#39;s 平凡之路">
<meta name="twitter:description" content="PPPan&apos;s 平凡之路 一个技术博客覆盖范围包括 iOS Objecticve-C Swift Xcode 等">
  
    <link rel="alternate" href="/atom.xml" title="PPPan&#39;s 平凡之路" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">PPPan&#39;s 平凡之路</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="index.html" id="subtitle">做一个互联网内容的贡献者</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shengpan.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-https" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/10/07/https/" class="article-date">
  <time datetime="2016-10-07T06:32:00.000Z" itemprop="datePublished">2016-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/10/07/https/">全站 HTTPS 边做边记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>没错，这是一篇可以 Step by Step 跟着做的操作指南。</p>
<p>keyword: <strong>Let’s Encrypt</strong>, <strong>Ubuntu 14.04</strong>, <strong>Nginx</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 HTTPS 可以先看看鹅厂的<a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=402615812&amp;idx=1&amp;sn=b6dae639119bb66e7025321254b8d973&amp;scene=1&amp;srcid=122439MA3l7gRwfjgNOB76pA#rd" target="_blank" rel="noopener">这篇文章</a>涨涨姿势。</p>
<p>我们知道 HTTPS 需要一个 CA 来解决信息抵赖和中间人攻击的隐患。<strong>Let’s Encrypt</strong> 就是一个 CA。它的优势在于免费、被绝大多数浏览器认可、高度自动化。这么好的一个 CA 摆在这里，还多说什么呢，开搞。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>操作系统: Ubuntu 14.04</li>
<li>代理服务器: Nginx</li>
<li>权限: 拥有 Shell 权限</li>
</ul>
<h2 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h2><p>我们采用官方推荐的自动化工具 <a href="https://certbot.eff.org" target="_blank" rel="noopener">Certbot</a>来进行全自动化的申请。</p>
<p>首先下载 Certbot, 并修改相关权限.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>
<p>下载完成后，先关闭 Nginx 服务。因为我们将采用独立模式来安装证书。在独立模式下，certbot-auto 需要占用 80 端口，因此我们需要先暂时关闭 Nginx 来释放 80 端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx stop</span><br></pre></td></tr></table></figure>
<p>运行 certbot-auto 命令申请证书</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./path/to/certbot-auto certonly --standalone -d example.com -d www.example.com</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 后面的参数是你需要用 HTTPS 访问的域名。这里不支持通配符，所以子域名比较多的同学得费力都填满了。</p>
<p>运行过程中，会弹出窗口让你填写邮箱。Let’s Encrypt 的证书的有效期是 90 天。在证书过期后，他们会往这个邮箱发送提醒。</p>
<p>填完邮箱并接收用户协议后，就会进入如下界面。这说明开始申请并下载证书了。</p>
<p><img src="/content/images/2016/10/get-cer.png" alt=""></p>
<p>稍等片刻，如果出现以下提示，则表示证书申请成功了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at</span><br><span class="line">   /etc/letsencrypt/live/shengpan.net/fullchain.pem. Your cert will</span><br><span class="line">   expire on 2017-01-05. To obtain a new or tweaked version of this</span><br><span class="line">   certificate <span class="keyword">in</span> the future, simply run certbot-auto again. To</span><br><span class="line">   non-interactively renew *all* of your certificates, run</span><br><span class="line">   <span class="string">"certbot-auto renew"</span></span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let<span class="string">'s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">   Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure>
<p>你可以在上述信息中找到证书存放的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/letsencrypt/live/shengpan.net/fullchain.pem</span><br></pre></td></tr></table></figure>
<p>这在后面的 Nginx 配置中会用到。</p>
<h2 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h2><p>找到 Nginx 的配置文件，添加 ssl 配置。以我的 Ghost 博客为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">	listen 443 ssl;</span><br><span class="line">    server_name shengpan.net; </span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/shengpan.net/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/shengpan.net/privkey.pem;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_ciphers AES256+EECDH:AES256+EDH:!aNULL;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header   Host      $http_host;</span><br><span class="line">        proxy_pass         http://127.0.0.1:2368;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>server_name</code> 改为你的域名，<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 分别改为你的公私钥路径。</p>
<h4 id="兼容-HTTP"><a href="#兼容-HTTP" class="headerlink" title="兼容 HTTP"></a>兼容 HTTP</h4><p>有可能你的网站在启用 HTTPS 之前已经在某些地方留下过 HTTP 的链接了，而你又不希望这些链接失效，就需要做一些兼容。</p>
<p>如果你希望全站都使用 HTTPS 访问，只需要把 HTTP 请求重定向到 HTTPS 上即可。在 Nginx 配置文件中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name shengpan.net; </span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你希望用户可以同时使用 HTTPS 和 HTTP 访问，只需要在配置文件中简单地添加一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen 443 ssl;</span><br><span class="line">listen 80; # 添加这一行即可</span><br><span class="line">server_name shengpan.net;</span><br></pre></td></tr></table></figure>
<p>最后我们重启一下 Nginx 服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure>
<p>在浏览器中输入你的域名看看吧！</p>
<h2 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h2><p>Let’s Encrypt 颁发的证书只有 90 天的有效期，过了有效期需要续期。幸运的是 Cerbot 已经帮我们打理好了这一切，只需要一句命令行就可以为你的证书续期。</p>
<blockquote>
<p>To non-interactively renew <em>all</em> of your certificates, run “certbot-auto renew”</p>
</blockquote>
<p>当然，这句命令行还可以交给计划任务去做，以自动续期。Linux 下我们使用 Cron 实现这一功能。</p>
<h4 id="启动-cron-服务"><a href="#启动-cron-服务" class="headerlink" title="启动 cron 服务"></a>启动 cron 服务</h4><p>通常 ubuntu 下自带 cron，如果没有也可以通过以下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install cron</span><br></pre></td></tr></table></figure>
<p>若已经安装，输入以下命令判断 cron 服务是否启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pgrep cron</span><br></pre></td></tr></table></figure>
<p>如果有 pid （一串数字）输出则说明 cron 服务已经启动，没有任何输出说明需要手动启动 cron 服务。<br>启动 cron 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service cron start</span><br></pre></td></tr></table></figure>
<h4 id="编写需要运行的脚本"><a href="#编写需要运行的脚本" class="headerlink" title="编写需要运行的脚本"></a>编写需要运行的脚本</h4><p>首先新建一个脚本文件，为了方便识别，我们命名为 <code>refetch-https-cer.sh</code>，并保存到 <code>/etc/cron.weekly/</code> 路径下。如果没有该路径则最新建。</p>
<p>在 <code>refetch-https-cer.sh</code> 中填入如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/usr/bin/service nginx stop</span><br><span class="line">/root/certbot-auto renew</span><br><span class="line">/usr/bin/service nginx start</span><br></pre></td></tr></table></figure>
<p><code>#!/bin/bash</code> 开头说明该文件是一个 shell 脚本。 下面就是需要执行的命令。这里我们只要三步就能完成 https 证书的更新:</p>
<ol>
<li>关闭占用80端口的 nginx 服务（因为我们用 <code>standalone</code> 模式来使用 <code>cerbot-auto</code>)</li>
<li>用 certbot 来为证书续期</li>
<li>重启 HTTP 代理服务器，来使新的 https 证书生效。</li>
</ol>
<p>需要注意的是，文件里需要写全命令路径，因为 cron 执行的时候，可能没有 PATH 的环境变量。我的 certbot 命令放在 root 文件夹下，因此是 <code>/root/certbot-auto renew</code>，你需要将其替换为你的 certbot 命令路径。</p>
<p>最后我们需要修改一下改脚本文件的权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 777 /etc/cron.quarterly/refetch-https-cer.sh</span><br></pre></td></tr></table></figure>
<h4 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h4><p>cron 是以载入配置文件的方式来运行计划任务的。因此，只需要编写好配置文件并将其提交到 cron 服务中，它就会按照配置定期运行相关任务。</p>
<p>我们新建一个配置文件，命名为 rootcron , 保存到 <code>/var/spool/cron/</code>。该路径是所有用户 cron 文件存放的目录。</p>
<p>编辑 rootcron 文件，添加如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># refetch https certificate per week</span><br><span class="line"># minute hour day month week command</span><br><span class="line">0 3 * * 2 /etc/cron.weekly/refetch-https-cer.sh &gt;&gt; /root/for_crontab/error.log</span><br></pre></td></tr></table></figure>
<p>这个配置文件的意思就是，在每周二的凌晨 3 点，执行我们先前编写的用来自动续期的脚本，并将错误日志输出到 <code>/root/for_crontab/error.log</code> 文件中。</p>
<p>你可以自定义log文件的路径，但要保证在编写这个配置文件之前，已经把 log 文件创建好了。这样你可以偶尔上来看看日志文件，确保计划任务正常运行。</p>
<p>你也可以根据自己证书的过期时间，自定义任务的计划时间。想要知道如何自定义自己的配置文件，请看<a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="noopener">这里</a>。</p>
<p>最后，我们将该配置文件提交到 cron 服务中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab /var/spool/cron/rootcron</span><br></pre></td></tr></table></figure>
<p>检查一下是否已经成功将计划任务提交了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure>
<p>如果出现下面的提示，则说明已经成功提交了。自此，cron 会帮你打理好证书续期的事。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line"><span class="comment"># refetch https certificate per week</span></span><br><span class="line"><span class="comment"># minute hour day month week command</span></span><br><span class="line">0 3 * * 2 /etc/cron.weekly/refetch-https-cer.sh &gt;&gt; /root/for_crontab/error.log</span><br></pre></td></tr></table></figure>
<p>Have fun ：）</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://letsencrypt.org/getting-started/" target="_blank" rel="noopener">Let’s Encrypt Getting Start</a></li>
<li><a href="https://certbot.eff.org/#ubuntutrusty-nginx" target="_blank" rel="noopener">Certbot</a></li>
<li><a href="http://www.jianshu.com/p/eaac0d082ba2" target="_blank" rel="noopener">Let’s Encrypt SSL证书配置</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="noopener">每天一个linux命令（50）：crontab命令</a></li>
<li><a href="http://outprog.github.io/blog/2015/10/15/ubuntu-14-dot-04-shi-yong-cron-shi-xian-ji-hua-ren-wu/" target="_blank" rel="noopener">Ubuntu 14.04 使用 Cron 实现计划任务</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/10/07/https/" data-id="cjpgo3o9y000dfzo0aydthxv5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-auto-code-review" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/09/14/auto-code-review/" class="article-date">
  <time datetime="2016-09-13T21:16:55.000Z" itemprop="datePublished">2016-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/09/14/auto-code-review/">iOS 持续集成系列 - 自动化 Code Review</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="/ios-ci-index/">iOS 持续集成 - 开篇</a></li>
<li><a href="#">iOS 持续集成 - 自动化 Code Review</a></li>
<li>[iOS 持续集成 - 自动化单元测试]</li>
<li>[iOS 持续集成 - 自动化打包与分发]</li>
</ul>
<p>为了保证代码质量，Code Review 是非常重要的一环。细到<code>*</code>的位置是否正确，大到代码的结构是否符合了软件开发的一些基本原则，都在这项工作的范围内。</p>
<p>受限于现实情况，大多数团队没有足够的时间进行 Code Review，那么只能把一部分 CR 工作交给计算机去完成了。我们只需要定下合理的流程，用代码告诉计算机需要做什么，剩下的就交给我们可靠的伙伴吧。</p>
<p>应用了自动化 Code Review 后，如果你的代码写得不好，Xcode 会表示不开心。</p>
<p><img src="/content/images/2016/11/xcode.png" alt=""></p>
<p>如果你忽略 Xcode 的心情，那么质量管理平台会默默地记录这一切。</p>
<p><img src="/content/images/2016/11/sonar.png" alt=""></p>
<p>这套东西既帮助开发们写出更高质量的的代码，也给经理们对工程质量的评估提供了一个切面的支持，同时只需要花费较少的人力维护，听起来是不是跃跃欲试了呢 ： ）</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>整体的工作流程非常简单，如图：</p>
<p><img src="/content/images/2016/11/flow-1.png" alt="自动化 Code Review 总体流程"></p>
<p>关键点在于<strong>本地 Review</strong>和<strong>远端 Review</strong>这两步。前者是提供给开发者一个即时的代码质量反馈，以便开发者修改，从而避免在接下来的远端 Review 中得到一个较低的得分。后者则是为了生成相关报表，为项目管理人员跟踪项目质量提供依据。在很多大公司里，这也是开发者们绩效的参考之一。</p>
<p>剩下的就是一些胶水步骤了，如何让过程更自动化，就是胶水步骤要做的事。例如利用 WebHook 自动触发远端 Review，利用 Git 的钩子进行增量校验而不是全量校验等。这些我们放在后面聊，先来看看本地校验的流程。</p>
<h2 id="本地-Review"><a href="#本地-Review" class="headerlink" title="本地 Review"></a>本地 Review</h2><p><img src="/content/images/2016/11/local-flow-1.png" alt="本地自动化 Code Review"></p>
<p>在本地 Review 环节，开发者只需要像往常一样按下 CMD + B，然后只要静静地等待进度条读完，满屏的⚠️就会精确地指示出某一行的代码违反了哪条规则。此时开发者就可以根据代码规范进行对应修改。</p>
<p>从按下按键到产生警告主要发生了这么几件事情：</p>
<ul>
<li>生成 compile_commands.json 文件</li>
<li>OCLint 读取相关的 Rules，逐个扫描 compile_commands.json 中的 .m 文件</li>
<li>OCLint 将生成的报告展示在 Xcode 上</li>
</ul>
<p><strong>实现本地 Review 的核心就是 OCLint 和 compile_commands.json文件</strong></p>
<h3 id="OCLint"><a href="#OCLint" class="headerlink" title="OCLint"></a>OCLint</h3><blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a> 是一个开源的，基于 Clang 用 C++ 编写而成的，可以用于 C、C++ 和 Objective-C 的静态代码分析器。它可以在扫描的过程中动态加载规则文件（Rules），因此可以实现非常灵活的，高度可自定义的代码分析方案。它几乎可以和大多数系统无缝集成，例如 Cmake、Bear、xcodebuild、xctool、Xcode、xcpretty、Jenkins CI、Travis CI 等。你可以在<a href="http://docs.oclint.org/en/stable/guide/xcode.html" target="_blank" rel="noopener">这里</a>找到如何将其和 Xcode 配合使用。</p>
<p>最新版本的 OCLint 已经自带了 71 条 Rules，基本上都是先人宝贵的经验，比如<a href="http://docs.oclint.org/en/stable/rules/basic.html#gotostatement" target="_blank" rel="noopener">这条禁用 goto 语句的 Rule</a>，就是来源于 <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger W. Dijkstra</a> 1968 年的一篇<a href="http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF" target="_blank" rel="noopener">手稿</a>。</p>
<p>这 71 条 Rules 已经可以帮助我们避免一部分因书写习惯和语言误区而导致的问题，但是对于有完整编码规范的公司来说显然是不够的。我们必须要自己开发 Rules。</p>
<p>幸运的是，OCLint 已经为我们准备好了一切。</p>
<p>OCLint 提供了 Clang 和 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">AST (Abstract Syntax Tree)</a> 的一层封装，使我们不必对抽象语法树进行解析，只需要专注规则相关的逻辑开发即可。从其提供的接口中我们可以很明显地看出这一点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到一元操作符</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VisitUnaryOperator</span><span class="params">(UnaryOperator *node)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 遇到二元操作符</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VisitBinaryOperator</span><span class="params">(BinaryOperator *node)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 遇到 Objective-C 的函数声明</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VisitObjCMethodDecl</span><span class="params">(ObjCMethodDecl *node)</span></span></span><br></pre></td></tr></table></figure>
<p>在开发好相关的规则后，打包成 dylib，就可以在分析的时候<a href="http://docs.oclint.org/en/stable/manual/oclint.html#rule-loading-options" target="_blank" rel="noopener">加载我们自己的 Rule 了</a>。</p>
<h3 id="compile-commands-json"><a href="#compile-commands-json" class="headerlink" title="compile_commands.json"></a>compile_commands.json</h3><p>compile_commands.json 是 Clang 定义的<a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html" target="_blank" rel="noopener">一个规范</a>，里面存放了一组<strong>工作目录</strong>、<strong>目标文件</strong>、<strong>需要被执行的命令</strong>，帮助相关工具可以独立于编译系统来将源代码文件转换为 AST 并做对应的事。</p>
<p>看文件内容会更直观一些：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"directory"</span>: <span class="string">"/path/to/project/"</span>, </span><br><span class="line">  <span class="attr">"command"</span>: <span class="string">"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x ..."</span>, </span><br><span class="line">  <span class="attr">"file"</span>: <span class="string">"/path/to/project/XXXViewController.m"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>OCLint 可以根据 compile_commands.json 中的内容，批量检查源代码文件。</p>
<h3 id="xcpretty"><a href="#xcpretty" class="headerlink" title="xcpretty"></a>xcpretty</h3><p>还有一个点需要关注的是，如何生成 compile_commands.json 文件？</p>
<p>最便捷的方式是使用 <code>oclint-xcodebuild</code> 来生成。首先，利用xcodebuild 生成 xcodebuild.log 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild | tee xcodebuild.log</span><br></pre></td></tr></table></figure>
<p>然后利用 <code>oclint-xcodebuild</code> 生成 compile_commands.json</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oclint-xcodebuild</span><br></pre></td></tr></table></figure>
<p>截至 Xcode 8.1，这种做法可以正确生成 json 文件。由于 OCLint 团队已经声称不再维护 oclint-xcodebuild , 因此可能在未来的某个 Xcode 版本中这个方法将不再适用。</p>
<p>另一个推荐的方法是利用 <a href="https://github.com/supermarin/xcpretty" target="_blank" rel="noopener">xcpretty</a> 。</p>
<p>xcpretty 可以一句话生成 json 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild | xcpretty -r json-compilation-database --output /path/to/compile_commands.json</span><br></pre></td></tr></table></figure>
<h3 id="使用本地-Review"><a href="#使用本地-Review" class="headerlink" title="使用本地 Review"></a>使用本地 Review</h3><p>了解了这些工具后就很容易明白本地自动化 Code Review 是如何工作的，使用方式也非常容易理解了：</p>
<ol>
<li>首先在电脑本地安装好 OCLint 并拿到公司自定义的 Rules 文件</li>
<li><a href="http://docs.oclint.org/en/stable/guide/xcode.html" target="_blank" rel="noopener">在 Xcode 上配置好工程</a></li>
<li>build 工程，等待结果显示在 Xcode 上。</li>
</ol>
<p>附一个我们团队的配置脚本供参考:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;SRCROOT&#125;</span></span><br><span class="line">xcodebuild clean</span><br><span class="line">xcodebuild | tee xcodebuild.log</span><br><span class="line">oclint-xcodebuild</span><br><span class="line">oclint-json-compilation-database \</span><br><span class="line">-e Vendor \</span><br><span class="line">-e Pods \</span><br><span class="line">-- \</span><br><span class="line">-max-priority-1 100000 \</span><br><span class="line">-max-priority-2 100000 \</span><br><span class="line">-max-priority-3 100000 \</span><br><span class="line">-report-type xcode \</span><br><span class="line">-R /path/to/rules</span><br></pre></td></tr></table></figure>
<h2 id="远端-Review"><a href="#远端-Review" class="headerlink" title="远端 Review"></a>远端 Review</h2><p><img src="/content/images/2016/11/remote-flow-1.png" alt="远端自动化 Code Review"></p>
<p>远端 Review 和 本地 Review 大体相似，区别在与引用构建的脚本的对象从 Xcode 变成了 Jenkins CI ，报告的展示者从 Xcode 变成了 SonarQube 。其流程是这样的：</p>
<p>工程师通过 <code>git push</code> 提交代码<br>→ Web Hook 触发 <strong>Jenkins</strong> 构建<br>→ <strong>OCLint</strong> 扫描代码生成PMD格式报告<br>→ <strong>Sonar-runner</strong> 读取报告并展现到 <strong>SonarQube</strong>。</p>
<h3 id="CI-环境"><a href="#CI-环境" class="headerlink" title="CI 环境"></a>CI 环境</h3><p>为了实现远端 Review ，服务端必须首先有一套 CI 环境。鉴于 iOS 的特殊性，服务器必须是 macOS 系统。CI 我们直接选择开源的 <a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a>，质量管理平台则选用开源的 <a href="http://www.sonarqube.org" target="_blank" rel="noopener">SonarQube</a>。Jenkins 大名鼎鼎大家都非常熟悉了，SonarQube 则相对少的人了解。</p>
<p>SonarQube 是一个质量管理平台，在 SonarQube 上，你可以看到一个项目的代码行数、文件数量、代码重复率、违反的代码规范、技术债时间等等指标。SonarQube 对 Java 的支持极度友好，提供了 <strong>SonarScanner</strong> 可以直接对 Java 源代码进行扫描。Objective-C 就没有这么幸运了。虽然 SonarQube 也提供了 Objective-C 的报告展示的支持，但静态分析还是得依靠 OCLint 。</p>
<h3 id="Sonnar-Runner"><a href="#Sonnar-Runner" class="headerlink" title="Sonnar-Runner"></a>Sonnar-Runner</h3><p>我们在 Jenkins 上运行 OCLint 生成了报告。需要一个中间人将报告解析成 SonarQube 可以理解的格式并传输到 SonarQube 平台。这个中间人就是 Sonnar-Runner。Sonnar-Runner 在我们的系统中也仅仅扮演这个搬运工的角色。你可以从<a href="http://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Jenkins" target="_blank" rel="noopener">这里</a>了解到如何在 Jenkins 上安装和使用 Sonnar-Runner。</p>
<p>Sonnar-Runner 只能解析 <a href="http://pmd.github.io" target="_blank" rel="noopener">PMD</a> 格式的报告，因此我们在使用 OCLint 分析代码后，需要将报告格式<a href="http://docs.oclint.org/en/stable/howto/selectreporters.html#pmd-reporter-pmd" target="_blank" rel="noopener">输出为 PMD 格式</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oclint -report-type pmd -o ./report.xml</span><br></pre></td></tr></table></figure>
<h3 id="Rules-in-Sonar"><a href="#Rules-in-Sonar" class="headerlink" title="Rules in Sonar"></a>Rules in Sonar</h3><p>SonarQube 有一套规则，将代码问题按照严重程度分为 5 个等级，不同等级的问题会以不同权重影响到项目质量评分。这套规则和 OCLint 生成的报告中的 Rule name 必须要一一对应，SonarQube 才能正确将报告中的问题归类并评分。</p>
<p>如果你使用 OCLint 原生的 Rules 来检查代码，只需要在 SonarQube 上安装 <a href="https://github.com/octo-technology/sonar-objective-c" target="_blank" rel="noopener">SonarQube Plugin for Objective C</a> 插件，相关的报告就会被正确识别了。</p>
<p>如果是使用了自行开发的 Rules ，只需要 Clone 上述插件，并在<strong>profile-oclint.xml</strong> 和 <strong>rules.txt</strong> 中添加相关的 rule name ，然后打包并将这个插件安装到 SonarQube 上即可。</p>
<p>举个例子：</p>
<p>当我们用自行开发的 Rule 检查完代码后，生成了report.xml，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">pmd</span> <span class="attr">version</span>=<span class="string">"oclint-0.11"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span> <span class="attr">name</span>=<span class="string">"/path/to/TerribleCode.m"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">violation</span> <span class="attr">rule</span>=<span class="string">"binary operator space (HT_iOS_Coding_style 2.8)"</span> <span class="attr">begincolumn</span>=<span class="string">"9"</span> <span class="attr">endcolumn</span>=<span class="string">"157"</span> <span class="attr">beginline</span>=<span class="string">"73"</span> <span class="attr">endline</span>=<span class="string">"73"</span> <span class="attr">priority</span>=<span class="string">"3"</span> <span class="attr">ruleset</span>=<span class="string">"HT_iOS_rules"</span> &gt;</span></span><br><span class="line">            多元运算符和他们的操作数之间至少需要一个空格</span><br><span class="line">        <span class="tag">&lt;/<span class="name">violation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pmd</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>binary operator space (HT_iOS_Coding_style 2.8)</code> 是我们定义的错误rule name。在 SonarQube 上，也必须对应有这么一条 rule 的 name，才能正确识别这个错误。</p>
<p>此时我们只需要在上述插件的 <strong>rules.txt</strong> 中添加一段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">binary operator space (HT_iOS_Coding_style 2.8)</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">Summary:多元运算符和他们的操作数之间至少需要一个空格。 </span><br><span class="line"></span><br><span class="line">Severity: 2</span><br><span class="line">Category: Hengtian iOS Coding Standard</span><br></pre></td></tr></table></figure>
<p>在上述插件的 <strong>profile-oclint.xml</strong> 中添加另外一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;rule&gt;</span><br><span class="line">  &lt;repositoryKey&gt;OCLint&lt;/repositoryKey&gt;</span><br><span class="line">  &lt;key&gt;binary operator space (HT_iOS_Coding_style 2.8)&lt;/key&gt;</span><br><span class="line">&lt;/rule&gt;</span><br></pre></td></tr></table></figure>
<p>然后将这个插件打包并安装到 SonarQube 上，SonarQube 就可以正确识别我们的问题并分类了。</p>
<h3 id="使用远端-Review"><a href="#使用远端-Review" class="headerlink" title="使用远端 Review"></a>使用远端 Review</h3><p>在使用前，一定要确保你的 macOS 服务器已经安装好了最新版的 Xocde、OCLint、Jenkins、sonnar-runner，安装好 Jenkins 的相关插件，并将自定义的 Rule 放置在服务器上（如果有的话）。</p>
<h4 id="检查并生成报告"><a href="#检查并生成报告" class="headerlink" title="检查并生成报告"></a>检查并生成报告</h4><p>在 Jenkins 上新建工程并配置好Git、构建触发器等其他内容。在构建步骤中添加一步 <strong>Execute Shell</strong> ，填入下述脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd YourProjectDir</span><br><span class="line">xcodebuild clean</span><br><span class="line">xcodebuild -workspace MyProject.xcworkspace -scheme HTMarket -sdk iphonesimulator | tee xcodebuild.log | xcpretty</span><br><span class="line">oclint-xcodebuild</span><br><span class="line">oclint-json-compilation-database -e Pods \</span><br><span class="line">-v \</span><br><span class="line">-- \</span><br><span class="line">-max-priority-1 100000 \</span><br><span class="line">-max-priority-2 100000 \</span><br><span class="line">-max-priority-3 100000 \</span><br><span class="line">-report-type pmd \</span><br><span class="line">-R /path/to/diy-rules \</span><br><span class="line">-o /path/to/report.xml</span><br></pre></td></tr></table></figure>
<p>脚本大致和本地 Review 一致，有三个地方需要注意一下。</p>
<ol>
<li><code>xcodebuild</code> 命令添加了 <code>-sdk iphonesimulator</code>参数，以避免 build 需要 Code Sign 的问题。</li>
<li><code>-report-type pmd</code> 输出格式必须为 pmd 格式</li>
<li><code>-o /path/to/report.xml</code> 注意输出报告的路径，下一步sonnar-runner 读取时会用到。</li>
</ol>
<h4 id="读取到-SonarQube"><a href="#读取到-SonarQube" class="headerlink" title="读取到 SonarQube"></a>读取到 SonarQube</h4><p>在上一步的下方再添加一步 <strong>Invoke Standalone SonarQube Analysis</strong>，选择好你的 sonnar-runner。并在 <em>Analysis Properties</em> 中添加如下配置：（如果没有这一项，你可能需要安装 SonarQube 相关的插件。）</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sonar.projectKey=YOUR_PROJECT_NAME</span><br><span class="line">sonar.projectName=YOUR_PROJECT_NAME</span><br><span class="line">sonar.projectVersion=<span class="number">1.0</span></span><br><span class="line">sonar.language=objc</span><br><span class="line">sonar.projectDescription=YOUR_PROJECT_DESCRIPTION</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Path to source directories </span></span><br><span class="line">sonar.sources=<span class="regexp">/path/to</span><span class="regexp">/source/directories</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Xcode project configuration (.xcodeproj or .xcworkspace)</span></span><br><span class="line"><span class="comment"># -&gt; If you have a project: configure only sonar.objectivec.project</span></span><br><span class="line"><span class="comment"># -&gt; If you have a workspace: configure sonar.objectivec.workspace and sonar.objectivec.project</span></span><br><span class="line"><span class="comment"># and use the later to specify which project(s) to include in the analysis (comma separated list)</span></span><br><span class="line">sonar.objectivec.project=YOUR_PROJECT_NAME.xcodeproj </span><br><span class="line">sonar.objectivec.workspace= YOUR_PROJECT_NAME.xcworkspace</span><br><span class="line"></span><br><span class="line"><span class="comment"># Scheme to build your application</span></span><br><span class="line">sonar.objectivec.appScheme=YOUR_PROJECT_NAME</span><br><span class="line"> </span><br><span class="line">sonar.sourceEncoding=UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OCLint report generated by run-sonar.sh is stored in sonar-reports/oclint.xml</span></span><br><span class="line"><span class="comment"># Change it only if you generate the file on your own</span></span><br><span class="line"> sonar.objectivec.oclint.report=YOUR_REPORT_FILE_PATH</span><br></pre></td></tr></table></figure>
<p>注意看注释并修改 <code>YOUR_PROJECT_NAME</code> 、<code>YOUR_PROJECT_DESCRIPTION</code>、和 <code>YOUR_REPORT_FILE_PATH</code>为你项目的值。</p>
<p>一切顺利的话，在 Jenkins 上立即构建，你就可以在你的 Sonar 平台上看到代码质量报告了。</p>
<p>配合好<strong>构建触发器</strong> 和 Git 平台的 WebHook 功能，就可以在开发提交代码或者合并分支等关键点自动触发构建了。</p>
<h3 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h3><p><strong>为什么生成的 compile_commands.json 为空</strong></p>
<p>检查 log 是否为空，如果 log 为空则代表 build 失败。排除失败原因后即可正常生成。</p>
<p><strong>Jenkins 构建遇到了如下问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❌  Code signing is required for product type &apos;Application&apos; in SDK &apos;iOS 10.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>遇到这样的情况，是因为构建了 Release 版本，且项目在 Xcode8+ 上开启了 Automatic Code Sign。解决方法如下：</p>
<ol>
<li>如果只需要检查代码规范，则在 xcodebuild 命令后添加 <code>-sdk iphonesimulator</code> 参数指明以 Debug 方式构建即可。</li>
<li>如果希望构建 Release 版本，那么关闭自动签名，在 CI 系统上手动配置证书和Proversion Profile。或者保留自动签名，参考<a href="https://testerhome.com/topics/5954" target="_blank" rel="noopener">这个回答</a>用 <code>sed</code> 命令在构建前修改相关配置。</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a></li>
<li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li>
<li><a href="http://www.sonarqube.org" target="_blank" rel="noopener">SonarQube</a></li>
<li><a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger W. Dijkstra</a></li>
<li><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">AST (Abstract Syntax Tree)</a></li>
<li><a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html" target="_blank" rel="noopener">json compilation database format specification</a></li>
<li><a href="https://github.com/supermarin/xcpretty" target="_blank" rel="noopener">xcpretty</a> </li>
<li><a href="http://pmd.github.io" target="_blank" rel="noopener">PMD</a></li>
<li><a href="https://testerhome.com/topics/5954" target="_blank" rel="noopener">xcode8 和 ios10 升级之后的问题集中讨论帖 – TesterHome</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/09/14/auto-code-review/" data-id="cjpgo3o9y000cfzo00vap3wxb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-string-comparable" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/09/06/string-comparable/" class="article-date">
  <time datetime="2016-09-06T01:13:20.000Z" itemprop="datePublished">2016-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/09/06/string-comparable/">深挖 Swift 中的字符串可比性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>在写 <a href="http://shengpan.net/swift-max/">《从 Swift 中的 max(_:_:) 看设计哲学》</a>的过程中，产生了这样一个想法: <em>既然 <code>max(_:_:)</code> 可以用来对比任何 <code>Comparable</code> ,而 <code>String</code> 是符合 <code>Comparable</code> 的，那么用它来比较两个字符串”谁大谁小”会怎么样呢？</em></p>
<p>由于实验结果的捉摸不定，于是产生了一探究竟的念头。过程很有趣，结果让人感叹计算机科学之深厚。同时也是典型的 <strong>How I Resolve A Problem</strong>,故记。</p>
<h3 id="用-max-来对比-String"><a href="#用-max-来对比-String" class="headerlink" title="用 max 来对比 String"></a>用 max 来对比 String</h3><blockquote>
<p>The Comparable protocol is used for types that have an inherent order, such as numbers and strings.</p>
</blockquote>
<p>Swift 标准库已经为 Sting 实现了 Comparable， max 可以用在 String 上。猜猜下面两个字符串谁更大？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let maxString = max(&quot;bc&quot;, &quot;abc&quot;)</span><br></pre></td></tr></table></figure>
<p>答案是 <strong>maxString == “bc”</strong></p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>根据结果我们猜测，String 的大小应该不是根据长度来判断的，<strong>有可能是按照首字母的 Unicode 编码大小来判断的</strong>。为了证实这一猜测，我们去翻翻相关资料。</p>
<p>首先看 String 的头文件。</p>
<p>我们只看到了实现了 Comparable 的声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension String : Equatable &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension String : Comparable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯。 好歹证实了 String 的确实现了 Comparable 嘛。既然 Swift 是开源的，我们去源代码里找找，继续深挖。</p>
<p>首先 Google <em>swift standard library source code</em>,</p>
<p><img src="/content/images/2016/09/google-swift-std-1.png" alt=""></p>
<p>我们访问 Swift 官网上的 Source Code 一节，其中中有两块资源可能会有我们的答案，一块是 <strong><a href="https://github.com/apple/swift" target="_blank" rel="noopener">Swift 源码</a></strong> ,另一块是 <strong><a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Foundation源码</a></strong>。</p>
<p><img src="/content/images/2016/09/swift-source-code.png" alt=""></p>
<p>我们把两部分都 Clone 下来看看。</p>
<p>首先看可以直接打开工程文件的 Foundation 源码，找到 String.swift 文件， 一共 70 行代码。类声明是这样的 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension String : _ObjectTypeBridgeable</span><br></pre></td></tr></table></figure>
<p>原来这个工程是为了和 Objective - C 的库桥接而生的。看来只能到 Swift 源码中找答案了。</p>
<h3 id="去-Swift-源码中找答案"><a href="#去-Swift-源码中找答案" class="headerlink" title="去 Swift 源码中找答案"></a>去 Swift 源码中找答案</h3><p>Swift 的 README 中有这么一句话</p>
<blockquote>
<p>Another source of documentation is the standard library itself, located in stdlib. Much of the language is actually implemented in the library (including Int)</p>
</blockquote>
<p>既然这样，在 <code>stdlib</code> 文件夹里面，肯定也有 <code>String</code> 的实现。</p>
<p>我们在 <code>stdlib/public/core</code> 下找到 <code>String.Swift</code> 并打开。</p>
<p><img src="/content/images/2016/09/string.png" alt=""></p>
<p>如苹果所说，Swift 标准库的文档基本上都在原代码中了，<strong>开头整整 284 行都是文档</strong>! Apple 的文档丰富和详细在这里提现得淋漓尽致。</p>
<p>从上图也可以看到，我们尝试搜索 <code>Comparable</code> 关键字，没有发现文件中有对 <code>Comparable</code> 的实现。快速翻阅一下 String 的 extension, 也没有发现相关的实现。</p>
<p>查阅 Apple 的 <a href="https://developer.apple.com/reference/swift/comparable" target="_blank" rel="noopener">API Reference</a> 可以得知 <code>Comparable</code> 也是 Swift 标准库的一份。因此，在上述文件夹中肯定能找到相关定义。同时，我们也知道，Swift 可以为 Protocol 添加默认实现。也许找到 <code>Comparable</code> 定义的地方，就能找到答案。</p>
<p><img src="/content/images/2016/09/Comparable.png" alt=""></p>
<p>在 String.swift 的同目录下，我们发现了 Comparable.swift 文件，打开文件，我们发现了熟悉的 <code>Comparable</code> 协议的定义，以及最关键的，默认实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public func &gt; &lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; Bool &#123;</span><br><span class="line">  return rhs &lt; lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func &lt;= &lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; Bool &#123;</span><br><span class="line">  return !(rhs &lt; lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func &gt;= &lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; Bool &#123;</span><br><span class="line">  return !(lhs &lt; rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里只有针对 <code>&gt;</code>，<code>&lt;=</code>,<code>&gt;=</code> 的实现，并且这些实现都是依赖 <code>&lt;</code> 的实现。这一点印证了接口文档中 Apple 关于<a href="http://en.wikipedia.org/wiki/Total_order#Strict_total_order" target="_blank" rel="noopener">严格全序</a>和如何在子类实现 <code>Comparable</code> 的说法。</p>
<blockquote>
<p>A type conforming to <code>Comparable</code> need only supply the <code>&lt;</code> and<code>==</code> operators;<br>default implementations of <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and<code>!=</code> are supplied by the standard library</p>
</blockquote>
<h3 id="走弯路"><a href="#走弯路" class="headerlink" title="走弯路"></a>走弯路</h3><p>那么 <code>&lt;</code> 的实现又在哪儿？</p>
<p>纵览 <code>Comparable</code> 的源码中的文档，基本上是设计思想和使用说明，只字未提 <code>&lt;</code> 的实现。</p>
<p>我们继续翻阅标准库中的文件，在 <code>optinal.swift</code> 等文件中，都有对 <code>==</code> 的重载，但 Command + 左键点击无法跳转到原始实现。一番寻找后，在 <code>Policy.swift</code> 中找到 <code>&lt;</code> 的定义</p>
<p><img src="/content/images/2016/09/-.png" alt=""></p>
<p>似乎 <code>ComparisonPrecedence</code> 是关键所在。由于是打开单个文件，无法点击跳转到 <code>ComparisonPrecedence</code> 的定义。联想到 Swift 的 README 中说过，可以通过 <code>utils/build-script -x</code> 来将源码构建成 Xcode 工程，那样看起来会方便许多。但考虑到需要安装 <code>CMake</code>、<code>Ninja</code> 等一系列环境，所花费的时间对于解决这个问题来说不划算。先去 Google 搜索一下答案。</p>
<p>通过 Google 找到了 NSHipster 的 <a href="http://nshipster.com/swift-operators/" target="_blank" rel="noopener">Swift Operators</a>,也仔细阅读了 <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" target="_blank" rel="noopener">The Swift Programming Language (Swift 2.2)</a>，均没有收获。</p>
<h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><p>就在一筹莫展的时候，想到标准库的源码还没翻完，于是继续一个个地浏览标准库的文件。其中一个文件名让人眼前一亮:</p>
<p><img src="/content/images/2016/09/StringComparable.png" alt=""></p>
<p>我们找到了 String 关于 <code>Comparable</code> 的实现！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension String : Comparable &#123;</span><br><span class="line">  public static func &lt; (lhs: String, rhs: String) -&gt; Bool &#123;</span><br><span class="line">    return lhs._compareString(rhs) &lt; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String 的 <code>&lt;</code> 实现依赖于 <code>Int</code> 的 <code>&lt;</code> 实现。通过 <code>_compareString</code> 生成的整数和 0 比较。至此，我们忽然明白，<strong>Swift 标准库中，<code>Comparable</code> 本身并没有提供默认的 <code>&lt;</code> 实现，而是由 <code>String</code> 和 <code>Int</code> 各自提供了 <code>&lt;</code> 的实现。</strong></p>
<p>整数的比较非常好理解了，我们来看看关键的 <code>_compareString</code> 方法是怎么实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func _compareString(_ rhs: String) -&gt; Int &#123;</span><br><span class="line">#if _runtime(_ObjC)</span><br><span class="line">    // We only want to perform this optimization on objc runtimes. Elsewhere,</span><br><span class="line">    // we will make it follow the unicode collation algorithm even for ASCII.</span><br><span class="line">    if _core.isASCII &amp;&amp; rhs._core.isASCII &#123;</span><br><span class="line">      return _compareASCII(rhs)</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return _compareDeterministicUnicodeCollation(rhs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法对 Objective-C 下的 ASCII 编码的字符串对比做了优化，剩余情况都采用 <code>_compareDeterministicUnicodeCollation</code> 来做比较。</p>
<p>顺藤摸瓜继续看 <code>_compareDeterministicUnicodeCollation</code> 的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  func _compareDeterministicUnicodeCollation(_ rhs: String) -&gt; Int &#123;</span><br><span class="line">    // Note: this operation should be consistent with equality comparison of</span><br><span class="line">    // Character.</span><br><span class="line">#if _runtime(_ObjC)</span><br><span class="line">    if self._core.hasContiguousStorage &amp;&amp; rhs._core.hasContiguousStorage &#123;</span><br><span class="line">      let lhsStr = _NSContiguousString(self._core)</span><br><span class="line">      let rhsStr = _NSContiguousString(rhs._core)</span><br><span class="line">      let res = lhsStr._unsafeWithNotEscapedSelfPointerPair(rhsStr) &#123;</span><br><span class="line">        return Int(</span><br><span class="line">            _stdlib_compareNSStringDeterministicUnicodeCollationPointer($0, $1))</span><br><span class="line">      &#125;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">    return Int(_stdlib_compareNSStringDeterministicUnicodeCollation(</span><br><span class="line">      _bridgeToObjectiveCImpl(), rhs._bridgeToObjectiveCImpl()))</span><br><span class="line">#else</span><br><span class="line">    switch (_core.isASCII, rhs._core.isASCII) &#123;</span><br><span class="line">    case (true, false):</span><br><span class="line">      return Int(_swift_stdlib_unicode_compare_utf8_utf16(</span><br><span class="line">          _core.startASCII, Int32(_core.count),</span><br><span class="line">          rhs._core.startUTF16, Int32(rhs._core.count)))</span><br><span class="line">    case (false, true):</span><br><span class="line">      // Just invert it and recurse for this case.</span><br><span class="line">      return -rhs._compareDeterministicUnicodeCollation(self)</span><br><span class="line">    case (false, false):</span><br><span class="line">      return Int(_swift_stdlib_unicode_compare_utf16_utf16(</span><br><span class="line">        _core.startUTF16, Int32(_core.count),</span><br><span class="line">        rhs._core.startUTF16, Int32(rhs._core.count)))</span><br><span class="line">    case (true, true):</span><br><span class="line">      return Int(_swift_stdlib_unicode_compare_utf8_utf8(</span><br><span class="line">        _core.startASCII, Int32(_core.count),</span><br><span class="line">        rhs._core.startASCII, Int32(rhs._core.count)))</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们略过优化，直接看关键的两个方法： <code>_stdlib_compareNSStringDeterministicUnicodeCollationPointer</code> 和 <code>_swift_stdlib_unicode_compare_utf8_utf8</code></p>
<p>看方法名，大概知道如下信息:</p>
<p>在 Objective - C 下，比较两个 String 的 Unicode 集合指针。</p>
<p>在 Swift 下，通过字符串的起始位置指针和字符串的长度综合比较。那么究竟是怎么综合比较的呢？（原来和长度还是有关系的，看来前面的猜测不全对）。</p>
<p>通过方法名中<code>_swift_stdlib</code>的前缀，我们猜测这个方法可能也是 Swift 标准库中的一员。经过一番查找，我们在 <code>/stdlib/public/stubs</code> 路径下的 <strong>UnicodeNormalization.cpp</strong> 文件的 173 行找到了这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/// Compares the strings via the Unicode Collation Algorithm on the root locale.</span><br><span class="line">/// Results are the usual string comparison results:</span><br><span class="line">///  &lt;0 the left string is less than the right string.</span><br><span class="line">/// ==0 the strings are equal according to their collation.</span><br><span class="line">///  &gt;0 the left string is greater than the right string.</span><br><span class="line">int32_t</span><br><span class="line">swift::_swift_stdlib_unicode_compare_utf8_utf8(const unsigned char *LeftString,</span><br><span class="line">                                               int32_t LeftLength,</span><br><span class="line">                                               const unsigned char *RightString,</span><br><span class="line">                                               int32_t RightLength) &#123;</span><br><span class="line">  UCharIterator LeftIterator;</span><br><span class="line">  UCharIterator RightIterator;</span><br><span class="line">  UErrorCode ErrorCode = U_ZERO_ERROR;</span><br><span class="line"></span><br><span class="line">  uiter_setUTF8(&amp;LeftIterator, reinterpret_cast&lt;const char *&gt;(LeftString), LeftLength);</span><br><span class="line">  uiter_setUTF8(&amp;RightIterator, reinterpret_cast&lt;const char *&gt;(RightString), RightLength);</span><br><span class="line"></span><br><span class="line">  uint32_t Diff = ucol_strcollIter(GetRootCollator(),</span><br><span class="line">    &amp;LeftIterator, &amp;RightIterator, &amp;ErrorCode);</span><br><span class="line">  if (U_FAILURE(ErrorCode)) &#123;</span><br><span class="line">    swift::crash(&quot;ucol_strcollIter: Unexpected error doing utf8&lt;-&gt;utf8 string comparison.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return Diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里的关键算法是 <code>ucol_strcollIter</code>。但到这里，其实我们已经不再需要在源代码中继续翻找了，注释已经给出了答案 – <strong>通过 Unicode 对照算法来比较两个字符串，结果小于 0 ，则代表左边的字符串小于右边，反之亦然。如果结果等于 0 则代表两个字符串在该对照算法下是相等的。</strong></p>
<p>为了补充一下知识，我们再来看看 Unicode Collation Algorithm 的<a href="http://unicode.org/reports/tr10/#Main_Algorithm" target="_blank" rel="noopener">主算法</a>。</p>
<p>主算法分四步</p>
<ol>
<li>标准化字符串</li>
<li>为每个标准化后的字符串生成对照元素数组</li>
<li>根据对照元素数组，生成二进制的排序 Key</li>
<li>通过对比二进制数据的大小，其结果就是原字符串的”大小”。</li>
</ol>
<p>算法这块不过多展开, ucol_strcollIter 函数的实现看<a href="http://icu-project.org/apiref/icu4c/ucol_8h.html" target="_blank" rel="noopener">这里</a>，有兴趣的朋友可以深入研究。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 下字符串的比较是通过计算机科学领域标准的 Unicode 对照算法来的。在不了解算法的情况下，很难从字面上看出两个字符串谁大谁小。因此在日常开发下，应当尽量避免比较两个字符串”谁大谁小”。</p>
<p>Swift 以<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" target="_blank" rel="noopener"><strong>是否具有统一码等价性</strong></a> 作为判断字符相等的标准。因此在比较两个字符串相等的时候，也需要多考虑细，来避免产生不必要的 BUG。</p>
<hr>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://developer.apple.com/reference/swift/comparable" target="_blank" rel="noopener">Comparable</a></li>
<li><a href="https://github.com/apple/swift" target="_blank" rel="noopener">Swift</a><br><a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">Foundation</a></li>
<li><a href="http://nshipster.com/swift-operators/" target="_blank" rel="noopener">Swift Operators</a> </li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" target="_blank" rel="noopener">The Swift Programming Language (Swift 2.2)</a></li>
<li><a href="http://unicode.org/reports/tr10/" target="_blank" rel="noopener">Unicode Collation Algorithm</a></li>
<li><a href="http://icu-project.org/apiref/icu4c/ucol_8h.html" target="_blank" rel="noopener">ICU 57.1</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/09/06/string-comparable/" data-id="cjpgo3oa5000ifzo0awbanuh9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-swift-max" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/09/05/swift-max/" class="article-date">
  <time datetime="2016-09-05T01:18:09.000Z" itemprop="datePublished">2016-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/09/05/swift-max/">从 Swift 中的 max(_:_:) 看设计哲学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于 Swift 不再支持宏了，于是 MAX,MIN 等一些列常用宏都被重写为 Swift 函数。我们来看看函数的定义:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@warn_unused_result</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">max</span>&lt;T : Comparable&gt;<span class="params">(x: T, <span class="number">_</span> y: T)</span></span> -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>
<h3 id="warn-unused-result"><a href="#warn-unused-result" class="headerlink" title="warn_unused_result"></a><code>warn_unused_result</code></h3><p>先说说 @warn_unused_result 注解。 顾名思义，被该注解标记的方法所产生的返回值，如果未被使用，编译器会不开心哦（编译的时候会产生一条警告⚠️）。</p>
<p>这里讲一下方法的设计哲学。一般来说一个理想的带有返回值的方法，除了返回返回值以外，是不会产生任何其他副作用的。比如说不会改变入参的值(这也是 <code>inout</code>存在的原因)<br>，不会对系统的其他状态有影响（比如说不会改变类的实例变量的值）。这样的好处是减少方法产生的不确定性，同时方法使用的目的变得非常明确。</p>
<p>拿 <code>max</code> 来举例。<code>max</code> 方法被设计用来判断并返回两个参数中更大的那个。容易理解，当返回值没有被使用的时候，这次方法的调用也是没有意义的，因此 @warn_unused_result 的标注是非常合理的。</p>
<p>所以当你在开发 SDK 或是框架，甚至是和同事合作开发业务，同事会用到你的 API 的时候，你可以在需要的地方，用此注解来标记你的方法，以提示使用者注意使用方法产生的返回值。</p>
<h3 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h3><p>从方法的定义中，我们可以看到，传入的参数只要符合 <code>Comparable</code> 协议，就可以正确得到返回结果。</p>
<p>这意味着我们不仅可以用它来比较数字大小:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxInteger = <span class="built_in">max</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>还可以用来比较 <code>String</code> 的大小</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxString = <span class="built_in">max</span>(<span class="string">"bc"</span>, <span class="string">"abc"</span>)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">甚至是自定义的对象，只要它实现了 `<span class="type">Comparable</span>` 协议。从这一点上，我们可以窥见 <span class="type">Swift</span> <span class="string">"面向协议编程"</span> 的一斑。面向协议编程让 ` <span class="built_in">max</span>(<span class="number">_</span>:<span class="number">_</span>:)` 从具体的类中解放出来，不关心入参是什么类，有什么结构，只关心 **所传进来的参数能否被比较**,而具体的比较则让入参自己去做，从而让 ` <span class="built_in">max</span>(<span class="number">_</span>:<span class="number">_</span>:)` 具有普适性，达到程序设计上的低耦合。</span><br><span class="line"></span><br><span class="line">这么说可能有点抽象，我们来举个具体的例子。</span><br><span class="line"></span><br><span class="line">假设我们有这样的餐馆定义</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Int</span> <span class="comment">// 占地面积</span></span><br><span class="line">    <span class="keyword">var</span> michelinRate: <span class="type">Int</span> <span class="comment">// 米其林等级</span></span><br><span class="line">    <span class="keyword">var</span> averageCoast: <span class="type">Int</span> <span class="comment">// 人均消费</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="comment">// 餐厅名称</span></span><br><span class="line">    <span class="keyword">var</span> logo: <span class="type">UIImage</span> <span class="comment">// 餐厅LOGO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何比较两家餐馆谁大谁小？</strong></p>
<p>按照餐馆面积比，平海路上的日料店表示不服；按照人均消费比，新白鹿表示不服；按照米其林等级比，一众特色小吃店表示不服；按照餐厅名称长度比，产品经理表示不服。</p>
<p>总地来说，”谁更大”其实是一种抽象的概念， <code>max</code> 方法不能也不该知道入参是如何比较的。只有入参自己知道自己该如何比较。因此抽象出 <code>Comparable</code> 协议是非常自然的。</p>
<h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>我们再来看看 <code>Comparable</code> 的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public protocol Comparable : Equatable &#123;</span><br><span class="line">    /// over instances of `Self`.</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func &lt;(lhs: Self, rhs: Self) -&gt; Bool</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func &lt;=(lhs: Self, rhs: Self) -&gt; Bool</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func &gt;=(lhs: Self, rhs: Self) -&gt; Bool</span><br><span class="line">    @warn_unused_result</span><br><span class="line">    public func &gt;(lhs: Self, rhs: Self) -&gt; Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Comparable</code> 抽象了数学上<a href="http://en.wikipedia.org/wiki/Total_order#Strict_total_order" target="_blank" rel="noopener">严格全序</a>的概念。虽然定义了五个方法(别忘了 Equatable 中还有一个 ==),但只需要实现 <code>==</code> 和 <code>&lt;</code> ，其他方法只需要使用 Swift 标准库提供的默认实现，就可以根据严格全序定义推导出实现。</p>
<p>数学真是计算机科学的基石啊！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/09/05/swift-max/" data-id="cjpgo3o9p0008fzo0cbe45qjw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ios-ci-index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/09/04/ios-ci-index/" class="article-date">
  <time datetime="2016-09-04T05:48:18.000Z" itemprop="datePublished">2016-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/09/04/ios-ci-index/">iOS 持续集成系列 - 开篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#">iOS 持续集成 - 开篇</a></li>
<li><a href="/auto-code-review/">iOS 持续集成 - 自动化 Code Review</a></li>
<li>[iOS 持续集成 - 自动化单元测试]</li>
<li>[iOS 持续集成 - 自动化打包与分发]</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发在经过这几年的野蛮生长之后，慢慢地趋于稳定。无论开发语言是 Objective-C 还是 Swift,工程类型是 Hybird 还是原生，开发思想是 OOP 还是函数式，随着项目逐渐变大都在面临相同的问题: 测试、发布等重复性工作占了很大一部分时间，回归成本越来越高。持续集成不可避免地被提上了日程。</p>
<p>本文主要阐述 iOS 下的持续集成，以目标、内容、流程、工具入手，希望可以为大家描绘一幅 iOS 持续集成的蓝图。这可能不是一篇可以让你 Step by Step 跟着做的文章，但愿可以在你脑海中建立相关概念，以便在实操时走对方向。</p>
<p>我们会在后面几篇内容中，详细阐述 <strong>是什么</strong> 和 <strong>如何做</strong> 。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>对于我们来说，减少重复工作、提升团队效率。<br>对于公司来说，省钱！</p>
<p>狭义上持续集成指早集成早测试尽早早发现问题早修复，并辅以一些自动化的手段，其目标是减少修复的成本。通过其目的，我们可以发现，其实<strong>通过自动化减少重复工作</strong>和<strong>通过早发现问题降低成本</strong>是持续集成的核心理念。因此，我把自动化 Code Review 也放到这里讲。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>iOS 下的持续集成内容包括自<strong>动化 Code Reivew、自动化单元测试、自动化打包和自动化分发</strong>。自动化 Code Review 保证团队遵守代码规范，在编码阶段减少 BUG 的产生。在人员流动较大的公司里，用同一套代码规范，也可以保证项目交接更流畅。自动化单元测试在集成阶段检测出 BUG ,以减少回归成本。自动化打包和自动化分发则是减少重复劳动，毕竟，工程师的时间就是金钱啊。</p>
<h4 id="自动化-Code-Review"><a href="#自动化-Code-Review" class="headerlink" title="自动化 Code Review"></a>自动化 Code Review</h4><p>顾名思义，自动化 Code Review 既采用自动化的手段，对团队成员得代码进行 Review，以保证代码质量。从现实角度来说，自动化的 Code Review 更多地是对代码进行静态分析，通过扫描代码并对比制定的规则，产出所需要的结果。这个所需要的结果，可以是工程总体的量化的质量报告，也可以是显示在 Xcode 中的一条警告⚠️。这取决于用户是什么角色。</p>
<p>在实际实践中，一般会有两种角色会关注这份结果 – <strong>工程师和管理层</strong>。工程师需要在开发的过程中及时了解代码错误，以便及时纠正。管理层需要了解工程的总体代码质量，以掌握项目的相关风险。同时，也可以作为工程师绩效的依据之一。</p>
<p>要完成这一块内容，我们需要这些工具:</p>
<ul>
<li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li>
<li><a href="http://www.sonarqube.org" target="_blank" rel="noopener">SonarQube</a></li>
<li><a href="http://oclint.org" target="_blank" rel="noopener">OCLint</a> OR <a href="https://github.com/realm/SwiftLint" target="_blank" rel="noopener">SwiftLint</a></li>
</ul>
<p>通过这三者协作，我们可以实现以下流程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工程师通过 `Git Commit` 提交代码 → Web Hook 触发 `Jenkins` 构建 → `OCLint` 扫描代码生成PMD格式报告 → `Sonar-runner` 读取报告并展现到 `SonarQube`。</span><br></pre></td></tr></table></figure>
<p>关于 Code Review 需要指出的是，自动化工具是有局限性的。其无法分析出较为”智能”的规则。比如说下面这条</p>
<blockquote>
<p>4.7 方法名以小写字母动词作为开头</p>
</blockquote>
<p>还有下面这种代码，尽管含有多个容易造成闪退的 BUG,也是可以顺利逃过分析器的眼睛的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> result?.bindPhone == <span class="string">"true"</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> range = (result?.loginId?.startIndex.advancedBy(<span class="number">3</span>))!...(result?.loginId?.endIndex.advancedBy(-<span class="number">5</span>))!</span><br><span class="line">	<span class="keyword">let</span> phoneNumber: <span class="type">String</span>? = result?.loginId?.stringByReplacingCharactersInRange(range, withString: <span class="string">"****"</span>)</span><br><span class="line">	<span class="keyword">self</span>.phoneNumLabel.text = phoneNumber!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，想要达到 “保证代码质量” 的目的，还需要人工 Review 和自动化 Review 相结合。</p>
<h4 id="自动化单元测试"><a href="#自动化单元测试" class="headerlink" title="自动化单元测试"></a>自动化单元测试</h4><p>自动化地执行单元测试，在测试失败的情况下中断集成，并通知相关人员，就是这一块工作的内容。</p>
<p>为此，我们需要如下的工具:</p>
<ul>
<li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li>
<li><a href="https://github.com/facebook/xctool" target="_blank" rel="noopener">xctool</a></li>
</ul>
<p>我们可以实现以下的流程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Git Merge`  → Web Hook 触发 `Jenkins` 构建 → xctool 执行单元测试 → 如果失败则发邮件给相关人员。</span><br></pre></td></tr></table></figure>
<p>当然，如果你公司的项目托管在 GitHub 上，业界有两个非常优秀的 Jenkins 替代产品 <a href="https://travis-ci.org" target="_blank" rel="noopener">travis-ci</a> 和 <a href="https://circleci.com" target="_blank" rel="noopener">circle-ci</a>。他们对 GitHub 的支持完美，且对开源项目是免费的。私有项目则需要付费试用。</p>
<p>在单元测试这一块，最高的成本还是写单元测试的时间成本。脑洞大开地说，如果能实现一款工具，可以自动地为业务代码生成测试代码，那才是生产力的大大提升。</p>
<h4 id="自动化打包与分发"><a href="#自动化打包与分发" class="headerlink" title="自动化打包与分发"></a>自动化打包与分发</h4><p>一次完整的打包，需要经历配置证书、切换环境、调整参数(构建版本号等)、Archive、导出。<br>根据工程的复杂程度，以上过程快则五分钟，慢则半小时。当需要频繁发版的情况下，浪费了工程师非常多的时间。</p>
<p>我们其实可以利用一些工具来实现这样的一个流程:</p>
<p>Git Merge 到 Master（通常这意味着一个 Release）→ 触发 Jenkins 构建生成 ipa → <strong>自动化分发</strong>。</p>
<p>自动分发包含以下工作：</p>
<ul>
<li>自动上传 App Store</li>
<li>自动使用 TestFlight 分发</li>
<li>自动上传到 蒲公英/Fir 等平台</li>
<li>自动上传到企业 App Store</li>
</ul>
<p>我们可以分别配置相关的脚本，来实现测试的分发，和发布等。</p>
<p>要实现这样的流程，我们需要这些工具:</p>
<ul>
<li><a href="https://jenkins-ci.org" target="_blank" rel="noopener">Jenkins</a></li>
<li><a href="https://fastlane.tools" target="_blank" rel="noopener">Fastlane</a></li>
</ul>
<p>Fastlane 是由一个个小组件组成的工具，功能包括上传截图到 iTunes Connect,创建 provisioning file, 管理 TestFlight 的测试员，分发等。这个工具几乎可以用命令行来实现打包上传分发相关的所有功能，并且越来越有成为默认的业界持续集成标准工具的样子。就像 CocoaPods 在依赖管理方面一样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>持续集成，可以看做是通过版本控制系统、CI平台(如Jenkins)和相关工具链来完成一套工作流，以减少团队重复性工作，并保证软件可以不停地迭代而不出太大的差错。iOS 下的持续集成大体就是上述几块内容，我们在实现的过程中遇到了不少坑，后面的文章分块详细讲。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/09/04/ios-ci-index/" data-id="cjpgo3o9h0003fzo0x6twu5qs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wechat-url" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/07/12/wechat-url/" class="article-date">
  <time datetime="2016-07-11T18:29:05.000Z" itemprop="datePublished">2016-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/07/12/wechat-url/">微信 URL Schemes</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="DEPRECATED"><a href="#DEPRECATED" class="headerlink" title="DEPRECATED"></a>DEPRECATED</h3><p>2016年09月18日更新：</p>
<p><strong>在 微信 6.3.25 版本中，所有外部唤起 URL 的方式均无法打开对应页面。</strong><br>未来这些 url 都只能在微信内部的浏览器使用了。</p>
<hr>
<p>年初的动态化分享热潮里，基本上都提到了 URL 跳转，天猫称为<a href="http://pingguohe.net/2015/11/24/Navigator-and-Rewrite.html" target="_blank" rel="noopener">统跳协议</a>，蘑菇街称为 <a href="http://limboy.me/tech/2016/03/10/mgj-components.html" target="_blank" rel="noopener">URL 路由</a>。其实很多大厂都默默地做了一套 URL 跳转机制，比如说 – 微信。</p>
<p>本文整理了部分微信 URL Schemes，经过本人测试，所有url在微信 6.3.22 版本下都可正常工作。大家可以在 Safari 中打开链接进行尝试。(部分链接仅允许在微信内部浏览器中打开，已用<code>!</code>标注。）</p>
<h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><ul>
<li>微信 <a href="weixin://" target="_blank" rel="noopener">weixin://</a></li>
<li><code>!</code>发起群聊 <a href="weixin://dl/groupchat" target="_blank" rel="noopener">weixin://dl/groupchat</a></li>
</ul>
<h3 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h3><ul>
<li><p><code>!</code>添加朋友 <a href="weixin://dl/add" target="_blank" rel="noopener">weixin://dl/add</a></p>
<ul>
<li>上报日志 <a href="weixin://dl/log" target="_blank" rel="noopener">weixin://dl/log</a></li>
<li>故障修复 搜索 <code>:recover</code></li>
</ul>
</li>
<li><p>新的朋友 <a href="weixin://dl/recommendation" target="_blank" rel="noopener">weixin://dl/recommendation</a></p>
</li>
<li>群聊 <a href="weixin://dl/groups" target="_blank" rel="noopener">weixin://dl/groups</a></li>
<li>标签 <a href="weixin://dl/tags" target="_blank" rel="noopener">weixin://dl/tags</a></li>
<li>公众号 <a href="weixin://dl/officialaccounts" target="_blank" rel="noopener">weixin://dl/officialaccounts</a></li>
</ul>
<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><ul>
<li>朋友圈 <a href="weixin://dl/moments" target="_blank" rel="noopener">weixin://dl/moments</a></li>
<li>扫一扫 <a href="weixin://dl/scan" target="_blank" rel="noopener">weixin://dl/scan</a></li>
<li>购物（京东） <a href="weixin://dl/shopping" target="_blank" rel="noopener">weixin://dl/shopping</a></li>
<li>游戏 <a href="weixin://dl/games" target="_blank" rel="noopener">weixin://dl/games</a></li>
</ul>
<h3 id="我"><a href="#我" class="headerlink" title="我"></a>我</h3><ul>
<li>个人信息 <a href="weixin://dl/profile" target="_blank" rel="noopener">weixin://dl/profile</a><ul>
<li>名字 <a href="weixin://dl/setname" target="_blank" rel="noopener">weixin://dl/setname</a></li>
<li>我的二维码 <a href="weixin://dl/myQRcode" target="_blank" rel="noopener">weixin://dl/myQRcode</a></li>
<li>我的地址 <a href="weixin://dl/myaddress" target="_blank" rel="noopener">weixin://dl/myaddress</a></li>
</ul>
</li>
<li>相册 <a href="weixin://dl/posts" target="_blank" rel="noopener">weixin://dl/posts</a></li>
<li>收藏 <a href="weixin://dl/favorites" target="_blank" rel="noopener">weixin://dl/favorites</a></li>
<li>优惠券 <a href="weixin://dl/card" target="_blank" rel="noopener">weixin://dl/card</a></li>
<li>表情 <a href="weixin://dl/stickers" target="_blank" rel="noopener">weixin://dl/stickers</a></li>
<li><p>设置 <a href="weixin://dl/settings" target="_blank" rel="noopener">weixin://dl/settings</a></p>
<ul>
<li>QQ 号 <a href="weixin://dl/bindqq" target="_blank" rel="noopener">weixin://dl/bindqq</a></li>
<li>手机号 <a href="weixin://dl/bindmobile" target="_blank" rel="noopener">weixin://dl/bindmobile</a></li>
<li>邮箱地址 <a href="weixin://dl/bindemail" target="_blank" rel="noopener">weixin://dl/bindemail</a></li>
<li>帐号保护 <a href="weixin://dl/protection" target="_blank" rel="noopener">weixin://dl/protection</a></li>
<li><p>新消息通知 <a href="weixin://dl/notifications" target="_blank" rel="noopener">weixin://dl/notifications</a></p>
</li>
<li><p>通讯录黑名单 <a href="weixin://dl/blacklist" target="_blank" rel="noopener">weixin://dl/blacklist</a></p>
<ul>
<li>不让他（她）看我的朋友圈 <a href="weixin://dl/hidemoments" target="_blank" rel="noopener">weixin://dl/hidemoments</a></li>
<li>不看他（她）的朋友圈 <a href="weixin://dl/blockmoments" target="_blank" rel="noopener">weixin://dl/blockmoments</a></li>
</ul>
</li>
<li><p>通用 <a href="weixin://dl/general" target="_blank" rel="noopener">weixin://dl/general</a></p>
<ul>
<li>多语言 <a href="weixin://dl/languages" target="_blank" rel="noopener">weixin://dl/languages</a></li>
<li>字体大小 <a href="weixin://dl/textsize" target="_blank" rel="noopener">weixin://dl/textsize</a></li>
<li>我的表情 <a href="weixin://dl/stickersetting" target="_blank" rel="noopener">weixin://dl/stickersetting</a></li>
<li>朋友圈小视频 <a href="weixin://dl/sight" target="_blank" rel="noopener">weixin://dl/sight</a></li>
<li><p>功能 <a href="weixin://dl/features" target="_blank" rel="noopener">weixin://dl/features</a></p>
<ul>
<li>通讯录同步助手 <a href="weixin://dl/securityassistant" target="_blank" rel="noopener">weixin://dl/securityassistant</a></li>
<li>群发助手 <a href="weixin://dl/broadcastmessage" target="_blank" rel="noopener">weixin://dl/broadcastmessage</a></li>
</ul>
</li>
<li>聊天记录迁移 <a href="weixin://dl/chathistory" target="_blank" rel="noopener">weixin://dl/chathistory</a></li>
<li>清理微信存储空间 <a href="weixin://dl/clear" target="_blank" rel="noopener">weixin://dl/clear</a></li>
</ul>
</li>
<li>帮助与反馈<ul>
<li>意见反馈 <a href="weixin://dl/help" target="_blank" rel="noopener">weixin://dl/help</a> 或 <a href="weixin://dl/feedback" target="_blank" rel="noopener">weixin://dl/feedback</a></li>
<li>关于微信 <a href="weixin://dl/about" target="_blank" rel="noopener">weixin://dl/about</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><strong>隐藏入口</strong> 第三方公众号临时会话接口 <a href="weixin://dl/business" target="_blank" rel="noopener">weixin://dl/business</a><ul>
<li>参数 <code>ticket</code> <a href="weixin://dl/business/?ticket=" target="_blank" rel="noopener">weixin://dl/business/?ticket=</a></li>
<li>参阅：<a href="http://xyk.cmbchina.com/wx/20150528" target="_blank" rel="noopener">http://xyk.cmbchina.com/wx/20150528</a> 使用了 <a href="http://xyk.cmbchina.com/getWeiXinURL.do" target="_blank" rel="noopener">http://xyk.cmbchina.com/getWeiXinURL.do</a> 生成 ticket 参数</li>
</ul>
</li>
<li><strong>隐藏入口</strong> <code>参数不明</code> 第三方 Webview 接口 <a href="weixin://dl/businessWebview/link/" target="_blank" rel="noopener">weixin://dl/businessWebview/link/</a></li>
<li><strong>隐藏入口</strong> <code>参数不明</code> 第三方游戏库接口 <a href="weixin://dl/businessGame/library/" target="_blank" rel="noopener">weixin://dl/businessGame/library/</a></li>
<li><strong>隐藏入口</strong> <code>参数不明</code> 第三方游戏详情接口 <a href="weixin://dl/businessGame/detail/" target="_blank" rel="noopener">weixin://dl/businessGame/detail/</a></li>
<li><strong>隐藏入口</strong> <code>参数不明</code> 第三方支付接口 <a href="weixin://dl/businessPay/" target="_blank" rel="noopener">weixin://dl/businessPay/</a></li>
<li><strong>隐藏入口</strong> <code>参数不明</code> 第三方临时会话接口 <a href="weixin://dl/business/tempsession/" target="_blank" rel="noopener">weixin://dl/business/tempsession/</a> 或 <a href="weixin://dl/businessTempSession/" target="_blank" rel="noopener">weixin://dl/businessTempSession/</a></li>
</ul>
<h3 id="未知"><a href="#未知" class="headerlink" title="未知"></a>未知</h3><ul>
<li><a href="weixin://dl/chat" target="_blank" rel="noopener">weixin://dl/chat</a></li>
<li><a href="weixin://dl/designeremoji" target="_blank" rel="noopener">weixin://dl/designeremoji</a></li>
<li><a href="weixin://dl/login/common_view" target="_blank" rel="noopener">weixin://dl/login/common_view</a></li>
<li><a href="weixin://dl/login/phone_view" target="_blank" rel="noopener">weixin://dl/login/phone_view</a></li>
<li><a href="weixin://dl/personalemoticon" target="_blank" rel="noopener">weixin://dl/personalemoticon</a></li>
<li><a href="weixin://private/" target="_blank" rel="noopener">weixin://private/</a><ul>
<li><a href="weixin://private/setresult/" target="_blank" rel="noopener">weixin://private/setresult/</a></li>
</ul>
</li>
<li><a href="weixin://dl/update_newest_version" target="_blank" rel="noopener">weixin://dl/update_newest_version</a></li>
<li><a href="weixin://dl/wechatout" target="_blank" rel="noopener">weixin://dl/wechatout</a><ul>
<li><a href="weixin://dl/wechatoutcoupon" target="_blank" rel="noopener">weixin://dl/wechatoutcoupon</a></li>
</ul>
</li>
</ul>
<p>参考资料:</p>
<ul>
<li><a href="https://github.com/reverseengineeringer/com.tencent.mm/blob/master/src/com/tencent/mm/pluginsdk/d.java" target="_blank" rel="noopener">Wechat 安卓版部分源码</a></li>
<li><a href="http://spacekid.me/weixin-url-schemes" target="_blank" rel="noopener">太空小孩</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/07/12/wechat-url/" data-id="cjpgo3o9s000afzo0pzj2te1z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-3dtouch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/06/23/3dtouch/" class="article-date">
  <time datetime="2016-06-22T23:52:03.000Z" itemprop="datePublished">2016-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/06/23/3dtouch/">让你的应用更好地利用 3D Touch - WWDC 2016 Session 228 笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们回首 iPhone 的历程，不禁感叹它是如何不断改变我们对手机的认知的。从触屏改变手机的定义开始，距离传感器、光线传感器，到三轴陀螺仪、GPS、运动传感器、再到指纹。这些功能一步步地拓展 iPhone 的能力，不断地改变着我们的生活。</p>
<p>iPhone 6s 再次增加了新的功能 – 3D Touch。 它为iOS 设备的操作增加了另一个维度的能力，为用户提供了另一个操作体验，甚至是改变了用户的操作习惯。随着设备的普及和软件的跟进，3D Touch 也许会像指纹解锁一样，不可或缺的存在。</p>
<p>关于 3D Touch, Apple 主要为我们提供了两种封装好的功能：</p>
<ol>
<li>主屏幕快捷菜单 ( Home screen quick action)</li>
<li>预览 ( peek and pop )</li>
</ol>
<h3 id="Home-screen-quick-action"><a href="#Home-screen-quick-action" class="headerlink" title="Home screen quick action"></a>Home screen quick action</h3><p><img src="/content/images/2016/06/IMG_0001-1.jpg" alt=""></p>
<p>Home screen quick action 的表现形式非常简单，利用 3D Touch 按主屏幕图标，则会弹出该App 的快捷菜单。点击快捷菜单则会唤起app，并进入到相对应的功能。</p>
<p>主屏幕快捷菜单分为<strong>静态</strong>和<strong>动态</strong>的两种。静态即固定的菜单。动态则代表菜单项是可变的。例如激活一款聊天软件的 Quick Action，出现三个你联系最频繁的人。这便需要动态菜单来实现。</p>
<p>当然，他们的开发也同表现形式一样简单。</p>
<h4 id="静态快捷菜单"><a href="#静态快捷菜单" class="headerlink" title="静态快捷菜单"></a>静态快捷菜单</h4><p>创建一个静态的快捷菜单，只需要简单地在<code>Info.plist</code>中添加一个 <code>UIApplicationShortcutItems</code> 的 Array 即可。</p>
<p>你可以为快捷菜单指定标题、系统或自定义的icon等，所有这些，都只需要在 <code>UIApplicationShortcutItems</code> 下添加一些key 和 value 即可。这些key可以在<a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW32" target="_blank" rel="noopener">这里</a>找到。</p>
<p>iOS 10 中，快捷菜单同时可以附带显示一个 Widget ，也就是以前的 App Extension。如果你提供了多个 Extension，可以在 <code>Info.plist</code> 中添加 <code>UIApplicationShortcutWidget</code>，其 Value 代表快捷菜单中展示的 Extension 的 Bundle id. </p>
<h4 id="动态快捷菜单"><a href="#动态快捷菜单" class="headerlink" title="动态快捷菜单"></a>动态快捷菜单</h4><p>创建一个动态的快捷菜单也非常容易，只需要初始化并配置   <code>UIApplicationShortcutItem</code>, <code>UIMutableApplicationShortcutItem</code> 和 <code>UIApplicationShortcutIcon</code> 这三个类，并将其添加到 AppDelegate 中的 <code>shortcutItems</code> 属性即可。</p>
<p>值得一提的是，静态快捷菜单在 App 被安装的那一刻就可用了。区别于静态菜单，动态快捷菜单只有当第一次启动后才可用。</p>
<h4 id="处理快捷菜单的点击"><a href="#处理快捷菜单的点击" class="headerlink" title="处理快捷菜单的点击"></a>处理快捷菜单的点击</h4><p>这里分<em>当 App 被 kill</em> 和 <em>当 App 未被 kill</em>两种情况。</p>
<p>当 App 仍然在运行的情况下，点击快捷菜单会触发以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">	<span class="comment">// 做你想做的事</span></span><br><span class="line">	<span class="comment">// 最后不要忘了调用completionHandler()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 App 被 kill 的情况下，点击快捷菜单会触发以下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="comment">// 通过 UIApplicationLaunchOptionsShortcutItemKey 在 launchOptions 中取得 UIApplicationShortcutItem</span></span><br><span class="line">	<span class="comment">// 然后做你想做的事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Peek-and-Pop"><a href="#Peek-and-Pop" class="headerlink" title="Peek and Pop"></a>Peek and Pop</h3><p><img src="/content/images/2016/06/IMG_0002-1.jpg" alt=""></p>
<p>macOS 中按下空格键即可预览各种各样的文件。通过 3D Touch 现在它也来到了 iOS 中。这一操作被 Apple 很形象地称为 <strong>Peek and Pop</strong>。</p>
<p>Peek and Pop 将传统的 Push 操作分为了两步，当你的手指按压某行列表，背景开始模式模糊，然后出现一个预览界面，然后继续增加压力，伴随着俏皮的弹性动画，下一个界面呈现在你眼前。在 API 中，这两部分别被称为 <code>Preview</code> 和 <code>Commit</code>。 </p>
<h4 id="为你的-App-添加-Peek-and-Pop"><a href="#为你的-App-添加-Peek-and-Pop" class="headerlink" title="为你的 App 添加 Peek and Pop"></a>为你的 App 添加 Peek and Pop</h4><p>为 App 添加 Peek and Pop 非常简单，只要遵循以下几步：</p>
<ol>
<li>让需要预览的 ViewController 遵循 <code>UIViewControllerPreviewingDelegate</code> 协议</li>
<li>调用 <code>registerForPreviewing(with:sourceView:)</code> 注册该ViewController</li>
<li>在 preview 代理方法中提供一个预览的ViewController，<strong>并设置好 context 的 sourceRect</strong>.</li>
<li>在 commit 代理方法中，直接调用 <code>show(_:sender:)</code> 即可。</li>
</ol>
<p>编码的过程中，要注意检查 3D Touch 的可用性。 因为这项功能同定位一样，用户是可以将其关闭的！为了保证所有的用户都能使用到你 App 的功能，应当依据 3D Touch 的可用性，来编写不同的代码。 当 3D Touch 可用时，那就用上着炫酷的新功能吧！如果不支持 3D Touch，我们还有另外一个备选方案 – <code>UILongPressGestureRecognizer</code>.</p>
<p>另外，不要在 UIViewControllerPreviewingDelegate 中做非常耗时的工作，那会造成界面卡顿。</p>
<p>合理地利用 Peek and Pop 可以为用户带来无缝的体验。 例如，下一个界面会有大量的初始化工作，在preview的过程中，你可以预先加载并提供部分预览（同时也为下一个界面做准备)，记住不要卡住主线程，等到 Pop 时，界面已经初始化好了。这为用户提供了一个非常好的体验。</p>
<h4 id="Preview-Action"><a href="#Preview-Action" class="headerlink" title="Preview Action"></a>Preview Action</h4><p>在 Preview 的过程中，用户可以上滑来唤出类似 Action Sheet 的菜单。实现这一功能只需要重写 ViewController 中的 <code>previewActionItems() -&gt; [UIPreviewActionItem]</code>方法即可。<br>系统提供了和 <code>UIAlertAction</code> 非常类似的 <code>UIPreviewAction</code>，来实现 <code>UIPreviewActionItem</code>。</p>
<p>与 Action Sheet 不同的是，系统提供了 <code>UIPreviewActionGroup</code> 类，实现子菜单的功能。</p>
<p>在开发 Peek and Pop 的过程中，请记住以下原则</p>
<ol>
<li>让合适的内容支持 Peek and Pop (不要滥用这项特性）</li>
<li>始终返回相同的预览界面 （保持一致性和可预测性）</li>
<li>不要在preview代理方法中花太多的时间</li>
<li>为 context 设置正确的 sourceRect</li>
</ol>
<h3 id="UIPreviewInteractionDelegate"><a href="#UIPreviewInteractionDelegate" class="headerlink" title="UIPreviewInteractionDelegate"></a>UIPreviewInteractionDelegate</h3><p>iOS 10 中为我们带来了全新的 API，可以让你自定义 Peek and Pop 操作。 我们只需要让某个对象遵循 <code>UIPreviewInteractionDelegate</code> 协议，并在相对于的代理方法中做我们想做的事情就可以了。 </p>
<p>UIPreviewInteractionDelegate 一共包含以下四个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须实现</span></span><br><span class="line"><span class="comment">// 这个方法可以让你精细地控制从按压到 Preview 触发过程中发生的事</span></span><br><span class="line"><span class="comment">// 配合 UIViewControllerTransitioningDelegate ，可以做类似新郎微博的 + 号菜单效果。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteraction</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction, didUpdatePreviewTransition transitionProgress: CGFloat, ended: Bool)</span></span> <span class="comment">// transitionProgress ranges from 0 to 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法也是必须实现的，用来处理一些 Interaction 被打断情况</span></span><br><span class="line"><span class="comment">// 比如说：接到一个电话。</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteractionDidCancel</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你可以用这个方法来控制 Delegate 的触发。</span></span><br><span class="line"><span class="comment">// return false 则不会触发其他代理方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteractionShouldBegin</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用这个方法来精细地控制 Preview -&gt; Commit 阶段</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">previewInteraction</span><span class="params">(<span class="number">_</span> previewInteraction: UIPreviewInteraction, didUpdateCommitTransition transitionProgress: CGFloat, ended: Bool)</span></span></span><br></pre></td></tr></table></figure>
<p><code>UIPreviewInteractionDelegate</code> 让 3D Touch 变得更灵活了。如果我们希望 iOS 9 也支持这样的功能怎么办呢？ 不用担心，Apple 还提供了更底层的 API。</p>
<h3 id="Low-Level-Force-API"><a href="#Low-Level-Force-API" class="headerlink" title="Low Level Force API"></a>Low Level Force API</h3><p>在 UITouch 中有两个关键的属性为我们提供了压力相关数据的存储。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> force <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br><span class="line">@property(nonatomic,readonly) <span class="type">CGFloat</span> maximumPossibleForce <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br></pre></td></tr></table></figure>
<p><code>force</code> 代表当前 Touch 的压力系数，默认是 0.0 ~ 1.0。你也可以通过 <code>maximumPossibleForce</code> 来调整 <code>force</code> 的上限，来为其提供更宽的变化范围。</p>
<p>上面的 API 仅在支持 3D Touch 和 Apple Pencil 的设备上可用，所以在使用前，不要忘了检查 <code>UITraitCollection</code> 中的<code>forceTouchCapability</code>，来确定以上 API 是否可用。</p>
<blockquote>
<p>为什么将 forceTouchCapability 放在 UITraitCollection 中？</p>
</blockquote>
<blockquote>
<p>因为 Size Classes 将设备抽象成了 Size.</p>
</blockquote>
<h3 id="3D-Touch-的最佳实践"><a href="#3D-Touch-的最佳实践" class="headerlink" title="3D Touch 的最佳实践"></a>3D Touch 的最佳实践</h3><ol>
<li>每个 app 都应该提供 quick actions。其简创建简单，却能带来巨大的价值。</li>
<li>为高价值的任务提供一个快速的入口。</li>
<li>很重要的一点，你需要保证 quik action 的可预测性，用户们如果经常使用它，却发现每一次的结果都不一样，就会因此而困惑。</li>
<li>即使你做了 3D touch 用户也可以禁用这一项功能，因此不能过度依赖这项特性来做一些必须的事情,同时也要准备好备选方案。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>主页的 quick action 可以让你的app 直接进入相关行为。</li>
<li>Peek and Pop 允许你快速预览内容，并导航到对应界面。</li>
<li>UIPreviewInteraction 让你可以更精细地控制 3D Touch。</li>
<li>用户们期望你支持 3D touch。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.apple.com/videos/play/wwdc2016/228/" target="_blank" rel="noopener">WWDC 2016 Sssion 228 - A Peek at 3D Touch</a></p>
<p><a href="http://devstreaming.apple.com/videos/wwdc/2016/228a1kbxogojm4fviqc/228/228_a_peek_at_3d_touch.pdf" target="_blank" rel="noopener">WWDC 2016 Sssion 228 - A Peek at 3D Touch Presentation Slides</a></p>
<p><a href="https://developer.apple.com/library/prerelease/content/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/3DTouchAPIs.html#//apple_ref/doc/uid/TP40016543-CH4-SW1" target="_blank" rel="noopener">Adopting 3D Touch</a></p>
<p><a href="https://developer.apple.com/library/prerelease/content/samplecode/AppChat/Introduction/Intro.html" target="_blank" rel="noopener">Apple WWDC 示例代码: AppChat</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/06/23/3dtouch/" data-id="cjpgo3o9x000bfzo0rse23qjk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-battery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/05/31/battery/" class="article-date">
  <time datetime="2016-05-30T19:31:24.000Z" itemprop="datePublished">2016-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/05/31/battery/">电池电量与低电量模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>优步最近公布的数据显示，<a href="http://www.npr.org/2016/05/17/478266839/this-is-your-brain-on-uber" title="UberNews" target="_blank" rel="noopener">当电池快没电的时候，人们更愿意接受溢价</a>。同时，优步也表明他们并没有利用电量相关的数据来设置溢价规则。换句话说，我们在开发App的时候，可以通过电池电量来”提升用户体验”。</p>
<h3 id="电池状态与电量"><a href="#电池状态与电量" class="headerlink" title="电池状态与电量"></a>电池状态与电量</h3><p><code>UIDevice</code> 中有三个电池相关的属性:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isBatteryMonitoringEnabled) <span class="built_in">BOOL</span> batteryMonitoringEnabled <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0) __TVOS_PROHIBITED;  <span class="comment">// default is NO</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIDeviceBatteryState</span>          batteryState <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0) __TVOS_PROHIBITED;  <span class="comment">// UIDeviceBatteryStateUnknown if monitoring disabled</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="keyword">float</span>                         batteryLevel <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0) __TVOS_PROHIBITED;  <span class="comment">// 0 .. 1.0. -1.0 if UIDeviceBatteryStateUnknown</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>batteryState</code> 来获取电池状态，通过 <code>batteryLevel</code>来获取电池电量信息。</p>
<p>值得一提的是，在获取电池信息之前，需要手动设置 <code>batteryMonitoringEnabled</code> 为 <code>YES</code>，不然<code>batterystate</code> 会返回 <code>Unkonw</code>. </p>
<p>如果想要订阅电池状态，可以注册为以下两个通知的观察者:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceBatteryStateDidChangeNotification</span>;</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIDeviceBatteryLevelDidChangeNotification</span>;</span><br></pre></td></tr></table></figure>
<p><code>batteryLevel</code> 的值每改变 0.05（也就是电池电量的 <strong>5%</strong>）, 就会触发一次 <code>UIDeviceBatteryLevelDidChangeNotification</code>。</p>
<h3 id="低电量模式"><a href="#低电量模式" class="headerlink" title="低电量模式"></a>低电量模式</h3><p>为了解决续航问题，Apple 在 iOS 9 中为 iPhone 添加了<a href="https://support.apple.com/en-gb/HT205234" title="低电量模式" target="_blank" rel="noopener">低电量模式</a> 。在此模式下，系统会通过禁用一些特性诸如电子邮件自动获取、后台刷新、Hey Siri等，来达到降低能耗的目的。</p>
<p>低电量模式的设置藏得比较深，以至于从设置中找到它对大多数人来说是一件非常困难的事。换句话说，用户打开了低电量模式，才能真正说明用户所处的情景需要尽可能地节约电量。因此，相比较于直接获取电池电量来说，探测低电量模式是否开启，更能直观地反应产品情景和用户心理。</p>
<h4 id="检测低电量模式"><a href="#检测低电量模式" class="headerlink" title="检测低电量模式"></a>检测低电量模式</h4><p>在 iOS 9 中，我们可以很容易地检测到用户是否开启了低电量模式，<code>NSProcessInfo</code> 提供了相对于的属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">NSProcessInfo</span> processInfo] isLowPowerModeEnabled]) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 做低电量模式下该做的事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，如果想要对低电量模式的变化做出响应，可以注册为以下通知的观察者：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSProcessInfoPowerStateDidChangeNotification</span>;</span><br></pre></td></tr></table></figure>
<p>当我们检测低电量模式的时候，需要注意以下两点:</p>
<ul>
<li>低电量模式仅支持 iOS 9 。当 App 需要兼容更早的版本时，先检查api的可用性。</li>
<li>低电量模式仅适用于 iPhone ,在 iPad 中，<code>isLowPowerModeEnabled</code> 的返回值始终为 <code>NO</code></li>
</ul>
<p>当我们检测到用户开启了低电量模式，可以为用户做一些小改变，来帮助用户延长电池续航。以下是 Apple 给出一些建议:</p>
<ul>
<li>停止使用定位服务</li>
<li>减弱动画效果</li>
<li>停止后台任务（比如网络请求）</li>
<li>禁用运动追踪</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html" target="_blank" rel="noopener">Energy Efficiency Guide for iOS Apps</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/707/" target="_blank" rel="noopener">WWDC 2015 Session 707 Achieving All-day Battery Life</a></li>
<li><a href="http://useyourloaf.com/blog/detecting-low-power-mode/" target="_blank" rel="noopener">Detecting low power mode</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/05/31/battery/" data-id="cjpgo3o9f0002fzo079kctqih" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hengtian-ios-code-style-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/05/30/hengtian-ios-code-style-2/" class="article-date">
  <time datetime="2016-05-30T00:16:55.000Z" itemprop="datePublished">2016-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/05/30/hengtian-ios-code-style-2/">HengTian iOS Code Style</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HengTian-iOS-Code-Style"><a href="#HengTian-iOS-Code-Style" class="headerlink" title="HengTian iOS Code Style"></a>HengTian iOS Code Style</h1><h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><p>1.1 首先是为人编写程序，其次才是计算机</p>
<p>软件的生命周期贯穿产品的开发、测试、生产、用户使用、版本升级和后期维护等过程，只有易读、易维护的软件代码才具有生命力。</p>
<p>1.2 保持代码的简明清晰，避免过分的编程技巧</p>
<p>简单是最美，不要过分追求技巧，否则会降低程序的可读性。</p>
<p>1.3 编程时首先达到正确性，其次考虑效率</p>
<p>编程首先考虑的是满足正确性、健壮性、可维护性、可移植性等质量因素。</p>
<p>1.4 编写代码时需要考虑到代码的可测试性</p>
<p>不可以测试的代码是无法保障质量的，实现设计功能的同时，要提供可以测试、验证的方法。</p>
<p>1.5 函数（方法）是为一特定功能而编写，不是万能工具箱</p>
<p>方法是一个处理单元，是有特定功能的，所以应该很好地规划方法，不能是所有东西都放在一个方法里实现。</p>
<p>1.6鼓励多注释</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><blockquote>
<p>程序布局的目的是显示出程序良好的逻辑结构，提高程序的准确性、连续性、可读性、可维护性。统一的程序布局和编程风格，有助于提高整个项目的开发质量，提高开发效率，降低开发成本。</p>
</blockquote>
<p>2.1 遵循统一的布局顺序书写头文件和实现文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件头注释</span><br><span class="line">imports</span><br><span class="line">文件内部使用的宏</span><br><span class="line">常量定义</span><br><span class="line">文件内部使用的数据类型</span><br><span class="line">全局变量</span><br><span class="line">本地变量</span><br><span class="line">类定义/实现</span><br></pre></td></tr></table></figure>
<p>在实现中，合理地将功能相似的代码块归为一类，并用 <code>#pragma mark –</code> 做标记。</p>
<p>推荐的代码块划分如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Public Method</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Life cycle</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - IBAction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Navigation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Delegate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private Method</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Getter and Setter</span></span><br></pre></td></tr></table></figure>
<h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><p>2.2.1 <code>If</code>、<code>else</code>、<code>else if</code>、<code>for</code>、<code>while</code>、<code>do</code>等语句自占一行，执行语句不得紧跟其后，不论执行语句有多少都要加<code>{}</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( numberA &gt; numberB )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> numberA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">	[<span class="keyword">self</span> caculate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.2.2 定义指针类型的变量，<code>*</code> 应该放在变量前</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *hello = <span class="string">@"Hello World!"</span>;</span><br></pre></td></tr></table></figure>
<p>2.3 源代码中关系较为紧密的代码应尽可能相邻</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="built_in">CGFloat</span> length;</span><br><span class="line"><span class="built_in">CGFloat</span> height;</span><br></pre></td></tr></table></figure>
<p>2.4 禁止使用TAB键，必须使用空格进行缩进，缩进为4个空格<br>在Xcode -&gt; Preferences -&gt; Text Editing -&gt; Indentation -&gt;Prefer indent using中，将值设置为Spaces。</p>
<p>2.5 程序的分界符 <code>{</code> 和 <code>}</code> 应独占一行并且位于同一列，同时与引用他们的语句对齐。<code>{}</code> 之内的代码块使用缩进规则对齐</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="literal">nil</span> == dic</span><br><span class="line">    || ( <span class="literal">NO</span> == [dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] ) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.6 相关的赋值语句等号对齐</p>
<p>2.7 一元操作符如<code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>*</code>、<code>&amp;</code>和<code>[]</code>、<code>.</code>、<code>-&gt;</code>前后不加空格</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!bValue</span><br><span class="line">iValue</span><br><span class="line">++iCount</span><br><span class="line">*strSource</span><br><span class="line">&amp;fSum</span><br></pre></td></tr></table></figure>
<p>2.8 多元运算符和他们的操作数之间至少需要一个空格</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fWidth = <span class="number">5</span> + <span class="number">5</span>;</span><br><span class="line">fLength = fWidth * <span class="number">2</span>;</span><br><span class="line">fHeight = fWidth + fLength;</span><br></pre></td></tr></table></figure>
<p>2.9 关键字之后要留空格。<br><code>if</code>、<code>for</code>、<code>while</code>等关键字之后应留一个空格再跟左括号<code>(</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == fWidth )</span><br></pre></td></tr></table></figure>
<p>2.10 方法名与形参不能留空格，返回类型与方法标识符有一个空格<br>方法名后紧跟<code>:</code>，然后紧跟形参，返回类型<code>(</code>与<code>-</code>之间有一个空格。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue </span><br><span class="line">sender:(<span class="keyword">id</span>)sender</span><br></pre></td></tr></table></figure>
<p>2.11 注释符与注释内容之间要用一个空格进行分割</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一段长注释 */</span></span><br><span class="line"><span class="comment">// 这是一句短注释</span></span><br></pre></td></tr></table></figure>
<p>2.12 长表达式（超过80列）要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当地缩进，使排版整齐</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == fWidth</span><br><span class="line">   || <span class="number">0</span> &lt; fLength )</span><br></pre></td></tr></table></figure>
<p>2.13 函数（方法）声明时，类型与名称不允许分行书写</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning</span><br></pre></td></tr></table></figure>
<p>2.14 类中功能模块以 <code>#pragma mark –</code>分割，上空两行，下空一行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomething</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark – UITextFieldDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)textFieldDidEndEditing:(<span class="built_in">UITextField</span> *)textField</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.15 方法实现时，参数过长则每个参数用一行，以冒号对齐</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWithFoo:(<span class="built_in">NSString</span> *)theFoo</span><br><span class="line">      			   	  rect:(<span class="built_in">CGRect</span>)theRect</span><br><span class="line"> 				  interval:(<span class="built_in">CGFloat</span>)theInterval</span><br></pre></td></tr></table></figure>
<p>如果方法名比参数名短，则每个参数占用一行，至少缩进4个字符，且为垂直对齐（非冒号对齐）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="keyword">short</span>:(<span class="built_in">NSString</span> *)theFoot</span><br><span class="line">    longKeyword:(<span class="built_in">CGRect</span>)theRect</span><br><span class="line">    evenLongerkeyword:(<span class="keyword">float</span>)theInterval</span><br></pre></td></tr></table></figure>
<p>2.16 方法调用沿用声明方法的习惯 在同一行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomethingWith:<span class="string">@"test"</span> rect:<span class="keyword">self</span>.view.frame interval:<span class="number">1.0</span>f];</span><br></pre></td></tr></table></figure>
<p>或冒号对齐</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomethingWith:<span class="string">@"test"</span></span><br><span class="line">                 rect:<span class="keyword">self</span>.view.frame</span><br><span class="line">             interval:<span class="number">1.0</span>f];</span><br></pre></td></tr></table></figure>
<p>2.17 Protocol 声明中类型标识符、代理名称、尖括号间不留空格</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;MyProtocalDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>在类声明中包含多个protocal，每个protocal占用一行，缩进2个字符。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomBackButtonViewController</span> ()</span></span><br><span class="line">&lt;<span class="built_in">UITextFieldDelegate</span>,</span><br><span class="line">  MyProtocalDelegate,</span><br><span class="line">  <span class="built_in">UITabBarControllerDelegate</span>,</span><br><span class="line">  <span class="built_in">UITabBarDelegate</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果并非所有方法都是必须得，使用<code>@optional</code>标示。 </p>
<p>2.18 其他</p>
<p>函数（方法）块之间使用两个空行分隔</p>
<p><code>@public</code> 和 <code>@private</code> 使用单独一行，且缩进1个字符</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>3.1 一般情况下，源程序有效注释量必须在30%以上</p>
<p>注释语言不宜太多也不能太少，注释语言必须准确、易懂、简洁。</p>
<p>3.2 多行注释采用<code>/*…*/</code>，单行注释采用<code>//…</code></p>
<p>3.3注释应与其描述的代码相近</p>
<p>对代码的注释应放在其上方或右方相邻位置，不可放在下方，如放于上方则需要与其上面的代码用空行隔开</p>
<p>3.4 注释与所描述内容进行同样的缩排</p>
<p>3.5 文件最前面的注释，是保留了工程自动生成的注释，但是需要进行如下修改：文件作者改为个人的名字，公司名为Insigma Hengtian software Ltd</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by ArthurWang on 14-5-7.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Insigma HengTian Software Ltd. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>3.6 类、协议、结构体注释。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @class HTServerDatamanager</span></span><br><span class="line"><span class="comment"> @abstract 异步连接服务器管理类</span></span><br><span class="line"><span class="comment"> @discussion 异步请求服务器，接收到响应后，通过回调把数据回传到对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>3.7 成员方法、接口注释。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @method  initWithTarget：selector：</span></span><br><span class="line"><span class="comment"> @abstract  类初始化函数</span></span><br><span class="line"><span class="comment"> @discussion  本类使用时必须调用此函数进行初始化</span></span><br><span class="line"><span class="comment"> @param target 响应回调对象</span></span><br><span class="line"><span class="comment"> @param selector  回调对象的selector</span></span><br><span class="line"><span class="comment"> @result   类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>4.1 标识符要采用英文单词或其组合，便于记忆和阅读，切忌使用汉语拼音来命名</p>
<p>标识符应当直观且可以拼读，可望文知意，英文单词一般不要太复杂，用词应当准确。</p>
<p>4.2 严格禁止使用连续的下划线，下划线也不能出现在标识符头或结尾。<br>（实例变量及特殊用法除外）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 禁止使用以下命名方式</span></span><br><span class="line"><span class="built_in">CGFloat</span> variable__name;</span><br><span class="line"><span class="built_in">NSString</span> *variale___name;</span><br></pre></td></tr></table></figure>
<p>4.3 程序中不要出现仅靠大小区分的相似的标识符</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 禁止使用以下命名方式</span></span><br><span class="line"><span class="built_in">NSString</span> *contentOfView;</span><br><span class="line"><span class="built_in">NSString</span> *ContentOfView;</span><br></pre></td></tr></table></figure>
<p>4.4 宏、常量名都要使用大写字母，用下划线‘_’分割单词。</p>
<blockquote>
<p>注：优先采用常量命名以兼容Swift</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define HT_SCREEN_HEIGHT UIScreen.mainScreen.bounds.size.height</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下宏可以采用常量替代，则优先采用常量表示</span></span><br><span class="line"><span class="comment">// #define URL_LOGIN   @"/v1/user/login"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> URL_LOGIN = <span class="string">@"/v1/user/login"</span></span><br></pre></td></tr></table></figure>
<p>4.5 程序中局部变量不要与全局变量重名</p>
<blockquote>
<p>尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。</p>
</blockquote>
<p>4.6 使用一致的前缀来区分变量的作用域</p>
<blockquote>
<p>此条规范仅在 C 语言环境下使用，在命名Objective-C的属性时，仍然采用驼峰法命名，并且以小写字母开头。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_  全局变量</span><br><span class="line">s_  模块内静态变量</span><br></pre></td></tr></table></figure>
<p>4.7 方法名用小写字母开头的<strong>动词</strong>组合而成</p>
<blockquote>
<p>方法名力求清晰、明了、通过方法名就能够判断方法的主要功能。方法名中不同意义字段之间不要用下划线连接，而要把每个字段的首字母大写以示区分。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法名采用动词开头</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)touchDoneButton:(<span class="built_in">UIButton</span> *)sender;</span><br></pre></td></tr></table></figure>
<p>4.8 尽量避免名字中出现数字编号，如 Value1, Vlaue2 等，除非逻辑上的确需要编号</p>
<p>4.9 标识符前最好不加项目、产品、部门的标识</p>
<p>这样做的目的是为了代码的可重用性。</p>
<p>4.10 类名（及其 Category 和 Protocol）的首字母大写，驼峰法分割单词</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Category命名</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImage</span> (<span class="title">Scale</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Protocol命名</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">HTModelCallBack</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>4.11 工厂方法以去前缀的类名开头，首字母小写,返回类型必须为 <code>instancetype</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)person;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)personWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>4.12 初始化方法命名必须以 <code>init</code> 开头，带有参数的初始化方法，第一个参数用 <strong>With</strong> 做连接，后续参数不需要跟 <strong>with</strong>，返回类型必须为 <code>instancetype</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">						 age:(<span class="built_in">NSInterger</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>变量、常量和数据类型是程序编写的基础，是直接关系到程序设计的成败。</p>
</blockquote>
<p>5.1 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途<br>一个变量只用来表示一个特定功能，不要把一个变量作多种用途。</p>
<p>5.2 循环语句与判断语句中，不允许对其它变量进行计算与赋值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 禁止如下做法</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="number">100</span> &gt; (fWidth = <span class="number">50</span> * fLength) )</span><br></pre></td></tr></table></figure>
<p>5.3 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MY_MIN(A, B)   ((A)&gt;(B)?(B):(A))</span></span><br></pre></td></tr></table></figure>
<p>5.4 对于全局变量通过统一的函数访问</p>
<p>5.5 最好不要在语句块内声明局部变量</p>
<p>5.6 系统常用类作实例变量声明时加入后缀</p>
<table>
<thead>
<tr>
<th>类名</th>
<th style="text-align:center">所需后缀</th>
<th style="text-align:right">命名例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIViewController</td>
<td style="text-align:center">ViewController</td>
<td style="text-align:right">loginViewController</td>
</tr>
<tr>
<td>UIImage</td>
<td style="text-align:center">Image</td>
<td style="text-align:right">avatarImage</td>
</tr>
<tr>
<td>UIImageView</td>
<td style="text-align:center">ImageView</td>
<td style="text-align:right">avatarImageView</td>
</tr>
<tr>
<td>UILabel</td>
<td style="text-align:center">Label</td>
<td style="text-align:right">nameLabel</td>
</tr>
<tr>
<td>UIView</td>
<td style="text-align:center">View</td>
<td style="text-align:right">carousleView</td>
</tr>
<tr>
<td>UIButton</td>
<td style="text-align:center">Button</td>
<td style="text-align:right">loginButton</td>
</tr>
<tr>
<td>UINavigationBar</td>
<td style="text-align:center">NavigationBar</td>
<td style="text-align:right">mainNavigationBar</td>
</tr>
<tr>
<td>UIToolbar</td>
<td style="text-align:center">ToolBar</td>
<td style="text-align:right">chatToolBar</td>
</tr>
<tr>
<td>UISearchBar</td>
<td style="text-align:center">SearchBar</td>
<td style="text-align:right">messageSearchBar</td>
</tr>
<tr>
<td>UITextField</td>
<td style="text-align:center">TextField</td>
<td style="text-align:right">nameTextField</td>
</tr>
<tr>
<td>UITextView</td>
<td style="text-align:center">TextView</td>
<td style="text-align:right">contentTextView</td>
</tr>
<tr>
<td>NSArray</td>
<td style="text-align:center">Array / s</td>
<td style="text-align:right">userArray / users</td>
</tr>
<tr>
<td>NSMutableArray</td>
<td style="text-align:center">MArray / s</td>
<td style="text-align:right">userMArray / users</td>
</tr>
<tr>
<td>NSDictionary</td>
<td style="text-align:center">Dictionary</td>
<td style="text-align:right">parameterDictionary</td>
</tr>
<tr>
<td>NSMutableDictionary</td>
<td style="text-align:center">MDictionary</td>
<td style="text-align:right">parameterMDictionary</td>
</tr>
<tr>
<td>NSString</td>
<td style="text-align:center">String</td>
<td style="text-align:right">parameterString</td>
</tr>
<tr>
<td>NSMutableString</td>
<td style="text-align:center">MString</td>
<td style="text-align:right">paramterMString</td>
</tr>
<tr>
<td>NSSet</td>
<td style="text-align:center">Set</td>
<td style="text-align:right">keySet</td>
</tr>
<tr>
<td>NSMutableSet</td>
<td style="text-align:center">Mset</td>
<td style="text-align:right">keyMSet</td>
</tr>
</tbody>
</table>
<p>5.7 属性声明严把权限，对不需要外部修改的属性使用 <code>readonly</code></p>
<p>5.8 <code>NSString</code>使用 <code>copy</code> 而非 <code>retain</code></p>
<p>5.9 <code>CFType</code> 使用 <code>@dynamic</code>，禁止使用 <code>@synthesize</code></p>
<p>5.10 除非必须，使用 <code>nonatomic</code></p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><blockquote>
<p>表达式是语句的一部分，他们是不可分割的。</p>
</blockquote>
<p>6.1 一条语句只完成一个功能</p>
<blockquote>
<p>复杂的语句阅读起来，难于理解，并容易隐含错误。</p>
</blockquote>
<p>6.2 在表达式中使用括号，使表达式的运算顺序更清晰</p>
<blockquote>
<p>由于将运算符的优先级与结合律熟记是比较困难的，为了防止产生歧义并提高可读性，即使不加括号时运算顺序不会改变，也应当用括号确定表达式的操作顺序。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ( ( <span class="number">0</span> == iYear % <span class="number">4</span> ) &amp;&amp; ( <span class="number">0</span> != iYear % <span class="number">100</span> ) ) || ( <span class="number">0</span> == iYear % <span class="number">400</span> ) )</span><br></pre></td></tr></table></figure>
<p>6.3 避免表达式中的附加功能，不要编写太复杂的复合表达式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @warning 不要采用如下写法</span></span><br><span class="line"><span class="keyword">int</span> iResult = iYear++-++iMonth+iDay++;</span><br></pre></td></tr></table></figure>
<p>6.4 不可将布尔变量和逻辑表达式直接与YES、NO或则1、0进行比较</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( isSuccess ) <span class="comment">//真</span></span><br><span class="line"><span class="keyword">if</span> ( !isSuccess )<span class="comment">//假</span></span><br></pre></td></tr></table></figure>
<p>6.5 在条件判断语句中，当整型变量与 <code>0</code> 比较时，不可模仿布尔变量的风格，应当将整型变量用 <code>==</code> 或 <code>!=</code> 直接与 <code>0</code> 比较</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == iYear )</span><br><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> != iMonth )</span><br></pre></td></tr></table></figure>
<p>6.6. 应当将指针变量用 <code>==</code> 或 <code>!=</code> 与 <code>nil</code> 比较</p>
<blockquote>
<p>指针变量的零值是 <em>空</em>（即nil），nil的值与0相同，但是两者含义不同。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="literal">nil</span> == strName )</span><br></pre></td></tr></table></figure>
<p>6.7 在switch语句中，每一个<code>case</code>分支必须使用<code>break</code>结尾，最后一个分支必须是<code>default</code>分支<br>避免漏掉<code>break</code>语句造成程序错误，同时保持程序简洁。对于多个分支相同处理的情况可以共用一个<code>break</code>，但是要用注释加以说明。</p>
<p>6.8 <code>for</code>语句的循环控制变量的取值采用<strong>半开半闭区间</strong>写法</p>
<p>这样做更能适应数组的特点，数组的下标属于一个<strong>半开半闭区间</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iMax[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, iMax[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.9 不可在<code>for</code>循环内修改循环变量，防止<code>for</code>循环失去控制</p>
<p>6.10 循环嵌套次数不大于 <code>3</code> 次</p>
<p>6.11 <code>do while</code> 语句和 <code>while</code> 语句仅使用一个条件</p>
<p>6.12 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面</p>
<p>6.13 将 <code>int</code> 值转换为 <code>BOOL</code> 时应特别小心</p>
<p>6.14 Objective-C 中，<code>BOOL</code> 被定义为 <code>unsigned char</code> ，这意味着除了 <code>YES</code>（1）和<code>NO</code>（0）外它还可以是其他值。禁止将<code>int</code>直接转换为<code>BOOL</code>。</p>
<p>6.15 将整型值转换为<code>BOOL</code>的方法：使用三元运算符返回<code>YES</code> / <code>NO</code>，或使用<code>&amp;&amp;</code>，<code>||</code>。</p>
<p>6.16 <code>BOOL</code>、<code>_BOOL</code>和<code>bool</code>之间的转换是安全的，但是<code>BOOL</code>和<code>Boolean</code>间的转换不是安全的，所以将<code>Boolean</code>看成整型值。</p>
<p>6.17 在 Objective-C 中，只允许使用<code>BOOL</code>。</p>
<h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><blockquote>
<p>凡此变数中函彼变数者，则此为彼之函数</p>
</blockquote>
<p>7.1 方法不能为多个目的服务</p>
<p>一个方法只做一件事。</p>
<p>7.2 避免函数有太多的参数，参数个数尽量控制在5个以内</p>
<p>如果参数的确比较多，不妨把这些参数定义成一个结构（或一个类）。</p>
<p>7.3 对于有返回值的函数（方法），每一个分支都必须有返回值</p>
<p>为了保证对被调用函数返回值的判断，有返回值的函数中都每一个退出点都需要有返回值。</p>
<p>7.4 对输入参数的正确性和有效性进行检查</p>
<p>很多程序错误和崩溃是由非法参数引起的。</p>
<p>7.5 防止将函数（方法）的参数作为工作变量</p>
<p>将函数的参数作为工作变量，有可能错误地改变参数内容。对必须改变的参数，最好先用局部变量代之，最后再将该局部变量的内容赋给该参数。</p>
<p>7.6 函数（方法）体的规模不能太大，尽量控制在200行之内</p>
<p>冗长的函数不利于调试，可读性差。</p>
<p>7.7 Dealloc的顺序要与变量声明的顺序相同</p>
<p>这样有利于review代码。 如果dealloc中调用其他方法来release变量，将被release的变量以注释的形式标注清楚。 先release自身成员变量，再调用父类dealloc方法。</p>
<p>7.8 在接口中应该尽量少使用外部定义的类型（减少耦合）</p>
<p>7.9 禁止直接调用<code>NSObject</code>的类方法<code>+new</code>，也不要在子类中重载它。使用<code>alloc</code>和<code>init</code>方法。</p>
<p>7.10 创建对象时尽量使用<code>autorelease</code>，创建临时对象时，尽量同时在同一行中<code>autorelease</code>掉，而非使用单独的release语句。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>8.1 申明成员类，应该引用该类申明，而不是包含该类的头文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">MyViewController</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) MyViewController *myViewController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>8.2共同的接口、结构体、常量和数据类型要定义在同一个头文件里</p>
<p>8.3 使用<code>#import</code>引入Objective - C和Objective - C++头文件，使用<code>#include</code>引入c和c++头文件</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>为保证代码的可靠性，编程时请遵循入下基本原则，优先级递减</p>
<ul>
<li>正确性</li>
<li>稳定性</li>
<li>可测试性</li>
<li>规范、可读性</li>
<li>全局效率</li>
<li>局部效率</li>
<li>个人表达方式/个人方便性</li>
</ul>
<p>9.1 防止内存操作越界</p>
<p>内存操作主要是指对数组、指针、内存地址等得操作，内存操作越界是软件系统主要错误之一，后果往往非常严重，引起崩溃。</p>
<p>9.2 当变量释放后，需要将变量置为nil</p>
<p>避免因为野指针引起的程序崩溃。</p>
<p>9.3 变量在使用前应初始化，防止未初始化的变量被引用</p>
<p>引用未初始化的变量，会引起程序的崩溃。</p>
<p>9.4 指针不要进行复杂的逻辑或算术操作</p>
<p>通过复杂的逻辑或算术操作后，指针的位置就很难确定。</p>
<p>9.5 减少指针和数据类型的强制类型转化</p>
<p>强制类型转化如果类型强转错误会引起崩溃。</p>
<p>9.6 在编写派生类的赋值时，主要不要忘记对基类的成员变量重新赋值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.7 使用 <code>Extension</code> 申明私有方法和属性,所有属性和实例变量都采用 <code>@property</code> 来申明</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LoginViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, string) <span class="built_in">UITextField</span> *nameTextField;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)login;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LoginViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>9.8对变量进行赋值时，必须对其值进行合法性检查，防止越界等现象发生。</p>
<p>9.9 非初始化方法中的 <code>alloc</code> 操作之前必须要 <code>nil</code> 判断。</p>
<p>9.10 指针类型变量必须初始化为<code>nil</code>。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><blockquote>
<p>断言是对某种假设条件进行检查，可以快速发现并定位软件文件，同时对系统错误进行自动报警。</p>
</blockquote>
<p>10.1 整个软件系统应该采用统一的断言。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(str);</span><br></pre></td></tr></table></figure>
<p>10.2 正式软件产品中应把断言及其它的调测代码去掉，加快软件运行速度。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>11.1 避免过多直接使用立即数</p>
<p>应该都使用常量，采用立即数不容易理解含义并容易出错。</p>
<p>11.2 枚举第一个成员要赋初始值</p>
<p>11.3 <code>addObject</code>之前要非空判断</p>
<p>11.4 release版本代码去掉NSLog打印，除了保留异常分支的NSLog</p>
<p>11.5 禁止在代码中直接写死字符串资源，必须要用字符串ID替代</p>
<p>应该考虑多语言国际化，尽量使用NSLocalizedStringFromTable实现对字符串ID的引用。</p>
<p>11.6 对于框架设计，逻辑层尽量与UI层分离，降低耦合度</p>
<p>11.7 同等难度下，优先考虑代码实现窗体创建</p>
<p>11.8 delegate对象使用weak，禁止使用strong</p>
<p>11.9 Controller独立于View和Controller</p>
<p>不要在View相关的类中添加过多的业务逻辑代码，这让代码的可重用性很差。Controller负责业务逻辑代码，且Controller的代码与View尽量无关。</p>
<p>11.10 init方法和dealloc方法是最常用的方法，所以将他们放在类实现的开始位置</p>
<p>11.11 使用空格将相同的变量、属性对齐，使用换行分组</p>
<p>11.12 很重要的一点：你所创建的项目的文件夹目录结构和Xcode中的虚拟Group文件夹的结构必须一致，这便于后期代码文件的维护，能够避免由于移动文件造成的引用编译错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/05/30/hengtian-ios-code-style-2/" data-id="cjpgo3oa8000jfzo0deegi45b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-usingswiftwithobjc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2016/04/12/usingswiftwithobjc/" class="article-date">
  <time datetime="2016-04-12T03:31:27.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2016/04/12/usingswiftwithobjc/">Objective-C与Swift混编实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###前言</p>
<p>由于Swift的语法趋于稳定，目前本人负责的项目也已经在小范围地引入Swift。关于混编过程中遇到的各种思考与选择，胡波的<a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=403474677&amp;idx=1&amp;sn=5163adb2d80aa5b4f0099f79e6d783e1&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">这篇文章</a>已经阐述得得比较全面了，看完文章回头看自己在混编过程中的各种选择，与胡先生的看法是一致的。在此梳理一下一些值得注意的小细节。</p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>基于Objective-C的工程一般都是将JSON转为Model,把数据以Model的形式在对象之间传递。当服务器传过来的值为空或者类型错误时，大部分解析框架都会将相对应的值置为nil。我们知道在Objective-C的世界里，向nil发送消息是不会引发任何错误的。</p>
<p>Objective-C中没有任何问题的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *GroupName;</span><br></pre></td></tr></table></figure>
<p>到了Swift的世界里，变成了:</p>
<p><img src="/content/images/2016/04/nullable-1.png" alt=""></p>
<p>没错，隐式解析的存在，导致了容错能力的下降。只要服务端回传的参数中有一个空字段，必然引发Crash。这简直是自寻死路。</p>
<p>因此我们需要在Objective-C中，将属性标上<code>nullable</code>，这样Swift中该属性变成了optional,然后采用<code>if let</code>或者<code>guard let</code>来安全地拆包。</p>
<blockquote>
<p>即使业务上决定了某些字段绝对不可能为null,也仍然要将其设为nullable。校验任何外来输入是编程时的基本准则之一。</p>
</blockquote>
<p>想必大家也想到了，这样一来，在混编的过程中，if let充斥着Swift的代码，虽然保证了安全，但一定程度上降低了开发效率。个人还在不断摸索解决这个问题的方法。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>在Objective-C的世界里，<code>@selector</code>是我们的老朋友了。但到了Swift中我们不得不这样来用<code>Selector</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.addTarget(<span class="keyword">self</span>, action: <span class="string">"resignFristResponder"</span>, forControlEvents: .<span class="type">EditingDidEndOnExit</span>)</span><br></pre></td></tr></table></figure>
<p>如果不仔细看，一定不会发现上面的代码中我错将<code>resignFirstResponder</code>写成了<code>resignFristResponder</code>。这在编译时不会出现任何提醒，但到了运行时会引起崩溃。</p>
<p>幸运的是，Swift2.2用<code>#selector</code>关键字替代了字符串反射。此时拼写错误可以被编译期正确地纠正了–因为编译期会检查到方法不存在，并报一个error。</p>
<p>你可以这样写一个不带参数的selector：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#selector(resignFirstResponder）</span><br></pre></td></tr></table></figure>
<p>如果是带参数的selector,则会稍微特别一点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#selector(textFieldDidChange(<span class="number">_</span>:)</span><br></pre></td></tr></table></figure>
<p>采用下划线来忽略参数名，但记得保留分号。</p>
<p>update:2016年06月22日</p>
<p>在Swift 3中，由于第一个参数也必须指定参数名，因此，selector的语法稍稍有一点点改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#selector(textFieldDidChange(textField:)</span><br></pre></td></tr></table></figure>
<p>有一点需要注意一下，Selector只支持反射Objective-C的方法，如果想要让#selector能正确识别Swift的方法，需要在方法前面加上<code>@objc</code>关键字</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>Swift得益于Module而避免了类的命名冲突。在用Swift编写代码的时候，应当遵循Apple官方的命名规范。例如类命名不需要在类名前加前缀。如果类也需要在Objective-C中被调用，可以用@objc关键字来为Objective-C生成对应的类名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>(<span class="type">PSLimitedTextField</span>) <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedTextField</span>: <span class="title">UITextField</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>同时API的设计也建议按照官方的<a href="https://swift.org/documentation/api-design-guidelines" target="_blank" rel="noopener">指导原则</a>来。我从开始写Objective-C时就尽量模仿Apple的命名方式，后来在Objective-C到Swift的自动桥接上尝到了甜头。比如说:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithName:(NSString *)name;</span><br></pre></td></tr></table></figure>
<p>被自动桥接成了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(name: <span class="type">String</span>)</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>如果仔细对比Objective-C和Swift的接口，你会发现有的类的工厂方法消失了，有的类的还在。这同样是由于命名的问题所导致的。Apple将那些同类名一致的工厂方法桥接成了init方法，将一些默认单词(default,standard,shared etc.)开头的工厂方法保留了下来。</p>
<p>如：<code>[NSDate date]</code>变成了<code>NSDate()</code>.</p>
<p>但<code>[NSUserDefaults standardUserDefaults]</code>,保留了下来，变成了<code>NSUserDefaults.standardUserDefaults()</code></p>
<p><a href="https://github.com/DeveloperPans/PSNumberPad" target="_blank" rel="noopener">PSNumberPad</a>就因为工厂方法的命名问题，没能自动桥接成Swift的方法。因此，在混编过程中，如果Objective-C的组件有可能被Swift调用的，需要妥善设计接口以便自动桥接。一个最佳实践是，多采用<strong>convince initialzer</strong>替代工厂方法。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>在混编的过程中，大部分问题你可以在<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" target="_blank" rel="noopener">这里</a>找到想要的答案。再一次感谢Apple完善的文档！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shengpan.net/2016/04/12/usingswiftwithobjc/" data-id="cjpgo3o9q0009fzo0r0ung1b2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="extend next" rel="next" href="page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2015/09/">九月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2016/10/07/https/">全站 HTTPS 边做边记</a>
          </li>
        
          <li>
            <a href="2016/09/14/auto-code-review/">iOS 持续集成系列 - 自动化 Code Review</a>
          </li>
        
          <li>
            <a href="2016/09/06/string-comparable/">深挖 Swift 中的字符串可比性</a>
          </li>
        
          <li>
            <a href="2016/09/05/swift-max/">从 Swift 中的 max(_:_:) 看设计哲学</a>
          </li>
        
          <li>
            <a href="2016/09/04/ios-ci-index/">iOS 持续集成系列 - 开篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 PPPan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="fancybox/jquery.fancybox.css">
  <script src="fancybox/jquery.fancybox.pack.js"></script>


<script src="js/script.js"></script>



  </div>
</body>
</html>